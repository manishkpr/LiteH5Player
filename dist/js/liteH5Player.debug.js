/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "./node_modules/preact/dist/preact.esm.js":
/*!************************************************!*\
  !*** ./node_modules/preact/dist/preact.esm.js ***!
  \************************************************/
/*! exports provided: default, h, createElement, cloneElement, Component, render, rerender, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rerender", function() { return rerender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return options; });
/** Virtual DOM Node */
function VNode() {}

/** Global options
 *	@public
 *	@namespace options {Object}
 */
var options = {

	/** If `true`, `prop` changes trigger synchronous component updates.
  *	@name syncComponentUpdates
  *	@type Boolean
  *	@default true
  */
	//syncComponentUpdates: true,

	/** Processes all created VNodes.
  *	@param {VNode} vnode	A newly-created VNode to normalize/process
  */
	//vnode(vnode) { }

	/** Hook invoked after a component is mounted. */
	// afterMount(component) { }

	/** Hook invoked after the DOM is updated with a component's latest render. */
	// afterUpdate(component) { }

	/** Hook invoked immediately before a component is unmounted. */
	// beforeUnmount(component) { }
};

var stack = [];

var EMPTY_CHILDREN = [];

/**
 * JSX/hyperscript reviver.
 * @see http://jasonformat.com/wtf-is-jsx
 * Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
 *
 * Note: this is exported as both `h()` and `createElement()` for compatibility reasons.
 *
 * Creates a VNode (virtual DOM element). A tree of VNodes can be used as a lightweight representation
 * of the structure of a DOM tree. This structure can be realized by recursively comparing it against
 * the current _actual_ DOM structure, and applying only the differences.
 *
 * `h()`/`createElement()` accepts an element name, a list of attributes/props,
 * and optionally children to append to the element.
 *
 * @example The following DOM tree
 *
 * `<div id="foo" name="bar">Hello!</div>`
 *
 * can be constructed using this function as:
 *
 * `h('div', { id: 'foo', name : 'bar' }, 'Hello!');`
 *
 * @param {string} nodeName	An element name. Ex: `div`, `a`, `span`, etc.
 * @param {Object} attributes	Any attributes/props to set on the created element.
 * @param rest			Additional arguments are taken to be children to append. Can be infinitely nested Arrays.
 *
 * @public
 */
function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack.length) stack.push(attributes.children);
		delete attributes.children;
	}
	while (stack.length) {
		if ((child = stack.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	// if a "vnode hook" is defined, pass every created VNode to it
	if (options.vnode !== undefined) options.vnode(p);

	return p;
}

/**
 *  Copy all properties from `props` onto `obj`.
 *  @param {Object} obj		Object onto which properties should be copied.
 *  @param {Object} props	Object from which to copy properties.
 *  @returns obj
 *  @private
 */
function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

/**
 * Call a function asynchronously, as soon as possible. Makes
 * use of HTML Promise to schedule the callback if available,
 * otherwise falling back to `setTimeout` (mainly for IE<11).
 *
 * @param {Function} callback
 */
var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

/**
 * Clones the given VNode, optionally adding attributes/props and replacing its children.
 * @param {VNode} vnode		The virtual DOM element to clone
 * @param {Object} props	Attributes/props to add when cloning
 * @param {VNode} rest		Any additional arguments will be used as replacement children.
 */
function cloneElement(vnode, props) {
  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}

// DOM properties that should NOT have "px" added when numeric
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

/** Managed queue of dirty components to be re-rendered */

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(options.debounceRendering || defer)(rerender);
	}
}

function rerender() {
	var p,
	    list = items;
	items = [];
	while (p = list.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

/**
 * Check if two nodes are equivalent.
 *
 * @param {Node} node			DOM Node to compare
 * @param {VNode} vnode			Virtual DOM node to compare
 * @param {boolean} [hydrating=false]	If true, ignores component constructors when comparing.
 * @private
 */
function isSameNodeType(node, vnode, hydrating) {
  if (typeof vnode === 'string' || typeof vnode === 'number') {
    return node.splitText !== undefined;
  }
  if (typeof vnode.nodeName === 'string') {
    return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
  }
  return hydrating || node._componentConstructor === vnode.nodeName;
}

/**
 * Check if an Element has a given nodeName, case-insensitively.
 *
 * @param {Element} node	A DOM Element to inspect the name of.
 * @param {String} nodeName	Unnormalized name to compare against.
 */
function isNamedNode(node, nodeName) {
  return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

/**
 * Reconstruct Component-style `props` from a VNode.
 * Ensures default/fallback values from `defaultProps`:
 * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
 *
 * @param {VNode} vnode
 * @returns {Object} props
 */
function getNodeProps(vnode) {
  var props = extend({}, vnode.attributes);
  props.children = vnode.children;

  var defaultProps = vnode.nodeName.defaultProps;
  if (defaultProps !== undefined) {
    for (var i in defaultProps) {
      if (props[i] === undefined) {
        props[i] = defaultProps[i];
      }
    }
  }

  return props;
}

/** Create an element with the given nodeName.
 *	@param {String} nodeName
 *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
 *	@returns {Element} node
 */
function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

/** Remove a child node from its parent if attached.
 *	@param {Element} node		The node to remove
 */
function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

/** Set a named attribute on the given Node, with special behavior for some names and event handlers.
 *	If `value` is `null`, the attribute/handler will be removed.
 *	@param {Element} node	An element to mutate
 *	@param {string} name	The name/key to set, such as an event or attribute name
 *	@param {any} old	The last value that was set for this name/node pair
 *	@param {any} value	An attribute value, such as a function to be used as an event handler
 *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
 *	@private
 */
function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') {
		// ignore
	} else if (name === 'ref') {
		if (old) old(null);
		if (value) value(node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		setProperty(node, name, value == null ? '' : value);
		if (value == null || value === false) node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

/** Attempt to set a DOM property to the given value.
 *	IE & FF throw for certain property-value combinations.
 */
function setProperty(node, name, value) {
	try {
		node[name] = value;
	} catch (e) {}
}

/** Proxy an event to hooked event handlers
 *	@private
 */
function eventProxy(e) {
	return this._listeners[e.type](options.event && options.event(e) || e);
}

/** Queue of components that have been mounted and are awaiting componentDidMount */
var mounts = [];

/** Diff recursion count, used to track the end of the diff cycle. */
var diffLevel = 0;

/** Global flag indicating if the diff is currently within an SVG */
var isSvgMode = false;

/** Global flag indicating if the diff is performing hydration */
var hydrating = false;

/** Invoke queued componentDidMount lifecycle methods */
function flushMounts() {
	var c;
	while (c = mounts.pop()) {
		if (options.afterMount) options.afterMount(c);
		if (c.componentDidMount) c.componentDidMount();
	}
}

/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
 *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
 *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
 *	@returns {Element} dom			The created/mutated element
 *	@private
 */
function diff(dom, vnode, context, mountAll, parent, componentRoot) {
	// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
	if (!diffLevel++) {
		// when first starting the diff, check if we're diffing an SVG or within an SVG
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		// hydration is indicated by the existing element to be diffed not having a prop cache
		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	// append the element if its a new parent
	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	// diffLevel being reduced to 0 means we're exiting the diff
	if (! --diffLevel) {
		hydrating = false;
		// invoke queued componentDidMount lifecycle methods
		if (!componentRoot) flushMounts();
	}

	return ret;
}

/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	// empty values (null, undefined, booleans) render as empty Text nodes
	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	// Fast case: Strings & Numbers create/update Text nodes.
	if (typeof vnode === 'string' || typeof vnode === 'number') {

		// update if it's already a Text node:
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			// it wasn't a Text node: replace it with one and recycle the old Element
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	// If the VNode represents a Component, perform a component diff:
	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	// Tracks entering and exiting SVG namespace when descending through the tree.
	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	// If there's no existing element or it's the wrong type, create a new one:
	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			// move children into the replacement node
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			} // if the previous Element was mounted into the DOM, replace it inline
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			// recycle the old element (skips non-Element node types)
			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	// Optimization: fast-path for elements containing a single TextNode:
	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	}
	// otherwise, if there are existing or new children, diff them:
	else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	// Apply attributes/props from VNode to the DOM Element:
	diffAttributes(out, vnode.attributes, props);

	// restore previous SVG mode: (in case we're exiting an SVG namespace)
	isSvgMode = prevSvgMode;

	return out;
}

/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
 *	@param {Element} dom			Element whose children should be compared & mutated
 *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
 *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
 *	@param {Boolean} mountAll
 *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
 */
function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	// Build up a map of keyed children and an Array of unkeyed children:
	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			// attempt to find a node based on key matching
			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			}
			// attempt to pluck a node of the same type from the existing children
			else if (!child && min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			// morph the matched/found/created DOM child to match vchild (deep)
			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	// remove unused keyed children:
	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	// remove orphaned unkeyed children:
	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

/** Recursively recycle (or just unmount) a node and its descendants.
 *	@param {Node} node						DOM node to start unmount/removal from
 *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
 */
function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		// if node is owned by a Component, unmount that component (ends up recursing back here)
		unmountComponent(component);
	} else {
		// If the node's VNode had a ref function, invoke it with null here.
		// (this is part of the React spec, and smart for unsetting references)
		if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

/** Recollect/unmount all children.
 *	- we use .lastChild here because it causes less reflow than .firstChild
 *	- it's also cheaper than accessing the .childNodes Live NodeList
 */
function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

/** Apply differences in attributes from a VNode to the given DOM Element.
 *	@param {Element} dom		Element with attributes to diff `attrs` against
 *	@param {Object} attrs		The desired end-state key-value attribute pairs
 *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
 */
function diffAttributes(dom, attrs, old) {
	var name;

	// remove attributes no longer present on the vnode by setting them to undefined
	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	// add new & update changed attributes
	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

/** Retains a pool of Components for re-use, keyed on component name.
 *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
 *	@private
 */
var components = {};

/** Reclaim a component for later re-use by the recycler. */
function collectComponent(component) {
	var name = component.constructor.name;
	(components[name] || (components[name] = [])).push(component);
}

/** Create a component. Normalizes differences between PFC's and classful Components. */
function createComponent(Ctor, props, context) {
	var list = components[Ctor.name],
	    inst;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	if (list) {
		for (var i = list.length; i--;) {
			if (list[i].constructor === Ctor) {
				inst.nextBase = list[i].nextBase;
				list.splice(i, 1);
				break;
			}
		}
	}
	return inst;
}

/** The `.render()` method for a PFC backing instance. */
function doRender(props, state, context) {
	return this.constructor(props, context);
}

/** Set a component's `props` (generally derived from JSX attributes).
 *	@param {Object} props
 *	@param {Object} [opts]
 *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
 *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
 */
function setComponentProps(component, props, opts, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	if (component.__ref = props.ref) delete props.ref;
	if (component.__key = props.key) delete props.key;

	if (!component.base || mountAll) {
		if (component.componentWillMount) component.componentWillMount();
	} else if (component.componentWillReceiveProps) {
		component.componentWillReceiveProps(props, context);
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (opts !== 0) {
		if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	if (component.__ref) component.__ref(component);
}

/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
 *	@param {Component} component
 *	@param {Object} [opts]
 *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
 *	@private
 */
function renderComponent(component, opts, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    rendered,
	    inst,
	    cbase;

	// if updating
	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		// context to pass to the child, can be updated via (grand-)parent component
		if (component.getChildContext) {
			context = extend(extend({}, context), component.getChildContext());
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {
			// set up high order component link

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			// destroy high order component link
			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || opts === 1) {
				if (cbase) cbase._component = null;
				base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.unshift(component);
	} else if (!skip) {
		// Ensure that pending componentDidMount() hooks of child components
		// are called before the componentDidUpdate() hook in the parent.
		// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
		// flushMounts();

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, previousContext);
		}
		if (options.afterUpdate) options.afterUpdate(component);
	}

	if (component._renderCallbacks != null) {
		while (component._renderCallbacks.length) {
			component._renderCallbacks.pop().call(component);
		}
	}

	if (!diffLevel && !isChild) flushMounts();
}

/** Apply the Component referenced by a VNode to the DOM.
 *	@param {Element} dom	The DOM node to mutate
 *	@param {VNode} vnode	A Component-referencing VNode
 *	@returns {Element} dom	The created/mutated element
 *	@private
 */
function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;
			// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

/** Remove a component from the DOM and recycle it.
 *	@param {Component} component	The Component instance to unmount
 *	@private
 */
function unmountComponent(component) {
	if (options.beforeUnmount) options.beforeUnmount(component);

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	// recursively tear down & recollect high-order component children:
	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

		component.nextBase = base;

		removeNode(base);
		collectComponent(component);

		removeChildren(base);
	}

	if (component.__ref) component.__ref(null);
}

/** Base Component class.
 *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
 *	@public
 *
 *	@example
 *	class MyFoo extends Component {
 *		render(props, state) {
 *			return <div />;
 *		}
 *	}
 */
function Component(props, context) {
	this._dirty = true;

	/** @public
  *	@type {object}
  */
	this.context = context;

	/** @public
  *	@type {object}
  */
	this.props = props;

	/** @public
  *	@type {object}
  */
	this.state = this.state || {};
}

extend(Component.prototype, {

	/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
  *	@param {object} nextProps
  *	@param {object} nextState
  *	@param {object} nextContext
  *	@returns {Boolean} should the component re-render
  *	@name shouldComponentUpdate
  *	@function
  */

	/** Update component state by copying properties from `state` to `this.state`.
  *	@param {object} state		A hash of state properties to update with new values
  *	@param {function} callback	A function to be called once component state is updated
  */
	setState: function setState(state, callback) {
		var s = this.state;
		if (!this.prevState) this.prevState = extend({}, s);
		extend(s, typeof state === 'function' ? state(s, this.props) : state);
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		enqueueRender(this);
	},


	/** Immediately perform a synchronous re-render of the component.
  *	@param {function} callback		A function to be called after component is re-rendered.
  *	@private
  */
	forceUpdate: function forceUpdate(callback) {
		if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
		renderComponent(this, 2);
	},


	/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
  *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
  *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
  *	@param {object} state		The component's current state
  *	@param {object} context		Context object (if a parent component has provided context)
  *	@returns VNode
  */
	render: function render() {}
});

/** Render JSX into a `parent` Element.
 *	@param {VNode} vnode		A (JSX) VNode to render
 *	@param {Element} parent		DOM element to render into
 *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
 *	@public
 *
 *	@example
 *	// render a div into <body>:
 *	render(<div id="hello">hello!</div>, document.body);
 *
 *	@example
 *	// render a "Thing" component into #foo:
 *	const Thing = ({ name }) => <span>{ name }</span>;
 *	render(<Thing name="one" />, document.querySelector('#foo'));
 */
function render(vnode, parent, merge) {
  return diff(merge, vnode, {}, false, parent, false);
}

var preact = {
	h: h,
	createElement: h,
	cloneElement: cloneElement,
	Component: Component,
	render: render,
	rerender: rerender,
	options: options
};

/* harmony default export */ __webpack_exports__["default"] = (preact);

//# sourceMappingURL=preact.esm.js.map


/***/ }),

/***/ "./node_modules/resize-sensor/ResizeSensor.min.js":
/*!********************************************************!*\
  !*** ./node_modules/resize-sensor/ResizeSensor.min.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(a,b){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return a.returnExportsGlobal=b()}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(this,function(){var a=function(){"use strict";function a(){this.q=[],this.add=function(a){this.q.push(a)};var a,b;this.call=function(){for(a=0,b=this.q.length;b>a;a++)this.q[a].call()}}function b(a,b){return a.currentStyle?a.currentStyle[b]:window.getComputedStyle?window.getComputedStyle(a,null).getPropertyValue(b):a.style[b]}function c(c,e){if(c.resizedAttached){if(c.resizedAttached)return void c.resizedAttached.add(e)}else c.resizedAttached=new a,c.resizedAttached.add(e);c.resizeSensor=document.createElement("div"),c.resizeSensor.className="resize-sensor";var f="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden; opacity: 0;",g="position: absolute; left: 0; top: 0; transition: 0s;";c.resizeSensor.style.cssText=f,c.resizeSensor.innerHTML='<div class="resize-sensor-expand" style="'+f+'"><div style="'+g+'"></div></div><div class="resize-sensor-shrink" style="'+f+'"><div style="'+g+' width: 200%; height: 200%"></div></div>',c.appendChild(c.resizeSensor),"static"==b(c,"position")&&(c.style.position="relative");var h=c.resizeSensor.childNodes[0],i=h.childNodes[0],j=c.resizeSensor.childNodes[1],k=function(){i.style.width=1e5+"px",i.style.height=1e5+"px",h.scrollLeft=1e5,h.scrollTop=1e5,j.scrollLeft=1e5,j.scrollTop=1e5};k();var l=!1,m=function(){c.resizedAttached&&(l&&(c.resizedAttached.call(),l=!1),d(m))};d(m);var n,o,p,q,r=function(){((p=c.offsetWidth)!=n||(q=c.offsetHeight)!=o)&&(l=!0,n=p,o=q),k()},s=function(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener(b,c)};s(h,"scroll",r),s(j,"scroll",r)}var d=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(a){return window.setTimeout(a,20)},e=function(a,b){var d=this,e=Object.prototype.toString.call(a),f=d._isCollectionTyped="[object Array]"===e||"[object NodeList]"===e||"[object HTMLCollection]"===e||"undefined"!=typeof jQuery&&a instanceof window.jQuery||"undefined"!=typeof Elements&&a instanceof window.Elements;if(d._element=a,f)for(var g=0,h=a.length;h>g;g++)c(a[g],b);else c(a,b)};return e.prototype.detach=function(){var a=this,b=a._isCollectionTyped,c=a._element;if(b)for(var d=0,f=c.length;f>d;d++)e.detach(c[d]);else e.detach(c)},e.detach=function(a){a.resizeSensor&&(a.removeChild(a.resizeSensor),delete a.resizeSensor,delete a.resizedAttached)},e}();return a});

/***/ }),

/***/ "./node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************!*\
  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/;?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\((\/\\*.*?\\*\/)?\s?.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./node_modules/webworkify/index.js":
/*!******************************************!*\
  !*** ./node_modules/webworkify/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            'function(require,module,exports){' + fn + '(self); }',
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        'function(require,module,exports){' +
            // try to call default if defined to also support babel esmodule exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);' +
        '}',
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};


/***/ }),

/***/ "./src/Player.js":
/*!***********************!*\
  !*** ./src/Player.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ./core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ./core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ./core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ./core/errors */ "./src/core/errors.js");

var _Debug = __webpack_require__(/*! ./core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _fetch_loader = __webpack_require__(/*! ./utils/fetch_loader */ "./src/utils/fetch_loader.js");

var _fetch_loader2 = _interopRequireDefault(_fetch_loader);

var _fragment_loader = __webpack_require__(/*! ./loader/fragment_loader */ "./src/loader/fragment_loader.js");

var _fragment_loader2 = _interopRequireDefault(_fragment_loader);

var _playlist_loader = __webpack_require__(/*! ./loader/playlist_loader */ "./src/loader/playlist_loader.js");

var _playlist_loader2 = _interopRequireDefault(_playlist_loader);

var _track_loader = __webpack_require__(/*! ./loader/track_loader */ "./src/loader/track_loader.js");

var _track_loader2 = _interopRequireDefault(_track_loader);

var _playback_controller = __webpack_require__(/*! ./controller/playback_controller */ "./src/controller/playback_controller.js");

var _playback_controller2 = _interopRequireDefault(_playback_controller);

var _eme_controller = __webpack_require__(/*! ./controller/eme_controller */ "./src/controller/eme_controller.js");

var _eme_controller2 = _interopRequireDefault(_eme_controller);

var _ads_controller = __webpack_require__(/*! ./controller/ads_controller */ "./src/controller/ads_controller.js");

var _ads_controller2 = _interopRequireDefault(_ads_controller);

var _parser_controller = __webpack_require__(/*! ./controller/parser_controller */ "./src/controller/parser_controller.js");

var _parser_controller2 = _interopRequireDefault(_parser_controller);

var _level_controller = __webpack_require__(/*! ./controller/level_controller */ "./src/controller/level_controller.js");

var _level_controller2 = _interopRequireDefault(_level_controller);

var _buffer_controller = __webpack_require__(/*! ./controller/buffer_controller */ "./src/controller/buffer_controller.js");

var _buffer_controller2 = _interopRequireDefault(_buffer_controller);

var _stream_controller = __webpack_require__(/*! ./controller/stream_controller */ "./src/controller/stream_controller.js");

var _stream_controller2 = _interopRequireDefault(_stream_controller);

var _texttrack_controller = __webpack_require__(/*! ./controller/texttrack_controller */ "./src/controller/texttrack_controller.js");

var _texttrack_controller2 = _interopRequireDefault(_texttrack_controller);

var _thumbnail_controller = __webpack_require__(/*! ./controller/thumbnail_controller */ "./src/controller/thumbnail_controller.js");

var _thumbnail_controller2 = _interopRequireDefault(_thumbnail_controller);

var _videoplayer = __webpack_require__(/*! ./videoplayer */ "./src/videoplayer.js");

var _videoplayer2 = _interopRequireDefault(_videoplayer);

var _cast_sender = __webpack_require__(/*! ./cast/cast_sender */ "./src/cast/cast_sender.js");

var _cast_sender2 = _interopRequireDefault(_cast_sender);

var _timeRanges = __webpack_require__(/*! ./utils/timeRanges */ "./src/utils/timeRanges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _common_utils = __webpack_require__(/*! ./utils/common_utils */ "./src/utils/common_utils.js");

var _common_utils2 = _interopRequireDefault(_common_utils);

var _ui_basic = __webpack_require__(/*! ./ui_basic/js/ui_basic */ "./src/ui_basic/js/ui_basic.js");

var _license_controller = __webpack_require__(/*! ./controller/license_controller */ "./src/controller/license_controller.js");

var _license_controller2 = _interopRequireDefault(_license_controller);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//////////////////////////////////////////////////////////////////////////////


// UI


// Utils
function Player(idContainer) {
  var context_ = oldmtn; //{ flag: 'player' };
  var playerContainer_ = document.getElementById(idContainer);

  // Create internal basic UI elements first.
  (0, _ui_basic.dom_initUI)(playerContainer_);

  var media_ = document.querySelector('.vop-video');
  var adContainer_ = document.querySelector('.vop-ads-container');

  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();
  var licenseController_ = new _license_controller2.default();

  var playlistLoader_ = void 0;
  var textTrackLoader_ = void 0;
  var fragmentLoader_ = void 0;

  var bufferController_ = void 0;
  var emeController_ = void 0;
  var parserController_ = void 0;
  var levelController_ = void 0;
  var streamController_ = void 0;
  var playbackController_ = void 0;
  var textTrackController_ = void 0;
  var thumbnailController_ = void 0;

  // chromecast
  var castSender_ = void 0;
  var flagCastConnected_ = false;

  // ads
  var adsEngine_ = void 0;

  // Autoplay reference
  var autoplayAllowed_ = void 0;
  var autoplayRequiresMuted_ = void 0;

  // player state machine
  var playerState_ = 'idle'; // 'idle', 'opening', 'opened', 'playing', 'paused', 'ended'

  // open completed flag
  var flagContentOpenComplete_ = false;
  var flagAdOpenComplete_ = false;
  var flagPlayedOnce_ = false;

  function setup() {
    // init internal configuration

    context_.media = media_;
  }

  function init(cfg) {
    context_.cfg = cfg;

    initComponent();
    addEventListeners();
  }

  function uninit() {}

  function open(mediaCfg) {
    debug_.log('Player, +open');

    if (!licenseController_.checkUrl(document.domain)) {
      eventBus_.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.LICENSE_ERROR
      });
      return false;
    }

    // preprocess the mediaCfg
    mediaCfg.drm = mediaCfg.drm || {};

    context_.mediaCfg = mediaCfg;

    emeController_.setDrmInfo(mediaCfg);
    // detect parser type
    eventBus_.trigger(_events2.default.FINDING_PARSER, {
      url: mediaCfg.url
    });

    if (mediaCfg.tracks) {
      // load subtitles tracks
      for (var i = 0; i < mediaCfg.tracks.length; i++) {
        var track = mediaCfg.tracks[i];
        //
        track.id = i.toString();
        if (!track.lang) {
          if (track.label) {
            track.lang = track.label;
          } else {
            track.lang = track.label = 'texttrack_' + i.toString();
          }
        }
        if (track.kind === 'subtitles') {
          eventBus_.trigger(_events2.default.TRACK_LOADING, {
            track: track
          });
        }
      }

      // load thumbnail tracks
      for (var _i = 0; _i < mediaCfg.tracks.length; _i++) {
        var _track = mediaCfg.tracks[_i];
        if (_track.kind === 'thumbnails') {
          eventBus_.trigger(_events2.default.THUMBNAIL_LOADING, {
            track: _track
          });
        }
      }
    }

    if (adsEngine_) {
      adsEngine_.requestAds();
    } else {
      flagAdOpenComplete_ = true;
    }
    flagPlayedOnce_ = false;
    flagContentOpenComplete_ = false;

    updateState('opening');
  }

  function close() {
    // if (adsEngine_) {
    //   adsEngine_.close();
    // }
    // if (streamController_) {
    //   streamController_.stopLoad();
    // }
    // if (bufferController_) {
    //   bufferController_.close();
    // }
    // if (playbackController_) {
    //   playbackController_.close();
    // }

    // context_.mediaCfg = null;

    updateState('idle');
  }

  function updateState(state) {
    var oldState = playerState_;
    var newState = state;

    playerState_ = newState;
    eventBus_.trigger(_events2.default.STATE_CHANGE, {
      oldState: oldState,
      newState: newState
    });
  }

  //////////////////////////////////////////////////////////////////////////////////
  // API
  function on(type, listener, scope) {
    eventBus_.on(type, listener, scope);
  }

  function off(type, listener, scope) {
    eventBus_.off(type, listener, scope);
  }

  function play() {
    if (flagCastConnected_) {
      castSender_.play();
    } else {
      if (!flagPlayedOnce_) {
        if (adsEngine_) {
          adsEngine_.playAd();
        } else {
          playbackController_.play();
        }
        flagPlayedOnce_ = true;
      } else {
        if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
          adsEngine_.play();
        } else {
          playbackController_.play();
        }
      }
    }
  }

  function pause() {
    if (flagCastConnected_) {
      castSender_.pause();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      adsEngine_.pause();
    } else {
      if (!playbackController_) {
        return;
      }
      playbackController_.pause();
    }
  }

  function isPaused() {
    if (flagCastConnected_) {
      return castSender_.isPaused();
    } else {
      if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
        return adsEngine_.isPaused();
      } else {
        if (!playbackController_) {
          return;
        }
        return playbackController_.isPaused();
      }
    }
  }

  function getPosition() {
    if (flagCastConnected_) {
      return castSender_.getPosition();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      return adsEngine_.getPosition();
    } else {
      if (!playbackController_) {
        return;
      }
      return playbackController_.getPosition();
    }
  }

  function getDuration() {
    if (flagCastConnected_) {
      return castSender_.getDuration();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      return adsEngine_.getDuration();
    } else {
      if (!playbackController_) {
        return;
      }
      return playbackController_.getDuration();
    }
  }

  function getSeekableRange() {
    if (!playbackController_) {
      return;
    }
    return playbackController_.getSeekableRange();
  }

  function getBufferedRanges() {
    if (!playbackController_) {
      return;
    }
    return playbackController_.getBufferedRanges();
  }

  function isEnded() {
    if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {} else {
      if (!playbackController_) {
        return;
      }
      return playbackController_.isEnded();
    }
  }

  function mute() {
    if (flagCastConnected_) {
      castSender_.mute();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      adsEngine_.mute();
    } else {
      if (!playbackController_) {
        return;
      }
      playbackController_.mute();
    }
  }

  function unmute() {
    if (flagCastConnected_) {
      castSender_.unmute();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      adsEngine_.unmute();
    } else {
      if (!playbackController_) {
        return;
      }
      playbackController_.unmute();
    }
  }

  function isMuted() {
    if (flagCastConnected_) {
      return castSender_.isMuted();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      return adsEngine_.isMuted();
    } else {
      if (!playbackController_) {
        return;
      }
      return playbackController_.isMuted();
    }
  }

  function setVolume(volume) {
    if (flagCastConnected_) {
      castSender_.setVolume(volume);
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      adsEngine_.setVolume(volume);
    } else {
      if (!playbackController_) {
        return;
      }
      playbackController_.setVolume(volume);
    }
  }

  function getVolume() {
    if (flagCastConnected_) {
      return castSender_.getVolume();
    } else if (adsEngine_ && adsEngine_.isPlayingAd() && adsEngine_.isLinearAd()) {
      return adsEngine_.getVolume();
    } else {
      if (!playbackController_) {
        return;
      }

      return playbackController_.getVolume();
    }
  }

  function setAudioPlaybackSpeed(speed) {
    playbackController_.setAudioPlaybackSpeed(speed);
  }

  function setPosition(pos) {
    if (flagCastConnected_) {
      castSender_.setPosition(pos);
    } else {
      playbackController_.setPosition(pos);
    }
  }

  function getWidth() {
    return playbackController_.videoWidth();
  }

  function getHeight() {
    return playbackController_.videoHeight();
  }

  function resize(width, height) {
    if (adsEngine_) {
      adsEngine_.resize(width, height);
    }
  }

  // ads
  function playAd() {
    if (adsEngine_) {
      adsEngine_.playAd();
    }

    // if (adsEngine_) {
    //     adsEngine_.playAd();
    // } else {

    // }
  }

  // subtitles
  function getSubtitleTracks() {
    return textTrackController_.getSubtitleTracks();
  }

  function getCurrentSubtitleTrack() {
    return textTrackController_.getCurrentSubtitleTrack();
  }

  function selectSubtitleTrack(id) {
    textTrackController_.selectSubtitleTrack(id);
  }

  // thumbnail
  function getThumbnail(time) {
    if (thumbnailController_) {
      return thumbnailController_.getThumbnail(time);
    } else {
      return undefined;
    }
  }

  // chromecast
  function castVideo() {
    castSender_.requestSession();
  }

  function castStop() {
    castSender_.stopSession();
  }

  function castInit(cfg) {
    castSender_.init(cfg);
  }

  function castOpen(mediaCfg) {
    castSender_.open(mediaCfg);
  }

  function castAdd() {
    castSender_.add();
  }

  function castPlay() {
    castSender_.play();
  }

  function castPause() {
    castSender_.pause();
  }

  function castSetPosition(time) {
    castSender_.setPosition(time);
  }

  function castTest() {
    castSender_.test();
  }

  // airplay
  function isAirplaySupported() {
    if (window.WebKitPlaybackTargetAvailabilityEvent) {
      return true;
    }
    return false;
  }

  function showPlaybackTargetPicker() {
    if (isAirplaySupported()) {
      var videoElement = media_;
      videoElement.webkitShowPlaybackTargetPicker();
    }
  }

  // pip
  function isPipSupported() {
    var videoElement = media_;
    if (videoElement && videoElement.webkitSupportsPresentationMode && typeof videoElement.webkitSetPresentationMode === 'function') {
      return true;
    }
    return false;
  }

  function setPipPresentation(show) {
    if (isPipSupported()) {
      var videoElement = media_;
      if (show && videoElement.webkitPresentationMode === 'inline') {
        videoElement.webkitSetPresentationMode('picture-in-picture');
      } else if (!show && videoElement.webkitPresentationMode === 'picture-in-picture') {
        videoElement.webkitSetPresentationMode('inline');
      }
    }
  }

  // 1. If loading UI when player is playing, need sync UI state to player state.
  function getState() {
    return playerState_;
  }

  function isFullscreen() {
    return document.fullscreenElement || document.msFullscreenElement || document.mozFullScreen || document.webkitIsFullScreen;
  }

  function getValidBufferPosition(currentPos) {
    if (adsEngine_ && adsEngine_.isLinearAd() && adsEngine_.isPlayingAd()) {
      return 0;
    } else {
      return playbackController_.getValidBufferPosition(currentPos);
    }
  }

  /////////////////////////////////////////////////////////////////////////////////
  // private functions
  function initComponent() {
    playlistLoader_ = (0, _playlist_loader2.default)(context_).getInstance();
    textTrackLoader_ = (0, _track_loader2.default)(context_).getInstance();
    fragmentLoader_ = (0, _fragment_loader2.default)(context_).create();

    playbackController_ = (0, _playback_controller2.default)(context_).getInstance();
    textTrackController_ = (0, _texttrack_controller2.default)(context_).getInstance();
    bufferController_ = (0, _buffer_controller2.default)(context_).getInstance();
    emeController_ = (0, _eme_controller2.default)(context_).getInstance();
    parserController_ = (0, _parser_controller2.default)(context_).getInstance();
    levelController_ = (0, _level_controller2.default)(context_).getInstance();
    streamController_ = (0, _stream_controller2.default)(context_).getInstance();
    thumbnailController_ = (0, _thumbnail_controller2.default)(context_).getInstance();

    // html5 video poster
    if (context_.cfg.poster) {
      media_.poster = context_.cfg.poster;
    }
    // ads
    if (context_.cfg.advertising) {
      adsEngine_ = (0, _ads_controller2.default)(context_).getInstance(adContainer_, media_, context_.cfg.advertising);
    }
    // chromecast
    if (window.cast && window.cast.__platform__) {
      // receiver don't need new CastSender
    } else {
      if (context_.cfg.cast && context_.cfg.cast.applicationID) {
        castSender_ = (0, _cast_sender2.default)(context_).getInstance(context_.cfg.cast.applicationID);
      }
    }
  }

  function addEventListeners() {
    // html5 event
    eventBus_.on(_events2.default.MEDIA_CANPLAY, onMediaCanPlay, {});
    eventBus_.on(_events2.default.MEDIA_ENDED, onMediaEnded, {});
    eventBus_.on(_events2.default.MEDIA_WAITING, onMediaWaiting, {});
    eventBus_.on(_events2.default.MEDIA_PLAYING, onMediaPlaying, {});
    eventBus_.on(_events2.default.MEDIA_PAUSED, onMediaPaused, {});

    // controller events
    eventBus_.on(_events2.default.FOUND_PARSER, onFoundParser);
    eventBus_.on(_events2.default.MEDIA_ATTACHED, onMediaAttached);

    // ads events
    eventBus_.on(_events2.default.AD_CONTENT_PAUSE_REQUESTED, onAdContentPauseRequested, {});
    eventBus_.on(_events2.default.AD_CONTENT_RESUME_REQUESTED, onAdContentResumeRequested, {});
    eventBus_.on(_events2.default.AD_LOADING_COMPLETE, onAdLoadingComplete, {});
    eventBus_.on(_events2.default.AD_PAUSED, onAdPaused, {});
    eventBus_.on(_events2.default.AD_RESUMED, onAdResumed, {});

    // chromecast
    eventBus_.on(_events2.default.CAST_CONNECTED, onCastConnected);
    eventBus_.on(_events2.default.CAST_DISCONNECTED, onCastDisconnected);

    // fullscreen listener
    document.addEventListener('fullscreenchange', onFullScreenChange);
    document.addEventListener('mozfullscreenchange', onFullScreenChange);
    document.addEventListener('webkitfullscreenchange', onFullScreenChange);
    document.addEventListener('msfullscreenchange', onFullScreenChange);
    document.addEventListener('MSFullscreenChange', onFullScreenChange);
  }

  function removeEventListeners() {
    // html5 event
    eventBus_.off(_events2.default.MEDIA_CANPLAY, onMediaCanPlay, {});
    eventBus_.off(_events2.default.MEDIA_ENDED, onMediaEnded, {});
    eventBus_.off(_events2.default.MEDIA_WAITING, onMediaWaiting, {});
    eventBus_.off(_events2.default.MEDIA_PLAYING, onMediaPlaying, {});
    eventBus_.off(_events2.default.MEDIA_PAUSED, onMediaPaused, {});

    // controller events
    eventBus_.off(_events2.default.FOUND_PARSER, onFoundParser);
    eventBus_.off(_events2.default.MEDIA_ATTACHED, onMediaAttached);

    // ads events
    eventBus_.off(_events2.default.AD_CONTENT_PAUSE_REQUESTED, onAdContentPauseRequested, {});
    eventBus_.off(_events2.default.AD_CONTENT_RESUME_REQUESTED, onAdContentResumeRequested, {});
    eventBus_.off(_events2.default.AD_LOADING_COMPLETE, onAdLoadingComplete, {});
    eventBus_.off(_events2.default.AD_PAUSED, onAdPaused, {});
    eventBus_.off(_events2.default.AD_RESUMED, onAdResumed, {});

    document.removeEventListener('fullscreenchange', onFullScreenChange);
    document.removeEventListener('mozfullscreenchange', onFullScreenChange);
    document.removeEventListener('webkitfullscreenchange', onFullScreenChange);
    document.removeEventListener('msfullscreenchange', onFullScreenChange);
    document.removeEventListener('MSFullscreenChange', onFullScreenChange);
  }

  function onFullScreenChange() {
    // we should not rely on clientWidth or clientHeight to set ad metrics when fullscreen change event triggered.
    eventBus_.trigger(_events2.default.FULLSCREEN_CHANGE);
  }

  //////////////////////////////////////////////////////////////////////////////////////////
  // Begin -- internal events listener functions
  function onMediaCanPlay() {
    if (!flagContentOpenComplete_) {
      flagContentOpenComplete_ = true;
      processOpenComplete();
    }
  }

  function onMediaEnded() {
    updateState('ended');
  }

  function onMediaWaiting() {}

  function onMediaPlaying() {
    updateState('playing');
  }

  function onMediaPaused() {
    updateState('paused');
  }

  function onFoundParser(data) {
    var parser = data.parser;

    context_.parser = parser;
    switch (parser.type) {
      case 'dash':
      case 'hls':
        eventBus_.trigger(_events2.default.MEDIA_ATTACHING, {
          media: media_
        });
        break;
      case 'pd':
        var vPlayer = (0, _videoplayer2.default)(context_).getInstance();
        vPlayer.setSrc(context_.mediaCfg.url);
        break;
      default:
        break;
    }
  }

  function onMediaAttached() {
    streamController_.startLoad();
  }

  function onAdContentPauseRequested() {
    playbackController_.pause();
  }

  function onAdContentResumeRequested() {
    if (!playbackController_.isEnded()) {
      playbackController_.play();
    }
  }

  function onAdLoadingComplete() {
    flagAdOpenComplete_ = true;
    processOpenComplete();
  }

  function onAdPaused() {
    updateState('paused');
  }

  function onAdResumed() {
    updateState('playing');
  }

  function onCastConnected() {
    flagCastConnected_ = true;
  }

  function onCastDisconnected() {
    flagCastConnected_ = false;
  }
  // End -- internal events listener functions

  function processOpenComplete() {
    if (flagContentOpenComplete_ && flagAdOpenComplete_) {
      // Emit event to outer.
      updateState('opened');

      if (context_.cfg.autoplay) {
        play();
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////
  // Title: debug function here
  function manualSchedule() {
    streamController_.manualSchedule();
  }

  function test() {
    eventBus_.trigger(_events2.default.TEST_MSG);

    // sample2
    // let fetch1 = FetchLoader(context_).create();

    // function sleep(numberMillis) {
    //     var now = new Date();
    //     var exitTime = now.getTime() + numberMillis;
    //     while (true) {
    //         now = new Date();
    //         if (now.getTime() > exitTime)
    //         return;
    //     }
    // }

    // let request = {
    //     url: 'http://localhost/2/hls/videoonly01/stream0.ts',
    //     cbProgress: function (chunkBytes) {
    //         console.log('cbProgress: ' + chunkBytes);
    //         sleep(5000);  //5
    //     },
    //     cbSuccess: function (totalBytes) {
    //         console.log('totalBytes: ' + totalBytes);
    //     }
    // };

    // fetch1.load(request);
  }

  function test2() {}

  function attribute() {
    var media = media_;
    debug_.log('media.buffered : ' + _timeRanges2.default.toString(media.buffered));
    debug_.log('media.seekable: ' + _timeRanges2.default.toString(media.seekable));

    bufferController_.setDuration(200);

    var a = 2;
    var b = a;
  }

  var instance = {
    init: init,
    uninit: uninit,
    open: open,
    close: close,
    on: on,
    off: off,
    play: play,
    pause: pause,
    isPaused: isPaused,
    getPosition: getPosition,
    setPosition: setPosition,
    getDuration: getDuration,
    getSeekableRange: getSeekableRange,
    getBufferedRanges: getBufferedRanges,
    isEnded: isEnded,
    mute: mute,
    unmute: unmute,
    isMuted: isMuted,
    setVolume: setVolume,
    getVolume: getVolume,
    setAudioPlaybackSpeed: setAudioPlaybackSpeed,
    // Resize
    getWidth: getWidth,
    getHeight: getHeight,
    resize: resize,
    isFullscreen: isFullscreen,
    // buffer
    getValidBufferPosition: getValidBufferPosition,
    // ads
    playAd: playAd,
    // subtitles
    getSubtitleTracks: getSubtitleTracks,
    getCurrentSubtitleTrack: getCurrentSubtitleTrack,
    selectSubtitleTrack: selectSubtitleTrack,
    // thumbnail
    getThumbnail: getThumbnail,
    // chromecast
    castVideo: castVideo,
    castStop: castStop,
    castInit: castInit,
    castOpen: castOpen,
    castAdd: castAdd,
    castPlay: castPlay,
    castPause: castPause,
    castSetPosition: castSetPosition,
    castTest: castTest,
    // pip(Safari only)
    setPipPresentation: setPipPresentation,
    // airplay(Safari only)
    showPlaybackTargetPicker: showPlaybackTargetPicker,
    // state Machine
    getState: getState,
    // debug
    manualSchedule: manualSchedule,
    test: test,
    test2: test2
  };

  setup();

  return instance;
}

// License
;

exports.default = Player;

/***/ }),

/***/ "./src/cast/cast_receiver.js":
/*!***********************************!*\
  !*** ./src/cast/cast_receiver.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _cast_utils = __webpack_require__(/*! ./cast_utils */ "./src/cast/cast_utils.js");

var _cast_utils2 = _interopRequireDefault(_cast_utils);

var _ui_tools = __webpack_require__(/*! ../ui/js/ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function printLog(msg) {
  console.log('CastReceiver: ' + msg);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
function CastReceiver(elementId) {
  printLog('receiver, constructor');

  var context_ = {};
  var eventBus_ = void 0;
  var debug_ = void 0;

  var elementId_ = elementId;
  var mediaElement_ = null;
  var receiverManager_ = null;
  var genericBus_ = null;
  var oldmtnBus_ = null;
  var mediaManager_ = null;
  var onLoadOrig_ = null;
  var onGetStatusOrig_ = null;
  var onMetadataLoadedOrig_ = null;
  var onStopOrig_ = null;
  var onLoadMetadataErrorOrig_ = null;
  var onErrorOrig_ = null;
  var evHandlers = {};
  var player_ = null;
  var isConnected_ = null;

  var omPlayer_ = void 0;
  var omUIEngine_ = void 0;

  function setup() {
    // init html5 reference
    eventBus_ = (0, _EventBus2.default)(context_).getInstance();
    debug_ = (0, _Debug2.default)(context_).getInstance();

    cast.player.api.setLoggerLevel(cast.player.api.LoggerLevel.DEBUG);
    cast.receiver.logger.setLevelValue(cast.receiver.LoggerLevel.DEBUG);

    // Init CastReceiverManager
    receiverManager_ = cast.receiver.CastReceiverManager.getInstance();
    receiverManager_.onReady = onReady_;
    receiverManager_.onSenderDisconnected = onSenderDisconnected_;
    receiverManager_.onVisibilityChanged = onVisibilityChanged_;

    // custom message bus
    printLog('CastUtils.GENERIC_MESSAGE_NAMESPACE: ' + _cast_utils2.default.GENERIC_MESSAGE_NAMESPACE);
    printLog('CastUtils.OLDMTN_MESSAGE_NAMESPACE: ' + _cast_utils2.default.OLDMTN_MESSAGE_NAMESPACE);

    oldmtnBus_ = receiverManager_.getCastMessageBus(_cast_utils2.default.OLDMTN_MESSAGE_NAMESPACE);
    oldmtnBus_.onMessage = onOldmtnMessage_;

    // // Init Video Element
    // let v = document.getElementById(elementId_);
    // mediaElement_ = v.querySelector('.h5p-video');
    // // mediaElement_.addEventListener('timeupdate', onTimeupdate,
    // //     false);

    // // Init MediaManager
    // mediaManager_ = new cast.receiver.MediaManager(mediaElement_);

    // // The default GENERIC_MESSAGE_NAMESPACE should called after creating MediaManager. 
    // genericBus_ = receiverManager_.getCastMessageBus(
    //         CastUtils.GENERIC_MESSAGE_NAMESPACE);
    // genericBus_.onMessage = onGenericMessage_;

    // onLoadOrig_ =
    //     mediaManager_.onLoad.bind(mediaManager_);
    // mediaManager_.onLoad = onLoad_;

    // onGetStatusOrig_ =
    //     mediaManager_.onGetStatus.bind(mediaManager_);
    // mediaManager_.onGetStatus = onGetStatus_;

    // onMetadataLoadedOrig_ =
    //     mediaManager_.onMetadataLoaded.bind(mediaManager_);
    // mediaManager_.onMetadataLoaded = onMetadataLoaded_;

    // onStopOrig_ =
    //     mediaManager_.onStop.bind(mediaManager_);
    // mediaManager_.onStop = onStop_;

    // onLoadMetadataErrorOrig_ =
    //     mediaManager_.onLoadMetadataError.bind(mediaManager_);
    // mediaManager_.onLoadMetadataError = onLoadMetadataError_;

    // onErrorOrig_ = mediaManager_.onError.bind(mediaManager_);
    // mediaManager_.onError = onError_;
  }

  function initPlayer() {
    omPlayer_ = new oldmtn.Player(elementId_);
    omUIEngine_ = new oldmtn.UIEngine(omPlayer_);
    omUIEngine_.installSkin();

    omPlayer_.on(_events2.default.STATE_CHANGE, onStateChange);
    omPlayer_.on(_events2.default.MEDIA_TIMEUPDATE, onMediaTimeupdated);
    omPlayer_.on(_events2.default.MEDIA_PLAYING, onMediaPlaying);
    omPlayer_.on(_events2.default.MEDIA_PAUSED, onMediaPaused);
    omPlayer_.on(_events2.default.MEDIA_SEEKING, onMediaSeeking);
    omPlayer_.on(_events2.default.MEDIA_SEEKED, onMediaSeeked);
    omPlayer_.on(_events2.default.MEDIA_VOLUME_CHANGED, onMediaVolumeChanged);
  }

  //
  function getMediaElement() {
    return mediaElement_;
  }

  function getMediaManager() {
    return mediaManager_;
  }

  function getPlayer() {
    return player_;
  }

  function onReady_() {
    printLog('onReady');
    isConnected_ = true;
  }

  function onSenderDisconnected_(event) {
    printLog('onSenderDisconnected');
    // When the last or only sender is connected to a receiver,
    // tapping Disconnect stops the app running on the receiver.
    if (receiverManager_.getSenders().length === 0 && event.reason === cast.receiver.system.DisconnectReason.REQUESTED_BY_SENDER) {
      receiverManager_.stop();
    }
  }

  function onStateChange(e) {
    var newState = e.newState;
    if (newState === 'opened') {
      e.position = omPlayer_.getPosition();
      e.duration = omPlayer_.getDuration();
      e.volume = omPlayer_.getVolume();
      e.muted = omPlayer_.isMuted();
      e.paused = omPlayer_.isPaused();
    }
    sendMessage_({
      type: _events2.default.STATE_CHANGE,
      data: e
    }, oldmtnBus_);
  }

  function onMediaTimeupdated() {
    var position = omPlayer_.getPosition();
    var duration = omPlayer_.getDuration();

    printLog('position: ' + position + ', duration: ' + duration);
    // send message to sender
    sendMessage_({
      type: _events2.default.MEDIA_TIMEUPDATE,
      data: {
        position: position,
        duration: duration
      }
    }, oldmtnBus_);
  }

  function onMediaPlaying() {
    sendMessage_({
      type: _events2.default.MEDIA_PLAYING
    }, oldmtnBus_);
  }

  function onMediaPaused() {
    sendMessage_({
      type: _events2.default.MEDIA_PAUSED
    }, oldmtnBus_);
  }

  function onMediaSeeking() {
    var position = omPlayer_.getPosition();
    var duration = omPlayer_.getDuration();

    sendMessage_({
      type: _events2.default.MEDIA_SEEKING,
      data: {
        position: position,
        duration: duration
      }
    }, oldmtnBus_);
  }

  function onMediaSeeked() {
    var position = omPlayer_.getPosition();
    var duration = omPlayer_.getDuration();

    sendMessage_({
      type: _events2.default.MEDIA_SEEKED,
      data: {
        position: position,
        duration: duration
      }
    }, oldmtnBus_);
  }

  function onMediaVolumeChanged() {
    var muted = omPlayer_.isMuted();
    var volume = omPlayer_.getVolume();
    sendMessage_({
      type: _events2.default.MEDIA_VOLUME_CHANGED,
      data: {
        muted: muted,
        volume: volume
      }
    }, oldmtnBus_);
  }

  function onSeekStart_() {
    printLog('onSeekStart');
  }

  function onSeekEnd_() {
    printLog('onSeekEnd');
  }

  function onVisibilityChanged_(event) {
    printLog('onVisibilityChanged');
    // if (!event.isVisible) {
    //     mediaElement_.pause();
    //     mediaManager_.broadcastStatus(false);
    // }
  }

  function onGenericMessage_(event) {
    printLog('+onGenericMessage_, type: ' + event.type + ', senderId: ' + event.senderId);
    return;

    // printLog('type: ' + event.data.type);
    // printLog('requestId: ' + event.data.requestId);
    // printLog('namespace: ' + event.namespace);
    // printLog('senderId: ' + event.senderId);

    // var message = CastUtils.deserialize(event.data);
    // printLog('+onGenericMessage_: ' + message['type']);

    // TODO(ismena): error message on duplicate request id from the same sender
    //switch (message['type']) {
    switch (event.data.type) {
      case 'PLAY':
        {
          mediaElement_.play();
        }
        break;
      case 'PAUSE':
        {
          mediaElement_.pause();
        }
        break;
      case 'LOAD':
        {
          var mediaInfo = event.data.media;
          var contentId = mediaInfo['contentId'];
          var manifestUri = contentId;

          // var mediaInfo = message['media'];
          // var contentId = mediaInfo['contentId'];
          // var currentTime = message['currentTime'];
          // var manifestUri = contentId;
          // sample
          // contentId: "http://10.2.72.104/7/hls/v8/gear1/test.m3u8"
          // contentType: "application/dash+xml"
          // metadata: Object
          // streamType: "BUFFERED"
          // var protocolFunc = CastReceiver.getProtocolFunction_(mediaInfo);
          // var host = new cast.player.api.Host({
          //   'url': manifestUri,
          //   'mediaElement': mediaElement_
          // });
          // player_ = new cast.player.api.Player(host);
          // player_.load(protocolFunc(host));
        }
        break;
      default:
        break;
    }
  }

  function onOldmtnMessage_(event) {
    var message = _cast_utils2.default.deserialize(event.data);
    var data = message.data;
    printLog('onOldmtnMessage_, event.data: ' + event.data);
    printLog('onOldmtnMessage_, message: ' + message);

    if (message.cmdType === 'init') {
      initPlayer(data);
      //printLog('poster: ' + message.poster);
      omPlayer_.init(data);
    } else if (message.cmdType === 'open') {
      omPlayer_.open(message);
    } else if (message.cmdType === 'add') {
      omPlayer_.manualSchedule();
    } else if (message.cmdType === 'play') {
      omPlayer_.play();
    } else if (message.cmdType === 'pause') {
      omPlayer_.pause();
    } else if (message.cmdType === 'playAd') {
      omPlayer_.playAd();
    } else if (message.cmdType === 'setPosition') {
      omPlayer_.setPosition(data.position);
    } else if (message.cmdType === 'setVolume') {
      omPlayer_.setVolume(data.volume);
    } else if (message.cmdType === 'mute') {
      omPlayer_.mute();
    } else if (message.cmdType === 'unmute') {
      omPlayer_.unmute();
    } else if (message.cmdType === 'test') {
      omPlayer_.test();
      // uiEngine_ = new oldmtn.UIEngine(omPlayer_);
      // uiEngine_.installSkin();
      // let v = document.querySelector('.html5-video-player');
      // UITools.removeClass(v, 'vop-autohide');
    }
    //oldmtnBus_.broadcast("abcd1234");
  }

  function sendMessage_(message, bus, opt_senderId) {
    // Cuts log spam when debugging the receiver UI in Chrome.
    if (!isConnected_) {
      return;
    }

    var serialized = _cast_utils2.default.serialize(message);
    if (opt_senderId) {
      bus.getCastChannel(opt_senderId).send(serialized);
    } else {
      bus.broadcast(serialized);
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////
  //
  function onLoad_(event) {
    printLog('onLoad_');

    if (player_) {
      player_.unload();
      player_ = null;
    }

    var info = new cast.receiver.MediaManager.LoadInfo(event.data, event.senderId);

    var url = info.message.media.contentId;
    var protocolFunc = getProtocolFunction_(info.message.media);
    var host = new cast.player.api.Host({
      'url': url,
      'mediaElement': mediaElement_
    });
    player_ = new cast.player.api.Player(host);
    player_.load(protocolFunc(host));
  };

  function onGetStatus_(event) {
    printLog('onGetStatus_', event);
  }

  function onMetadataLoaded_(info) {
    var totalTime = mediaElement_.duration;

    printLog('onMetadataLoaded, ' + 'total time: ' + totalTime);
    onMetadataLoadedOrig_(info);
  }

  function onLoadMetadataError_(event) {
    printLog('onLoadMetadataError_');
    onLoadMetadataErrorOrig_(event);
  }

  ////////////////////////////////////////////////////////////////////////////////////////
  // object function
  function getProtocolFunction_(mediaInformation) {
    var url = mediaInformation.contentId;
    var type = mediaInformation.contentType || '';
    var path = getPath_(url) || '';
    if (getExtension_(path) === 'm3u8' || type === 'application/x-mpegurl' || type === 'application/vnd.apple.mpegurl') {
      return cast.player.api.CreateHlsStreamingProtocol;
    } else if (getExtension_(path) === 'mpd' || type === 'application/dash+xml') {
      return cast.player.api.CreateDashStreamingProtocol;
    } else if (path.indexOf('.ism') > -1 || type === 'application/vnd.ms-sstr+xml') {
      return cast.player.api.CreateSmoothStreamingProtocol;
    }
    return null;
  }

  function formatDuration_(dur) {
    dur = Math.floor(dur);

    function digit(n) {
      return ('00' + Math.round(n)).slice(-2);
    }
    var hr = Math.floor(dur / 3600);
    var min = Math.floor(dur / 60) % 60;
    var sec = dur % 60;
    if (!hr) {
      return digit(min) + ':' + digit(sec);
    } else {
      return digit(hr) + ':' + digit(min) + ':' + digit(sec);
    }
  }

  /**
   * Utility function to get the extension of a URL file path.
   *
   * @param {string} url the URL
   * @return {string} the extension or "" if none
   * @private
   */
  function getExtension_(url) {
    var parts = url.split('.');
    // Handle files with no extensions and hidden files with no extension
    if (parts.length === 1 || parts[0] === '' && parts.length === 2) {
      return '';
    }
    return parts.pop().toLowerCase();
  }

  /**
   * Returns the URL path.
   *
   * @param {string} url The URL
   * @return {string} The URL path.
   * @private
   */
  function getPath_(url) {
    var href = document.createElement('a');
    href.href = url;
    return href.pathname || '';
  }

  function start() {
    receiverManager_.start();
  }

  function addEventListener(ev, cb) {
    evHandlers[ev] = cb;
  }

  var instance = {
    start: start,
    addEventListener: addEventListener
  };
  setup();
  return instance;
}

exports.default = CastReceiver;

/***/ }),

/***/ "./src/cast/cast_sender.js":
/*!*********************************!*\
  !*** ./src/cast/cast_sender.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _cast_utils = __webpack_require__(/*! ./cast_utils */ "./src/cast/cast_utils.js");

var _cast_utils2 = _interopRequireDefault(_cast_utils);

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

///////////////////////////////////////////////////////////////////////////////
// RemotePlayerHandler
function RemotePlayerHandler() {
  function init(remotePlayer, remotePlayerController) {
    remotePlayer = remotePlayer;
    remotePlayerController = remotePlayerController;

    remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.IS_MUTED_CHANGED, function () {
      console.log('muted: ' + remotePlayer.isMuted);
    });

    remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.VOLUME_LEVEL_CHANGED, function () {
      var newVolume = remotePlayer.volumeLevel;
      console.log('newVolume is: ' + newVolume);
    });
  }

  function play() {
    if (remotePlayer.isPaused) {
      remotePlayerController.playOrPause();
    }
  }

  function pause() {
    if (!remotePlayer.isPaused) {
      remotePlayerController.playOrPause();
    }
  }

  function setVolume(volume) {
    remotePlayer.volumeLevel = volume;
    remotePlayerController.setVolumeLevel();

    // or
    //session_.setVolume(1.0);
  }

  function getVolume() {
    return remotePlayer.volumeLevel;
  }

  function seek(time) {
    remotePlayer.currentTime = time;
    remotePlayerController.seek();
  }

  function stop() {
    remotePlayerController.stop();
  }

  var instance = {
    init: init,
    play: play,
    pause: pause,
    setVolume: setVolume,
    getVolume: getVolume,
    seek: seek,
    stop: stop
  };
  return instance;
};

////////////////////////////////////////////////////////////////////////////////////
// CastSender
function CastSender(receiverAppId) {
  var context_ = this.context;
  var receiverAppId_ = receiverAppId;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var remotePlayer = null;
  var remotePlayerController = null;
  var castContext_ = null;
  var session_ = null;

  var remotePlayerHandler = new RemotePlayerHandler();

  // 
  var position_ = void 0;
  var duration_ = void 0;
  var paused_ = void 0;
  var muted_ = void 0;
  var volume_ = void 0;

  function setup() {
    console.log('cast, setup');

    var options = {};

    // Set the receiver application ID to your own (created in the
    // Google Cast Developer Console), or optionally
    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID
    options.receiverApplicationId = receiverAppId;

    // Auto join policy can be one of the following three:
    // ORIGIN_SCOPED - Auto connect from same appId and page origin
    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab
    // PAGE_SCOPED - No auto connect
    //options.autoJoinPolicy = chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED;
    castContext_ = cast.framework.CastContext.getInstance();
    castContext_.setOptions(options);

    castContext_.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, function (e) {
      //console.log('cast, cast state: ', e);
    });

    castContext_.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, function (event) {
      console.log('cast, sessionState: ' + event.sessionState);
      switch (event.sessionState) {
        case cast.framework.SessionState.SESSION_STARTED:
        case cast.framework.SessionState.SESSION_RESUMED:
          break;
        case cast.framework.SessionState.SESSION_ENDED:
          //console.log('CastContext: CastSession disconnected');
          // Update locally as necessary
          break;
      }
    });

    remotePlayer = new cast.framework.RemotePlayer();
    remotePlayerController = new cast.framework.RemotePlayerController(remotePlayer);
    remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED, onConnectedChanged);
    remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED, onMediaLoadedChanged);

    //
    remotePlayerHandler.init(remotePlayer, remotePlayerController);
  }

  function onConnectedChanged() {
    console.log('cast, +onConnectedChanged, remotePlayer.isConnected: ' + remotePlayer.isConnected);

    session_ = cast.framework.CastContext.getInstance().getCurrentSession();
    if (session_) {
      // BD
      var castDev = session_.getCastDevice();
      // ED
      session_.addMessageListener(_cast_utils2.default.OLDMTN_MESSAGE_NAMESPACE, onMessageReceived_);
    } else {
      console.log('cast, session_ is null');
    }

    // Notify upper layer
    if (remotePlayer.isConnected) {
      eventBus_.trigger(_events2.default.CAST_CONNECTED);
    } else {
      eventBus_.trigger(_events2.default.CAST_DISCONNECTED);
    }
  }

  function onMediaLoadedChanged() {
    console.log('--onMediaLoadedChanged--');
  }

  function loadMedia_SuccessCb() {
    console.log('--loadMedia_SuccessCb--');
  }

  function loadMedia_ErrorCb() {
    console.log('--loadMedia_ErrorCb--');
  }

  function init(cfg) {
    var msg = {
      cmdType: 'init',
      data: cfg
    };
    sendMessage_(msg);
  }

  function open(message) {
    message.cmdType = 'open';
    sendMessage_(message);
  }

  function add() {
    var msg = {
      'cmdType': 'add'
    };
    sendMessage_(msg);
  }

  function play() {
    var msg = {
      'cmdType': 'play'
    };
    sendMessage_(msg);
  }

  function pause() {
    var msg = {
      'cmdType': 'pause'
    };
    sendMessage_(msg);
  }

  function isPaused() {
    return paused_;
  }

  function setPosition(pos) {
    var msg = {
      cmdType: 'setPosition',
      data: {
        position: pos
      }
    };
    sendMessage_(msg);
  }

  function getPosition() {
    return position_;
  }

  function getDuration() {
    return duration_;
  }

  function setVolume(volume) {
    var msg = {
      cmdType: 'setVolume',
      data: {
        volume: volume
      }
    };
    sendMessage_(msg);

    // old
    //remotePlayerHandler.setVolume(volume);
  }

  function getVolume() {
    return volume_;
  }

  function mute() {
    var msg = {
      cmdType: 'mute'
    };
    sendMessage_(msg);
  }

  function unmute() {
    var msg = {
      cmdType: 'unmute'
    };
    sendMessage_(msg);
  }

  function isMuted() {
    return muted_;
  }

  // Opens the cast selection UI, to allow user to start or stop session.
  function requestSession() {
    if (!castContext_) {
      console.warn('cast, you should call init first.');
      return;
    }

    castContext_.requestSession();
  }

  function endSession() {
    if (!castContext_) {
      return;
    }

    var castSession = castContext_.getCurrentSession();
    // End the session and pass 'true' to indicate
    // that receiver application should be stopped.
    castSession.endSession(true);
  }

  var tmp = 1;

  function test() {
    //console.log('--test--');
    session_.sendMessage(_cast_utils2.default.OLDMTN_MESSAGE_NAMESPACE, tmp.toString(), function () {}, // success callback
    function () {}); // error callback
    tmp++;
    play();
    // let msg = {
    //   'cmdType': 'test'
    // };
    // sendMessage_(msg);
  }

  function loadMedia(url, type) {
    console.log('+loadMedia');

    if (cast && cast.framework && remotePlayer.isConnected) {
      var mediaInfo = new chrome.cast.media.MediaInfo(url, type);

      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
      mediaInfo.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;

      var request = new chrome.cast.media.LoadRequest(mediaInfo);

      // For cast to voReceiver
      //request.customData = { drmInfoList: null };

      session_.loadMedia(request, loadMedia_SuccessCb, loadMedia_ErrorCb);
    } else {
      remotePlayer = null;
      remotePlayerController = null;
    }

    console.log('-loadMedia');
  }

  function onMessageReceived_(namespace, serialized) {
    var message = _cast_utils2.default.deserialize(serialized);
    var e = message.data || {};
    e.from = 'chromecast';

    console.log('receive msg, namespace: ' + namespace + ', serialized: ' + serialized + ', type: ' + message.type);
    switch (message.type) {
      case _events2.default.STATE_CHANGE:
        if (e.newState === 'opened') {
          // do some initialization here
          position_ = e.position;
          duration_ = e.duration;
          muted_ = e.muted;
          volume_ = e.volume;
          paused_ = e.paused;
        }
        //eventBus_.trigger(Events.STATE_CHANGE, e);
        break;
      case _events2.default.MEDIA_TIMEUPDATE:
        position_ = e.position;
        duration_ = e.duration;
        eventBus_.trigger(_events2.default.MEDIA_TIMEUPDATE);
        console.log('timeupdate, ' + message.data.position + '/' + message.data.duration);
        break;
      case _events2.default.MEDIA_PLAYING:
        paused_ = false;
        eventBus_.trigger(_events2.default.MEDIA_PLAYING);
        break;
      case _events2.default.MEDIA_PAUSED:
        paused_ = true;
        eventBus_.trigger(_events2.default.MEDIA_PAUSED);
        break;
      case _events2.default.MEDIA_SEEKING:
        position_ = e.position;
        duration_ = e.duration;
        eventBus_.trigger(_events2.default.MEDIA_SEEKING);
        break;
      case _events2.default.MEDIA_SEEKED:
        position_ = e.position;
        duration_ = e.duration;
        eventBus_.trigger(_events2.default.MEDIA_SEEKED);
        break;
      case _events2.default.MEDIA_VOLUME_CHANGED:
        muted_ = e.muted;
        volume_ = e.volume;
        eventBus_.trigger(_events2.default.MEDIA_VOLUME_CHANGED);
        break;
      default:
        break;
    }
  }

  function old_play() {
    remotePlayerHandler.play();
  }

  function old_pause() {
    remotePlayerHandler.pause();
  }

  function addVolume() {
    var volume = RemotePlayerHandler.getVolume() + 0.1;

    remotePlayerHandler.setVolume(volume);
  }

  function delVolume(volume) {
    var volume = RemotePlayerHandler.getVolume() - 0.1;
    remotePlayerHandler.setVolume(volume);
  }

  function isConnected() {
    return remotePlayer && remotePlayer.isConnected;
  }

  function seek(time) {
    remotePlayerHandler.seek(parseFloat(time));
  }

  function stop() {
    remotePlayerHandler.stop();
  }

  function attribute() {
    console.log('remote player time: ' + remotePlayer.currentTime);
    if (remotePlayer.savedPlayerState) {
      console.log('remotePlayer.savedPlayerState.currentTime: ' + remotePlayer.savedPlayerState.currentTime);
    }
  }

  function remoteCall_(targetName, methodName) {
    var args = Array.prototype.slice.call(arguments, 2);
    sendMessage_({
      'type': 'call',
      'targetName': targetName,
      'methodName': methodName,
      'args': args
    });
  }

  function sendMessage_(message) {
    var serialized = _cast_utils2.default.serialize(message);
    console.log('send msg: ' + serialized);
    // TODO: have never seen this fail.  When would it and how should we react?
    session_.sendMessage(_cast_utils2.default.OLDMTN_MESSAGE_NAMESPACE, serialized, function () {}, // success callback
    function () {}); // error callback
  }

  var instance = {
    // 
    requestSession: requestSession,
    endSession: endSession,
    init: init,
    open: open,
    add: add,
    play: play,
    pause: pause,
    isPaused: isPaused,
    setPosition: setPosition,
    getPosition: getPosition,
    getDuration: getDuration,
    setVolume: setVolume,
    getVolume: getVolume,
    mute: mute,
    unmute: unmute,
    isMuted: isMuted,
    test: test,
    // old left
    loadMedia: loadMedia,
    stop: stop,
    old_play: old_play,
    old_pause: old_pause,
    addVolume: addVolume,
    delVolume: delVolume,
    seek: seek,
    attribute: attribute
  };

  setup();
  return instance;
};

CastSender.__h5player_factory_name = 'CastSender';
exports.default = _FactoryMaker2.default.getSingletonFactory(CastSender);

/***/ }),

/***/ "./src/cast/cast_utils.js":
/*!********************************!*\
  !*** ./src/cast/cast_utils.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var CastUtils = function CastUtils() {};

////////////////////////////////////////////////////////////////////////
// Begin CastUtils
CastUtils.GENERIC_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.cast.media';
CastUtils.OLDMTN_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.oldmtn.cast';

CastUtils.simulateTimeRanges_ = function (obj) {
  return {
    length: obj.length,
    // NOTE: a more complete simulation would throw when |i| was out of range,
    // but for simplicity we will assume a well-behaved application that uses
    // length instead of catch to stop iterating.
    start: function start(i) {
      return obj.start[i];
    },
    end: function end(i) {
      return obj.end[i];
    }
  };
};

CastUtils.serialize = function (thing) {
  return JSON.stringify(thing);
};

CastUtils.deserialize = function (str) {
  return JSON.parse(str, function (key, value) {
    if (value == 'NaN') {
      return NaN;
    } else if (value == '-Infinity') {
      return -Infinity;
    } else if (value == 'Infinity') {
      return Infinity;
    } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value['__type__'] == 'TimeRanges') {
      // TimeRanges objects have been unpacked and sent as plain data.
      // Simulate the original TimeRanges object.
      return CastUtils.simulateTimeRanges_(value);
    }
    return value;
  });
};

// End CastUtils
///////////////////////////////////////////////////////////////////////////////////////////////////

exports.default = CastUtils;

/***/ }),

/***/ "./src/common/common.js":
/*!******************************!*\
  !*** ./src/common/common.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = exports.Fragment = function Fragment() {
  _classCallCheck(this, Fragment);

  this.type = null; // audio/video/pd
  this.url = null; // https://abc.com/1.m4s

  this.byteRangeStart = null;
  this.byteRangeEnd = null;
};

var TrackInfo = exports.TrackInfo = function TrackInfo() {
  _classCallCheck(this, TrackInfo);

  this.type = null; // audio/video/stream(ts)
  this.rep = null; // dash only
};

var PeriodInfo = exports.PeriodInfo = function PeriodInfo() {
  _classCallCheck(this, PeriodInfo);

  this.url = null; // dash/hls/pd ulr
  this.duration = null; // current stream total duration
  this.tracks = []; // an array of TrackInfo
};

/***/ }),

/***/ "./src/controller/ads_controller.js":
/*!******************************************!*\
  !*** ./src/controller/ads_controller.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _common_utils = __webpack_require__(/*! ../utils/common_utils */ "./src/utils/common_utils.js");

var _common_utils2 = _interopRequireDefault(_common_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function formatAdsTimeOffset(offset) {
  var hour = parseInt(offset / 3600);
  var min = parseInt(parseInt(offset % 3600) / 60);
  var sec = parseInt(parseInt(offset % 3600) % 60);

  return hour.toString() + ':' + min.toString() + ':' + sec.toString() + '.000';
}

function getVMAPItem(breakId, offset, tag) {
  var breakType = 'linear,nonlinear';
  var breakId = breakId;
  var timeOffset = formatAdsTimeOffset(offset);
  var url = tag;

  var item = '<vmap:AdBreak breakType="_type_" breakId="_adbreakname_" timeOffset="_offset_"><vmap:AdSource allowMultipleAds="true" followRedirects="true" id="_adbreakname_-ad-1"><vmap:AdTagURI><![CDATA[_url_]]></vmap:AdTagURI></vmap:AdSource></vmap:AdBreak>'.replace(/_type_/g, breakType).replace(/_adbreakname_/g, breakId).replace(/_offset_/g, timeOffset).replace(/_url_/g, url);
  return item;
}

function AdsController(adContainer, media, advertising) {
  var context_ = this.context;

  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();
  var adContainer_ = adContainer;
  var media_ = media;
  var advertising_ = advertising;

  // IMA SDK Needs
  var adDisplayContainer_ = null;
  var adsLoader_ = null;
  var adsManager_ = null;

  //
  var cuePoints_ = null;

  //
  var width_ = void 0;
  var height_ = void 0;

  // flag
  var isPlayingAd_ = false;
  var isLinearAd_ = false;
  var isVpaidAd_ = false;
  var isPaused_ = false;

  var adsLoaded_ = false;
  var contentInitialized_ = false;
  var adWidth_ = 0;
  var adHeight_ = 0;

  var countdownTimer_ = null;
  var duration_ = void 0;
  var position_ = void 0;

  var isMobilePlatform_ = _common_utils2.default.isMobilePlatform();

  function setup() {
    if (advertising_.vpaidmode) {
      var mode = -1;
      if (advertising_.vpaidmode === 'disabled') {
        mode = google.ima.ImaSdkSettings.VpaidMode.DISABLED;
      } else if (advertising_.vpaidmode === 'enabled') {
        mode = google.ima.ImaSdkSettings.VpaidMode.ENABLED;
      } else if (advertising_.vpaidmode === 'insecure') {
        mode = google.ima.ImaSdkSettings.VpaidMode.INSECURE;
      }
      if (mode !== -1) {
        google.ima.settings.setVpaidMode(mode);
      }
    }

    if (advertising_.locale) {
      google.ima.settings.setLocale(advertising_.locale);
    }

    adDisplayContainer_ = new google.ima.AdDisplayContainer(adContainer_, media_, null);
    //advertising_.companions[0] ? advertising_.companions[0].div : null);

    adsLoader_ = new google.ima.AdsLoader(adDisplayContainer_);
    // Mobile Skippable Ads
    // see: https://developers.google.com/interactive-media-ads/docs/sdks/html5/skippable-ads
    adsLoader_.getSettings().setDisableCustomPlaybackForIOS10Plus(true);
    adsLoader_.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, onAdsManagerLoaded, false, this);
    adsLoader_.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, onAdError, false, this);

    //
    adsLoaded_ = false;
    contentInitialized_ = false;
    eventBus_.on(oldmtn.Events.MEDIA_LOADEDMETADATA, onMediaLoadedMetadata, this);
    eventBus_.on(oldmtn.Events.MEDIA_ENDED, onMediaEnded, this);
  }

  function open() {
    initialUserAction();
    requestAds();
  }

  function close() {
    stopAdTimer();
    if (adsManager_) {
      adsManager_.destroy();
      adsManager_ = null;
    }
  }

  function initialUserAction() {
    // On iOS and Android devices, video playback must begin in a user action.
    // AdDisplayContainer provides a initialize() API to be called at appropriate
    // time.
    // see: https://developers.google.com/interactive-media-ads/docs/sdks/html5/mobile_video
    adDisplayContainer_.initialize();
  }

  function requestAds() {
    width_ = adContainer_.parentNode.clientWidth;
    height_ = adContainer_.parentNode.clientHeight;
    debug_.log('width_: ' + width_ + ', height: ' + height_);
    // var item = getVMAPItem('myAds', advertising_.offset, advertising_.tag);
    // var ads = '<vmap:VMAP xmlns:vmap='http://www.iab.net/videosuite/vmap' version='1.0'>' + item + '</vmap:VMAP>'
    // console.log('ads: ' + ads);

    debug_.log('+request ads, advertising_.tag: ' + advertising_.tag);
    var adsRequest = new google.ima.AdsRequest();
    adsRequest.adTagUrl = advertising_.tag;
    // Specify the linear and nonlinear slot sizes. This helps the SDK to
    // select the correct creative if multiple are returned.
    adsRequest.linearAdSlotWidth = width_;
    adsRequest.linearAdSlotHeight = height_;
    adsRequest.nonLinearAdSlotWidth = width_;
    adsRequest.nonLinearAdSlotHeight = height_;

    //adsRequest.setAdWillAutoPlay(autoplayAllowed_);
    //adsRequest.setAdWillPlayMuted(autoplayRequiresMuted_);
    //adsRequest.forceNonLinearFullSlot = advertising_.forceNonLinearFullSlot;

    /*
     * In some circumstances you may want to prevent the SDK from playing ad breaks until you're ready for them.
     * In this scenario, you can disable automatic playback of ad breaks in favor of letting the SDK know when you're ready for an ad break to play.
     * With this configuration, once the SDK has loaded an ad break, it will fire an AD_BREAK_READY event.
     * When your player is ready for the ad break to start, you can call adsManager.start():
     */
    //adsLoader_.getSettings().setAutoPlayAdBreaks(false);

    adsLoader_.requestAds(adsRequest);
  }

  // AdsController public functions
  function playAd() {
    // sometimes, requestAds may be caught an error, so we return here directly.
    if (!adsManager_) {
      return;
    }

    if (contentInitialized_ && adsLoaded_) {
      try {
        initialUserAction();
        adsManager_.init(width_, height_, google.ima.ViewMode.NORMAL);
        adsManager_.start();
      } catch (adError) {
        // An error may be thrown if there was a problem with the VAST response.
      }
    }
  }

  function isPaused() {
    return isPaused_;
  }

  function isPlayingAd() {
    return isPlayingAd_;
  }

  function isLinearAd() {
    return isLinearAd_;
  }

  function isMuted() {
    if (adsManager_.getVolume() === 0) {
      return true;
    } else {
      return false;
    }
  }

  function mute() {
    adsManager_.setVolume(0);
  }

  function unmute() {
    adsManager_.setVolume(1);
  }

  function getVolume() {
    return adsManager_.getVolume();
  }

  function setVolume(volume) {
    adsManager_.setVolume(volume);
  }

  function getPosition() {
    return position_;
  }

  function getDuration() {
    return duration_;
  }

  function play() {
    if (adsManager_) {
      adsManager_.resume();
    }
  }

  function pause() {
    if (adsManager_) {
      adsManager_.pause();
    }
  }

  function resize(width, height, fullscreen) {
    if (adsManager_) {
      width_ = width;
      height_ = height;
      adsManager_.resize(width_, height_, google.ima.ViewMode.FULLSCREEN);
    }
  }

  ////////////////////////////////////////////////////////////////////////
  function onAdsManagerLoaded(adsManagerLoadedEvent) {
    debug_.log('+onAdsManagerLoaded');

    var adsRenderingSettings = new google.ima.AdsRenderingSettings();
    adsRenderingSettings.autoAlign = true;
    if (advertising_.enablePreloading) {
      adsRenderingSettings.enablePreloading = advertising_.enablePreloading;
    }
    adsRenderingSettings.restoreCustomPlaybackStateOnAdBreakComplete = true;
    //adsRenderingSettings.useStyledLinearAds = true;
    adsRenderingSettings.useStyledNonLinearAds = true;

    adsManager_ = adsManagerLoadedEvent.getAdsManager(media_, adsRenderingSettings);

    // Attach the pause/resume events.
    // Handle errors.
    adsManager_.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, onAdError, false, this);
    var events = [
    // For non-auto ad breaks, listen for ad break ready
    google.ima.AdEvent.Type.AD_BREAK_READY, google.ima.AdEvent.Type.AD_METADATA, google.ima.AdEvent.Type.ALL_ADS_COMPLETED, google.ima.AdEvent.Type.CLICK, google.ima.AdEvent.Type.COMPLETE, google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, google.ima.AdEvent.Type.DURATION_CHANGE, google.ima.AdEvent.Type.FIRST_QUARTILE, google.ima.AdEvent.Type.IMPRESSION, google.ima.AdEvent.Type.INTERACTION, google.ima.AdEvent.Type.LINEAR_CHANGED, google.ima.AdEvent.Type.LOADED, google.ima.AdEvent.Type.LOG, google.ima.AdEvent.Type.MIDPOINT, google.ima.AdEvent.Type.PAUSED, google.ima.AdEvent.Type.RESUMED, google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, google.ima.AdEvent.Type.SKIPPED, google.ima.AdEvent.Type.STARTED, google.ima.AdEvent.Type.THIRD_QUARTILE, google.ima.AdEvent.Type.USER_CLOSE, google.ima.AdEvent.Type.VOLUME_CHANGED, google.ima.AdEvent.Type.VOLUME_MUTED];
    for (var index in events) {
      adsManager_.addEventListener(events[index], onAdEvent, false, this);
    }

    adsLoaded_ = true;
    if (contentInitialized_) {
      debug_.log('playAd when contentInitialized_');
      eventBus_.trigger(_events2.default.AD_LOADING_COMPLETE);
    }

    debug_.log('-onAdsManagerLoaded');
  }

  function onAdError(adErrorEvent) {
    debug_.log('--onAdEvent--: ' + adErrorEvent.getError().toString());
    var err = adErrorEvent.getError();
    // deserialize, getErrorCode, getInnerError, getMessage, getType, getVastErrorCode, serialize, toString
    debug_.log('ad err: ', err);

    var errCode = err.getErrorCode();
    var errMsg = err.getMessage();

    if (adsManager_) {
      adsManager_.destroy();
    }
    //application_.resumeAfterAd();
  }

  function onAdEvent(adEvent) {
    debug_.log('+onAdEvent: ' + adEvent.type);
    var ad = adEvent.getAd();

    switch (adEvent.type) {
      case google.ima.AdEvent.Type.AD_BREAK_READY:
        {
          debug_.log('adEvent.o.adBreakTime: ' + adEvent.o.adBreakTime);
        }
        break;
      case google.ima.AdEvent.Type.AD_METADATA:
        {
          // for (let i in adEvent) {
          //     console.log('AD_METADATA: ' + i);
          // }
          cuePoints_ = adEvent.getAdCuePoints();
          debug_.log('cue points: ' + cuePoints_.h.join(','));
        }
        break;
      case google.ima.AdEvent.Type.CLICK:
        {
          //application_.adClicked();
        }
        break;
      case google.ima.AdEvent.Type.COMPLETE:
        {
          // This event indicates the ad has finished - the video player
          // can perform appropriate UI actions, such as removing the timer for
          // remaining time detection.
          processWhenAdComplete();
        }
        break;
      case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
        {
          eventBus_.trigger(_events2.default.AD_CONTENT_PAUSE_REQUESTED);
        }
        break;
      case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
        {
          eventBus_.trigger(_events2.default.AD_CONTENT_RESUME_REQUESTED);
        }
        break;
      case google.ima.AdEvent.Type.DURATION_CHANGE:
        {}
        break;
      case google.ima.AdEvent.Type.IMPRESSION:
        {}
        break;
      case google.ima.AdEvent.Type.LINEAR_CHANGED:
        {}
        break;
      case google.ima.AdEvent.Type.LOADED:
        {
          // This is the first event sent for an ad - it is possible to
          // determine whether the ad is a video ad or an overlay.
          if (!ad.isLinear()) {
            // Position AdDisplayContainer correctly for overlay.
            // Use ad.width and ad.height.
          }
        }
        break;
      case google.ima.AdEvent.Type.PAUSED:
        {
          isPaused_ = true;
          eventBus_.trigger(_events2.default.AD_PAUSED);
        }
        break;
      case google.ima.AdEvent.Type.RESUMED:
        {
          isPaused_ = false;
          eventBus_.trigger(_events2.default.AD_RESUMED);
        }
        break;
      case google.ima.AdEvent.Type.SKIPPED:
        {
          // for 'skippable ads', if we skip it, we won't receive COMPLETED event, but only receive SKIPPED event.
          processWhenAdComplete();
        }
        break;
      case google.ima.AdEvent.Type.STARTED:
        {
          // This event indicates the ad has started - the video player
          // can adjust the UI, for example display a pause button and
          // remaining time.
          processWhenAdStart(ad);
        }
        break;
      case google.ima.AdEvent.Type.THIRD_QUARTILE:
        {}
        break;
      case google.ima.AdEvent.Type.USER_CLOSE:
        {
          if (isVpaidAd_ || isLinearAd_) {
            processWhenAdComplete();
          }
        }
        break;
      case google.ima.AdEvent.Type.VOLUME_CHANGED:
        {
          debug_.log('ad VOLUME_CHANGED: ' + adsManager_.getVolume());
          eventBus_.trigger(_events2.default.AD_VOLUME_CHANGED);
        }
        break;
      case google.ima.AdEvent.Type.VOLUME_MUTED:
        {
          debug_.log('ad VOLUME_MUTED: ' + adsManager_.getVolume());
          eventBus_.trigger(_events2.default.AD_VOLUME_CHANGED);
        }
        break;
      default:
        break;
    }
  }

  function onMediaLoadedMetadata() {
    // In some platform, content player & ad player could use a single video tag,
    // and we just process content player 'metadata' event only, so cancel the listener.
    eventBus_.off(oldmtn.Events.MEDIA_LOADEDMETADATA, onMediaLoadedMetadata, this);
    debug_.log('+onMediaLoadedMetadata' + ', ' + 'contentInitialized_: ' + contentInitialized_ + ', ' + 'adsLoaded_: ' + adsLoaded_);
    contentInitialized_ = true;
    if (adsLoaded_) {
      debug_.log('playAd when adsLoaded_');
      eventBus_.trigger(_events2.default.AD_LOADING_COMPLETE);
      //playAd();
    }
    debug_.log('-onMediaLoadedMetadata');
  }

  function onMediaEnded() {
    adsLoader_.contentComplete();
  }

  //
  function startAdTimer() {
    countdownTimer_ = setInterval(function () {
      var timeRemaining = adsManager_.getRemainingTime();
      // If the ad is not loaded yet or has finished playing, getRemainingTime would return -1.
      if (timeRemaining === -1) {
        return;
      }

      position_ = duration_ - timeRemaining;
      // Update UI with timeRemaining
      if (isPlayingAd_ && !isPaused_) {
        //debug_.log('test, timeRemaining: ' + timeRemaining + ', position: ' + position_ + ', duration: ' + duration_);
        eventBus_.trigger(_events2.default.AD_TIMEUPDATE);
      }
    }, 300);
  }

  function stopAdTimer() {
    if (countdownTimer_) {
      clearInterval(countdownTimer_);
      countdownTimer_ = null;
    }
  }

  function processWhenAdStart(ad) {
    //
    isPlayingAd_ = true;
    isLinearAd_ = ad.isLinear();

    // How to know the ad is VPAID or not?
    // Method1
    // isVpaidAd_ = ad.g.vpaid;
    // Method2
    var apiFw = ad.getApiFramework();
    isVpaidAd_ = apiFw === 'VPAID' ? true : false;
    position_ = 0;
    duration_ = ad.getDuration();
    adWidth_ = ad.getWidth();
    adHeight_ = ad.getHeight();

    eventBus_.trigger(_events2.default.AD_STARTED, {
      linear: isLinearAd_,
      vpaid: isVpaidAd_,
      width: adWidth_,
      height: adHeight_
    });
    if (isLinearAd_) {
      startAdTimer();
      eventBus_.trigger(_events2.default.AD_TIMEUPDATE);
    } else {
      eventBus_.trigger(_events2.default.AD_CONTENT_RESUME_REQUESTED);
    }

    // report companion
    var selectionCriteria = new google.ima.CompanionAdSelectionSettings();
    selectionCriteria.resourceType = google.ima.CompanionAdSelectionSettings.ResourceType.STATIC;
    selectionCriteria.creativeType = google.ima.CompanionAdSelectionSettings.CreativeType.IMAGE;
    selectionCriteria.sizeCriteria = google.ima.CompanionAdSelectionSettings.SizeCriteria.IGNORE;

    // Get a list of companion ads for an ad slot size and CompanionAdSelectionSettings
    var companionAds = ad.getCompanionAds(width_, height_, selectionCriteria);
    var companions = [];
    for (var i = 0; i < companionAds.length; i++) {
      var companionAd = companionAds[i];

      var width = companionAd.getWidth();
      var height = companionAd.getHeight();
      var content = companionAd.getContent();
      companions.push({
        width: width,
        height: height,
        content: content
      });

      debug_.log('companion[' + i + '], type:' + companionAd.getContentType() + ' width:' + companionAd.getWidth() + ', height:' + companionAd.getHeight());
    }
    if (companions.length > 0) {
      eventBus_.trigger(_events2.default.AD_COMPANIONS, {
        companions: companions
      });
    }
  }

  function processWhenAdComplete() {
    //
    isPlayingAd_ = false;
    stopAdTimer();
    position_ = duration_;
    eventBus_.trigger(_events2.default.AD_TIMEUPDATE);
    eventBus_.trigger(_events2.default.AD_COMPLETE);
  }

  //
  function test() {
    // playAd();

    if (contentInitialized_ && adsLoaded_) {
      try {
        initialUserAction();
        adsManager_.init(width_, height_, google.ima.ViewMode.NORMAL);
        adsManager_.start();
      } catch (adError) {
        // An error may be thrown if there was a problem with the VAST response.
      }
    }
  }

  var instance = {
    open: open,
    close: close,
    isPlayingAd: isPlayingAd,
    isLinearAd: isLinearAd,
    play: play,
    pause: pause,
    isPaused: isPaused,
    mute: mute,
    unmute: unmute,
    isMuted: isMuted,
    getVolume: getVolume,
    setVolume: setVolume,
    getPosition: getPosition,
    getDuration: getDuration,
    resize: resize,
    requestAds: requestAds,
    playAd: playAd,

    //
    test: test
  };

  setup();
  return instance;
}

AdsController.__h5player_factory_name = 'AdsController';
exports.default = _FactoryMaker2.default.getSingletonFactory(AdsController);

/***/ }),

/***/ "./src/controller/buffer_controller.js":
/*!*********************************************!*\
  !*** ./src/controller/buffer_controller.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _timeRanges = __webpack_require__(/*! ../utils/timeRanges */ "./src/utils/timeRanges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BufferController() {
  var context_ = this.context;

  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var mediaSource_ = null;
  var media_ = void 0;
  var sourceBuffer_ = {};

  var streamInfo_ = void 0;

  var segments_ = null;
  // flag
  var appending_ = false;

  function setup() {
    eventBus_.on(_events2.default.MEDIA_ATTACHING, onMediaAttaching);

    eventBus_.on(_events2.default.STREAM_UPDATED, onStreamUpdated);

    eventBus_.on(_events2.default.BUFFER_CODEC, onBufferCodec);
    eventBus_.on(_events2.default.BUFFER_APPENDING, onBufferAppending);
    eventBus_.on(_events2.default.BUFFER_EOS, onBufferEOS);

    //
    eventBus_.on(_events2.default.TEST_MSG, onTestMsg);
  }

  function createMediaSource() {
    debug_.log('BufferController, +createMediaSource');
    //
    var hasWebKit = 'WebKitMediaSource' in window;
    var hasMediaSource = 'MediaSource' in window;

    if (hasMediaSource) {
      mediaSource_ = new MediaSource();
      mediaSource_.addEventListener('sourceopen', onMediaSourceOpen, false);
      mediaSource_.addEventListener('sourceended', onMediaSourceEnded, false);
      mediaSource_.addEventListener('sourceclose', onMediaSourceClose, false);
    } else if (hasWebKit) {
      mediaSource_ = new WebKitMediaSource();
      mediaSource_.addEventListener('webkitsourceopen', onMediaSourceOpen, false);
    }

    debug_.log('BufferController, -createMediaSource');

    return mediaSource_;
  }

  function close() {
    debug_.log('BufferController, +close');
    if (sourceBuffer_.audio) {
      mediaSource_.removeSourceBuffer(sourceBuffer_.audio);
    }
    if (sourceBuffer_.video) {
      mediaSource_.removeSourceBuffer(sourceBuffer_.video);
    }
  }

  function setDuration(value) {
    if (mediaSource_.duration != value) {
      mediaSource_.duration = value;
    }

    return mediaSource_.duration;
  }

  function signalEndOfStream() {
    debug_.log('+signalEndOfStream');
    mediaSource_.endOfStream();
  }

  function test() {}

  function onMediaSourceOpen() {
    debug_.log('+onMediaSourceOpen');

    // once received, don't listen anymore to sourceopen event
    mediaSource_.removeEventListener('sourceopen', onMediaSourceOpen);
    mediaSource_.removeEventListener('webkitsourceopen', onMediaSourceOpen);

    URL.revokeObjectURL(media_.src);
    eventBus_.trigger(_events2.default.MEDIA_ATTACHED, {});
  }

  function onMediaSourceEnded() {
    debug_.log('+onMediaSourceEnded');
  }

  function onMediaSourceClose() {
    debug_.log('+onMediaSourceClose');
  }

  function onStreamUpdated(e) {
    streamInfo_ = e.streamInfo;
  }

  function onMediaAttaching(data) {
    media_ = data.media;

    var mediaSrc = createMediaSource();
    var objURL = window.URL.createObjectURL(mediaSrc);
    media_.src = objURL;
  }

  function onBufferCodec(data) {
    var tracks = data;

    if (tracks.audio) {
      var mimeType = tracks.audio.container + ';codecs=' + tracks.audio.codec;
      var buffer = mediaSource_.addSourceBuffer(mimeType);
      sourceBuffer_.audio = buffer;

      buffer.addEventListener('updatestart', sourceBuffer_updatestart);
      buffer.addEventListener('update', sourceBuffer_update);
      buffer.addEventListener('updateend', sourceBuffer_updateend);
      buffer.addEventListener('error', sourceBuffer_error);
      buffer.addEventListener('abort', sourceBuffer_abort);
    }
    if (tracks.video) {
      var _mimeType = tracks.video.container + ';codecs=' + tracks.video.codec;
      var _buffer = mediaSource_.addSourceBuffer(_mimeType);
      sourceBuffer_.video = _buffer;

      _buffer.addEventListener('updatestart', sourceBuffer_updatestart);
      _buffer.addEventListener('update', sourceBuffer_update);
      _buffer.addEventListener('updateend', sourceBuffer_updateend);
      _buffer.addEventListener('error', sourceBuffer_error);
      _buffer.addEventListener('abort', sourceBuffer_abort);
    }
  }

  function doAppending() {
    if (appending_) {
      // logger.log(`sb appending in progress`);
      return;
    }

    if (segments_ && segments_.length) {
      var segment = segments_.shift();
      try {
        var type = segment.type,
            sb = sourceBuffer_[type];
        if (sb) {
          if (!sb.updating) {
            appending_ = true;

            // reset sourceBuffer ended flag before appending segment
            sb.ended = false;
            sb.appendBuffer(segment.data);
          }
        }
      } catch (err) {
        // in case any error occured while appending, put back segment in segments table
        debug_.log('error while trying to append buffer:' + err.message);
      }
    }
  }

  function onBufferAppending(data) {
    if (!segments_) {
      segments_ = [data];
    } else {
      segments_.push(data);
    }

    doAppending();
  }

  function onBufferEOS() {
    signalEndOfStream();
  }

  function onTestMsg() {
    var media = context_.media;
    // BD
    // var a = sourceBuffer_.audio;
    // var v = sourceBuffer_.video;
    // if (a) {
    //   debug_.log(`audio buffered: ${TimeRanges.toString(a.buffered)}`);
    // }
    // if (v) {
    //   debug_.log(`video buffered: ${TimeRanges.toString(v.buffered)}`);
    // }
    // debug_.log(`media buffered: ${TimeRanges.toString(media.buffered)}`);
    // ED
  }

  // Begin source buffer event
  function sourceBuffer_updatestart() {
    debug_.log('--sourceBuffer_updatestart--');
  }

  function sourceBuffer_update() {
    debug_.log('--sourceBuffer_update--');
  }

  function sourceBuffer_updateend() {
    debug_.log('+sourceBuffer_updateend');
    appending_ = false;

    var pending = segments_.length;
    if (pending === 0) {
      eventBus_.trigger(_events2.default.BUFFER_APPENDED, { pending: pending });
    } else {
      doAppending();
    }

    updateMediaElementDuration();
  }

  function sourceBuffer_error(e) {
    debug_.log('+sourceBuffer_error', e);
  }

  function sourceBuffer_abort() {
    debug_.log('+sourceBuffer_abort');
  }
  // End source buffer event

  function updateMediaElementDuration() {
    // can't set duration while a buffer is updating
    for (var type in sourceBuffer_) {
      if (sourceBuffer_[type].updating === true) {
        return;
      }
    }

    if (mediaSource_ && mediaSource_.duration !== streamInfo_.duration) {
      //mediaSource_.duration = streamInfo_.duration;
    }
  }

  var instance = {
    createMediaSource: createMediaSource,
    close: close,
    setDuration: setDuration,
    signalEndOfStream: signalEndOfStream,
    test: test
  };
  setup();
  return instance;
};

BufferController.__h5player_factory_name = 'BufferController';
exports.default = _FactoryMaker2.default.getSingletonFactory(BufferController);

/***/ }),

/***/ "./src/controller/eme_controller.js":
/*!******************************************!*\
  !*** ./src/controller/eme_controller.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _ProtectionKeyController = __webpack_require__(/*! ../protection/controller/ProtectionKeyController */ "./src/protection/controller/ProtectionKeyController.js");

var _ProtectionKeyController2 = _interopRequireDefault(_ProtectionKeyController);

var _ProtectionModel_21Jan = __webpack_require__(/*! ../protection/models/ProtectionModel_21Jan2015 */ "./src/protection/models/ProtectionModel_21Jan2015.js");

var _ProtectionModel_21Jan2 = _interopRequireDefault(_ProtectionModel_21Jan);

var _ProtectionModel_3Feb = __webpack_require__(/*! ../protection/models/ProtectionModel_3Feb2014 */ "./src/protection/models/ProtectionModel_3Feb2014.js");

var _ProtectionModel_3Feb2 = _interopRequireDefault(_ProtectionModel_3Feb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EMEController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var streamInfo_ = void 0;
  var protectionModel_ = null;
  var protectionKeyController_ = (0, _ProtectionKeyController2.default)(context_).getInstance();

  function setup() {
    protectionModel_ = getProtectionModel();
    protectionModel_.attachMedia(context_.media);

    eventBus_.on(_events2.default.BUFFER_CODEC, onBufferCodec);
  }

  function onBufferCodec(data) {
    var tracks = data;
    if (tracks.audio) {
      streamInfo_.drm.audioCodec = tracks.audio.container + ';codecs=' + tracks.audio.codec;
    }
    if (tracks.video) {
      streamInfo_.drm.videoCodec = tracks.video.container + ';codecs=' + tracks.video.codec;
    }
  }

  function getProtectionModel() {
    var media = context_.media;
    if (media.onencrypted !== undefined && media.mediaKeys !== undefined && navigator.requestMediaKeySystemAccess !== undefined && typeof navigator.requestMediaKeySystemAccess === 'function') {
      debug_.log('User Agent support ProtectionModel_21Jan2015');
      return new _ProtectionModel_21Jan2.default();
    } else {
      debug_.log('User Agent support ProtectionModel_3Feb2014');
      return new _ProtectionModel_3Feb2.default();
    }
  }

  function setDrmInfo(info) {
    streamInfo_ = info;

    if (!info.drm || !info.drm.type) {
      return;
    }

    var keySystem = protectionKeyController_.getKeySystemBySystemString(info.drm.type);
    debug_.log('H5Player, request system tring: ' + keySystem.systemString);
    protectionModel_.setKeySystem(keySystem);
    protectionModel_.setDrmInfo(info);
  }

  var instance_ = {
    setDrmInfo: setDrmInfo
  };
  setup();
  return instance_;
};

EMEController.__h5player_factory_name = 'EMEController';
exports.default = _FactoryMaker2.default.getSingletonFactory(EMEController);

/***/ }),

/***/ "./src/controller/level_controller.js":
/*!********************************************!*\
  !*** ./src/controller/level_controller.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LevelController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var streamInfo_ = void 0;

  function setup() {
    eventBus_.on(_events2.default.MANIFEST_PARSED, onManifestParsed);
  }

  function onManifestParsed(streamInfo) {
    streamInfo_ = streamInfo;

    eventBus_.trigger(_events2.default.STREAM_UPDATED, { streamInfo: streamInfo_ });
  }

  var instance_ = {};
  setup();
  return instance_;
}

LevelController.__h5player_factory_name = 'LevelController';
exports.default = _FactoryMaker2.default.getSingletonFactory(LevelController);

/***/ }),

/***/ "./src/controller/license_controller.js":
/*!**********************************************!*\
  !*** ./src/controller/license_controller.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// From: https://stackoverflow.com/questions/21173734/extracting-top-level-and-second-level-domain-from-a-url-using-regex/21174423#21174423
var DOMAIN_REGEX = /[^.]*\.[^.]{2,3}(?:\.[^.]{2,3})?$/;
// From: https://www.regular-expressions.info/ip.html
var IPADDRESS_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

var LicenseController = function () {
  function LicenseController(props) {
    _classCallCheck(this, LicenseController);

    this.whitelist = [];
  }

  LicenseController.prototype.setWhitelist = function setWhitelist(whitelist) {
    this.whitelist = whitelist;

    // BD
    // this.whitelist.forEach(function(value, index) {
    //   console.log(`whitelist, index[${index}] = ${value}`);
    // });
    // ED
  };

  LicenseController.prototype.checkUrl = function checkUrl(domain) {
    var ret = false;
    if (domain.toLowerCase() === 'localhost') {
      ret = true;
    } else if (this.whitelist.length > 0) {
      // check ip address
      var arrRegex = domain.match(IPADDRESS_REGEX);
      //console.log(`check ip: ${domain} ==> ip: ${arrRegex}`);
      if (arrRegex) {
        for (var i = 0; i < this.whitelist.length; i++) {
          if (arrRegex[0] === this.whitelist[i]) {
            ret = true;
            break;
          }
        }
      } else {
        // check domain
        var _arrRegex = domain.match(DOMAIN_REGEX);
        //console.log(`check domain: ${domain} ==> domain: ${arrRegex}`);
        if (_arrRegex) {
          for (var _i = 0; _i < this.whitelist.length; _i++) {
            if (_arrRegex[0] === this.whitelist[_i]) {
              ret = true;
              break;
            }
          }
        }
      }
    }

    return ret;
  };

  return LicenseController;
}();

exports.default = LicenseController;

/***/ }),

/***/ "./src/controller/parser_controller.js":
/*!*********************************************!*\
  !*** ./src/controller/parser_controller.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _dash_parser = __webpack_require__(/*! ../dash/dash_parser */ "./src/dash/dash_parser.js");

var _dash_parser2 = _interopRequireDefault(_dash_parser);

var _hls_parser = __webpack_require__(/*! ../hls/hls_parser */ "./src/hls/hls_parser.js");

var _hls_parser2 = _interopRequireDefault(_hls_parser);

var _pd_parser = __webpack_require__(/*! ../pd/pd_parser */ "./src/pd/pd_parser.js");

var _pd_parser2 = _interopRequireDefault(_pd_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ParserController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  function setup() {
    eventBus_.on(_events2.default.FINDING_PARSER, onFindingParser);
  }

  function onFindingParser(data) {
    var url = data.url;

    var parser = getParser(url);
    eventBus_.trigger(_events2.default.FOUND_PARSER, { parser: parser });
  }

  function getParser(url) {
    var parser = null;
    var extension = url.split('.').pop();
    if (extension === 'mpd') {
      parser = (0, _dash_parser2.default)(context_).getInstance();
      parser.type = 'dash';
    } else if (extension === 'm3u8') {
      parser = (0, _hls_parser2.default)(context_).getInstance();
      parser.type = 'hls';
    } else if (extension === 'mp4') {
      parser = (0, _pd_parser2.default)(context_).getInstance();
      parser.type = 'pd';
    }

    return parser;
  }

  var instance_ = {};
  setup();
  return instance_;
}

ParserController.__h5player_factory_name = 'ParserController';
exports.default = _FactoryMaker2.default.getSingletonFactory(ParserController);

/***/ }),

/***/ "./src/controller/playback_controller.js":
/*!***********************************************!*\
  !*** ./src/controller/playback_controller.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _timeRanges = __webpack_require__(/*! ../utils/timeRanges */ "./src/utils/timeRanges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _common_utils = __webpack_require__(/*! ../utils/common_utils */ "./src/utils/common_utils.js");

var _common_utils2 = _interopRequireDefault(_common_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* During the loading process of an audio/video, the following events occur, in this order:
loadstart
durationchange
loadedmetadata
loadeddata
progress
canplay
canplaythrough
*/

function PlaybackController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var media_ = context_.media;
  var cfg_ = context_.cfg;

  // flag
  var autoplayAllowed_ = void 0;
  var autoplayRequiresMuted_ = void 0;

  function setup() {
    addEventListeners();
  }

  // Begin -- public functions
  function detectAutoplay() {
    debug_.log('+detectAutoplay: ' + cfg_.autoplay);
    if (cfg_.autoplay) {
      //media_.autoplay = true;
      var playPromise = play(); // This is asynchronous!
      if (playPromise !== undefined) {
        // console.log('webkitAudioDecodedByteCount: ' + media_.webkitAudioDecodedByteCount);
        // console.log('webkitVideoDecodedByteCount: ' + media_.webkitVideoDecodedByteCount);
        // if (CommonUtils.isSafari()) {
        //     console.log('audioTracks length: ' + media_.audioTracks.length);
        // }

        playPromise.then(onAutoplayWithSoundSuccess).catch(onAutoplayWithSoundFail);
      }
    }
  }

  function play() {
    debug_.log('+Native video element request: play');
    return media_.play();
  }

  function pause() {
    debug_.log('+Native video element request: pause');
    media_.pause();
  }

  function isPaused() {
    return media_.paused;
  }

  function getPosition() {
    return media_.currentTime;
  }

  function getDuration() {
    return media_.duration;
  }

  function getSeekableRange() {
    return media_.seekable;
  }

  function getBufferedRanges() {
    return media_.buffered;
  }

  function setPosition(time) {
    media_.currentTime = time;
  }

  function isSeeking() {
    return media_.seeking;
  }

  function isEnded() {
    return media_.ended;
  }

  function mute() {
    media_.muted = true;
  }

  function unmute() {
    media_.muted = false;
  }

  function isMuted() {
    return media_.muted;
  }

  function setVolume(volume) {
    media_.volume = volume;
  }

  function getVolume() {
    return media_.volume;
  }

  function setAudioPlaybackSpeed(speed) {
    media_.playbackRate = speed;
  }

  function videoWidth() {
    return media_.videoWidth;
  }

  function videoHeight() {
    return media_.videoHeight;
  }
  // End -- public functions

  ///////////////////////////////////////////////////////////////////////////
  // Begin autoplay policy
  // see https://developers.google.com/interactive-media-ads/docs/sdks/html5/desktop-autoplay
  function onMutedAutoplaySuccess() {
    debug_.log('+onMutedAutoplaySuccess');
    autoplayAllowed_ = true;
    autoplayRequiresMuted_ = true;
  }

  function onMutedAutoplayFail() {
    debug_.log('+onMutedAutoplayFail');
    // Both muted and unmuted autoplay failed. Fall back to click to play.
    autoplayAllowed_ = false;
    autoplayRequiresMuted_ = false;

    setVolume(1);
    unmute();
  }

  function checkMutedAutoplaySupport() {
    debug_.log('+checkMutedAutoplaySupport');
    setVolume(0);
    mute();
    var playPromise = play();
    if (playPromise !== undefined) {
      playPromise.then(onMutedAutoplaySuccess).catch(onMutedAutoplayFail);
    }
  }

  function onAutoplayWithSoundSuccess(info) {
    // If we make it here, unmuted autoplay works.
    debug_.log('+onAutoplayWithSoundSuccess');
    autoplayAllowed_ = true;
    autoplayRequiresMuted_ = false;
  }

  function onAutoplayWithSoundFail(err) {
    // Unmuted autoplay failed. Now try muted autoplay.
    debug_.log('+onAutoplayWithSoundFail, err: ', err);
    autoplayAllowed_ = false;
    if (cfg_.mutedAutoplay) {
      checkMutedAutoplaySupport();
    }
  }
  // End autoplay policy

  // Begin - private function
  function onMediaAudioAvailable() {
    debug_.log('+Native video element event: audioavailable');
  }

  function onMediaAbort(e) {
    debug_.log('+Native video element event: abort');
  }

  function onMediaCanplay() {
    //The canplay event occurs when the browser can start playing the specified audio/video (when it has buffered enough to begin).
    debug_.log('+Native video element event: canplay');
    eventBus_.trigger(_events2.default.MEDIA_CANPLAY);
  }

  function onMediaCanplayThrough() {
    debug_.log('+Native video element event: canplaythrough');
    var a = media_;
    eventBus_.trigger(_events2.default.MEDIA_CANPLAY_THROUGH);
  }

  function onMediaEncrypted() {
    debug_.log('+Native video element event: encrypted');
  }

  function onMediaDurationChanged() {
    // debug_.log('+Native video element event: durationchange' +
    //     ', getPosition: ' + media_.getPosition +
    //     ', duration: ' + media_.duration);
    eventBus_.trigger(_events2.default.MEDIA_DURATION_CHANGED);
  }

  function onMediaEnded() {
    debug_.log('+Native video element event: ended');
    eventBus_.trigger(_events2.default.MEDIA_ENDED);
  }

  function onMediaError(e) {
    var error = void 0;
    if (e.target && e.target.error) {
      error = e.target.error;
    }
    debug_.log('+Native video element event: error, code:' + error.code + ', msg:' + error.message);
  }

  function onMediaInterruptBegin() {
    debug_.log('+Native video element event: interruptbegin');
  }

  function onMediaInterruptEnd() {
    debug_.log('+Native video element event: interruptend');
  }

  function onMediaLoadedData() {
    debug_.log('+Native video element event: loadeddata');

    function hasAudio() {
      if (typeof media_.webkitAudioDecodedByteCount !== 'undefined') {
        // non-zero if video has audio track
        if (media_.webkitAudioDecodedByteCount > 0) {
          console.log('video has audio');
        } else {
          console.log('video doesn\'t have audio');
        }
      } else if (typeof media_.mozHasAudio !== 'undefined') {
        // true if video has audio track
        if (media_.mozHasAudio) {
          console.log('video has audio');
        } else {
          console.log('video doesn\'t have audio');
        }
      } else {
        console.log('can\'t tell if video has audio');
      }
    }

    //debug_.log('hasAudio: ' + hasAudio());
    eventBus_.trigger(_events2.default.MEDIA_LOADEDDATA);
  }

  function onMediaLoadedMetadata() {
    debug_.log('+Native video element event: metadata' + ', width: ' + media_.videoWidth + ', height: ' + media_.videoHeight + ', duration: ' + media_.duration);
    var width = media_.videoWidth;
    var height = media_.videoHeight;
    eventBus_.trigger(_events2.default.MEDIA_LOADEDMETADATA, {
      width: width,
      height: height
    });
  }

  function onMediaLoadStart() {
    debug_.log('+Native video element event: loadstart');
  }

  function onMediaPaused() {
    debug_.log('+Native video element event: pause');
    eventBus_.trigger(_events2.default.MEDIA_PAUSED);
  }

  function onMediaPlay() {
    debug_.log('+Native video element event: play');
    eventBus_.trigger(_events2.default.MEDIA_PLAY);
  }

  function onMediaPlaying() {
    debug_.log('+Native video element event: playing');
    eventBus_.trigger(_events2.default.MEDIA_PLAYING);
  }

  function onMediaProgress(e) {
    var progress = _timeRanges2.default.toString(media_.buffered);

    //debug_.log('+Native video element event: progress, ' + progress);
  }

  function onMediaReadyState(e) {
    debug_.log('+Native video element event: readyState');
  }

  function onMediaSeeking() {
    eventBus_.trigger(_events2.default.MEDIA_SEEKING);
  }

  function onMediaSeeked() {
    eventBus_.trigger(_events2.default.MEDIA_SEEKED);
  }

  function onMediaSuspend() {
    debug_.log('+Native video element event: suspend');
  }

  function onMediaTimeUpdated(e) {
    eventBus_.trigger(_events2.default.MEDIA_TIMEUPDATE);
  }

  function onMediaVolumeChanged() {
    //debug_.log('+Native video element event: volumechange, muted: ' + media_.muted + ', volume: ' + media_.volume);
    eventBus_.trigger(_events2.default.MEDIA_VOLUME_CHANGED);
  }

  function onMediaWaiting() {
    debug_.log('+Native video element event: waiting');
    eventBus_.trigger(_events2.default.MEDIA_WAITING);
  }
  // End

  // public function
  function addEventListeners() {
    media_.addEventListener('mozaudioavailable', onMediaAudioAvailable);
    media_.addEventListener('abort', onMediaAbort);
    media_.addEventListener('canplay', onMediaCanplay);
    media_.addEventListener('canplaythrough', onMediaCanplayThrough);
    media_.addEventListener('durationchange', onMediaDurationChanged);
    media_.addEventListener('encrypted', onMediaEncrypted);
    media_.addEventListener('ended', onMediaEnded);
    media_.addEventListener('error', onMediaError);
    media_.addEventListener('interruptbegin', onMediaInterruptBegin);
    media_.addEventListener('interruptend', onMediaInterruptEnd);
    media_.addEventListener('loadeddata', onMediaLoadedData);
    media_.addEventListener('loadedmetadata', onMediaLoadedMetadata);
    media_.addEventListener('loadstart', onMediaLoadStart);
    media_.addEventListener('pause', onMediaPaused);
    media_.addEventListener('play', onMediaPlay);
    media_.addEventListener('playing', onMediaPlaying);
    media_.addEventListener('progress', onMediaProgress);
    media_.addEventListener('readyState', onMediaReadyState);
    media_.addEventListener('seeking', onMediaSeeking);
    media_.addEventListener('seeked', onMediaSeeked);
    media_.addEventListener('suspend', onMediaSuspend);
    media_.addEventListener('timeupdate', onMediaTimeUpdated);
    media_.addEventListener('volumechange', onMediaVolumeChanged);
    media_.addEventListener('waiting', onMediaWaiting);
  }

  function removeEventsListeners() {
    media_.removeEventListener('mozaudioavailable', onMediaAudioAvailable);
    media_.removeEventListener('abort', onMediaAbort);
    media_.removeEventListener('canplay', onMediaCanplay);
    media_.removeEventListener('canplaythrough', onMediaCanplayThrough);
    media_.removeEventListener('durationchange', onMediaDurationChanged);
    media_.removeEventListener('encrypted', onMediaEncrypted);
    media_.removeEventListener('ended', onMediaEnded);
    media_.removeEventListener('error', onMediaError);
    media_.removeEventListener('interruptbegin', onMediaInterruptBegin);
    media_.removeEventListener('interruptend', onMediaInterruptEnd);
    media_.removeEventListener('loadeddata', onMediaLoadedData);
    media_.removeEventListener('loadedmetadata', onMediaLoadedMetadata);
    media_.removeEventListener('loadstart', onMediaLoadStart);
    media_.removeEventListener('pause', onMediaPaused);
    media_.removeEventListener('play', onMediaPlay);
    media_.removeEventListener('playing', onMediaPlaying);
    media_.removeEventListener('progress', onMediaProgress);
    media_.removeEventListener('readyState', onMediaReadyState);
    media_.removeEventListener('seeking', onMediaSeeking);
    media_.removeEventListener('seeked', onMediaSeeked);
    media_.removeEventListener('suspend', onMediaSuspend);
    media_.removeEventListener('timeupdate', onMediaTimeUpdated);
    media_.removeEventListener('volumechange', onMediaVolumeChanged);
    media_.removeEventListener('waiting', onMediaWaiting);
  };

  function setSrc(objURL) {
    media_.src = objURL;
  }

  function getSrc() {
    return media_.src;
  }

  function revokeSrc() {
    URL.revokeObjectURL(media_.src);
  }

  function getValidBufferPosition(currentPos) {
    var bufferedEnd = void 0;
    for (var i = 0; i < media_.buffered.length; ++i) {
      var start = media_.buffered.start(i);
      var end = media_.buffered.end(i);

      if (currentPos >= start && currentPos <= end) {
        bufferedEnd = end;
        break;
      }
    }

    return bufferedEnd;
  }

  function close() {
    debug_.log('+PlaybackController.js, close');
    // Detach properly the MediaSource from the HTMLMediaElement as
    // suggested in https://github.com/w3c/media-source/issues/53
    if (media_) {
      media_.removeAttribute('src');
      media_.load();
    }
  }

  var instance = {
    detectAutoplay: detectAutoplay,
    play: play,
    pause: pause,
    isPaused: isPaused,
    getPosition: getPosition,
    setPosition: setPosition,
    getDuration: getDuration,
    getSeekableRange: getSeekableRange,
    getBufferedRanges: getBufferedRanges,
    isSeeking: isSeeking,
    isEnded: isEnded,
    mute: mute,
    unmute: unmute,
    isMuted: isMuted,
    setVolume: setVolume,
    getVolume: getVolume,
    setAudioPlaybackSpeed: setAudioPlaybackSpeed,
    videoWidth: videoWidth,
    videoHeight: videoHeight,

    close: close,
    setSrc: setSrc,
    revokeSrc: revokeSrc,
    getValidBufferPosition: getValidBufferPosition
  };

  setup();
  return instance;
}

PlaybackController.__h5player_factory_name = 'PlaybackController';
exports.default = _FactoryMaker2.default.getSingletonFactory(PlaybackController);

/***/ }),

/***/ "./src/controller/stream_controller.js":
/*!*********************************************!*\
  !*** ./src/controller/stream_controller.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.State = undefined;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _timeRanges = __webpack_require__(/*! ../utils/timeRanges */ "./src/utils/timeRanges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _demuxer = __webpack_require__(/*! ../../third_party/hlsjs/src/demux/demuxer */ "./third_party/hlsjs/src/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _config = __webpack_require__(/*! ../../third_party/hlsjs/src/config */ "./third_party/hlsjs/src/config.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var State = exports.State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

function StreamController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var streamInfo_ = void 0;

  var hls_ = void 0;
  var demuxer_ = void 0;

  // flag
  var startLoaded_ = void 0;
  var manualMode_ = false;
  // state machine
  var state_ = void 0;

  function setup() {
    state_ = State.IDLE;

    hls_ = eventBus_;
    hls_.config = _config.hlsDefaultConfig;
    //hls_.config.enableWorker = true;

    demuxer_ = new _demuxer2.default(hls_, 'main');

    eventBus_.on(_events2.default.MANIFEST_PARSED, onManifestParsed);
    eventBus_.on(_events2.default.STREAM_UPDATED, onStreamUpdated);

    eventBus_.on(_events2.default.FRAG_LOADED, onFragLoaded);

    eventBus_.on(_events2.default.INIT_PTS_FOUND, onInitPtsFound, {});
    eventBus_.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, onFragParsingInitSegment, {});
    eventBus_.on(_events2.default.FRAG_PARSING_DATA, onFragParsingData, {});
    eventBus_.on(_events2.default.FRAG_PARSED, onFragParsed, {});

    eventBus_.on(_events2.default.BUFFER_APPENDED, onBufferAppended);

    //
    eventBus_.on(_events2.default.TEST_MSG, onTestMsg);
  }

  // tool functions
  function getLevelDetails() {
    var details = null;
    for (var i = 0; i < streamInfo_.tracks.length; i++) {
      var trackInfo = streamInfo_.tracks[i];
      if (trackInfo.type === 'stream') {
        details = trackInfo.levelDetails;
        break;
      }
    }

    return details;
  }

  // Begin events functions
  function onManifestParsed() {}

  function onStreamUpdated(e) {
    streamInfo_ = e.streamInfo;
    tick();
  }

  function onTestMsg() {
    tick();
  }

  function onFragLoaded(e) {
    var frag = e.frag;
    var data = frag.data;

    debug_.log('+onFragLoaded, SN:' + frag.sn + ', start:' + frag.start + ', duration:' + frag.duration);
    if (frag.sn === 'initSegment') {
      frag.data = data;
      state_ = State.IDLE;
      tick();
    } else {
      state_ = State.PARSING;

      var details = getLevelDetails();
      var initSegmentData = details.initSegment ? details.initSegment.data : [];
      demuxer_.push(data, initSegmentData, undefined, undefined, frag, streamInfo_.duration, true, undefined);
    }
  }

  function onInitPtsFound(data) {
    var a = 2;
    var b = a;
  }

  function onFragParsingInitSegment(data) {
    eventBus_.trigger(_events2.default.BUFFER_CODEC, data.tracks);

    debug_.log('+onFragParsingInitSegment');
    for (var trackName in data.tracks) {
      var track = data.tracks[trackName];
      var initSegment = track.initSegment;
      if (initSegment) {
        eventBus_.trigger(_events2.default.BUFFER_APPENDING, {
          type: trackName,
          content: 'initSegment',
          data: initSegment
        });
      }
    }
  }

  function onFragParsingData(data) {
    // BD
    var cnt = 0;
    if (data.data1) {
      cnt++;
    }
    if (data.data2) {
      cnt++;
    }
    // ED

    debug_.log('+onFragParsingData, cnt:' + cnt);
    [data.data1, data.data2].forEach(function (buffer, index) {
      if (buffer) {
        debug_.log('push data, index:' + index);
        eventBus_.trigger(_events2.default.BUFFER_APPENDING, {
          type: data.type,
          content: 'data',
          data: buffer
        });
      }
    });
  }

  function onFragParsed(data) {
    debug_.log('+onFragParsed');
    state_ = State.PARSED;
  }

  function onBufferAppended(e) {
    var media = context_.media;
    //debug_.log('main buffered: ' + TimeRanges.toString(media.buffered));
    debug_.log('+onBufferAppended, main buffered: ' + _timeRanges2.default.toString(media.buffered) + ', duration:' + media.duration);
    if (state_ === State.PARSED && e.pending === 0) {
      state_ = State.IDLE;
      //tick();
    }
  }

  // Begin internal functions
  function _checkBuffer() {}

  function _findFragment() {
    var parser = context_.parser;
    var frag = parser.getNextFragment();
    return frag;
  }

  function tick() {
    switch (state_) {
      case State.IDLE:
        {
          var frag = _findFragment();
          if (frag) {
            eventBus_.trigger(_events2.default.FRAG_LOADING, { frag: frag });
            state_ = State.FRAG_LOADING;
          } else {
            eventBus_.trigger(_events2.default.BUFFER_EOS);
          }
        }
        break;
      case State.STOPPED:
        break;
    }

    _checkBuffer();
  }

  function manualSchedule() {
    tick();
  }

  function startLoad() {
    eventBus_.trigger(_events2.default.MANIFEST_LOADING, { url: context_.mediaCfg.url });
  }

  function stopLoad() {
    state_ = State.STOPPED;
  }

  var instance_ = {
    // for debug
    manualSchedule: manualSchedule,
    startLoad: startLoad,
    stopLoad: stopLoad
  };
  setup();
  return instance_;
}

StreamController.__h5player_factory_name = 'StreamController';
exports.default = _FactoryMaker2.default.getSingletonFactory(StreamController);

/***/ }),

/***/ "./src/controller/texttrack_controller.js":
/*!************************************************!*\
  !*** ./src/controller/texttrack_controller.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _common_utils = __webpack_require__(/*! ../utils/common_utils */ "./src/utils/common_utils.js");

var _common_utils2 = _interopRequireDefault(_common_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 20180705
// 
var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

function TextTrackController() {
  var context_ = this.context;

  var media_ = context_.media;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var currTrackId_ = '';
  var textTracks_ = [];

  function setup() {
    eventBus_.on(_events2.default.TRACK_LOADED, onTextTrackLoaded);
  }

  function onTextTrackLoaded(e) {
    if (currTrackId_ === '') {
      currTrackId_ = '0';
    }
    textTracks_.push(e.track);

    eventBus_.trigger(_events2.default.TRACK_ADDED, {
      track: e.track,
      currTrackId: currTrackId_
    });
  }

  function onTextTrackLoaded_old(e) {
    var cueData = e.cueData;
    var kind = e.kind;
    var label = e.label;
    var textTrack = media_.addTextTrack(kind, label, label);
    textTrack.mode = 'hidden';
    textTrack.oncuechange = function (e) {
      var activeCues = e.currentTarget.activeCues;
      console.log('activeCues: ', activeCues[0]);

      // Get the most recent start time. Cues are sorted by start time in ascending order by the browser
      var startTime = activeCues[activeCues.length - 1].startTime;

      var c = this;
      var a = 2;
      var b = a;
    };

    var trackId = (media_.textTracks.length - 1).toString();

    for (var i = 0; i < cueData.length; i++) {
      var item = cueData[i];
      var data = {
        trackId: trackId,
        start: item.start,
        end: item.end,
        text: item.data
      };

      var cue = createCue(data);
      textTrack.addCue(cue);
    }

    var track = {
      id: trackId,
      lang: e.label,
      label: e.label
    };
    textTracks_.push(track);

    // set default
    if (currTrackId_ === '') {
      if (trackId === '0') {
        currTrackId_ = trackId;
        textTrack.mode = 'showing';
      }
    }

    // Trigger text track found event.
    eventBus_.trigger(_events2.default.TRACK_ADDED, {
      track: track,
      currTrackId: currTrackId_
    });
  }

  function createCue(data) {
    function findTrackById(id) {
      var ret = void 0;
      for (var i = 0; i < media_.textTracks.length; i++) {
        var track = media_.textTracks[i];
        if (id === i.toString()) {
          ret = track;
        }
      }
      return ret;
    }

    var cue = new Cue(data.start, data.end, '');
    cue.data = data;
    // FIXME: Need to hide ttml render if you want to hide a texttrack while a cue is showing.
    // IDEA: Create a series of div for each text track.
    cue.onenter = function () {
      var data = this.data;
      console.log('onenter, [' + data.start + ', ' + data.end + '] = ' + data.text);
    };
    cue.onexit = function () {
      var data = this.data;
      console.log('onexit, [' + data.start + ', ' + data.end + '] = ' + data.text);
    };

    return cue;
  }

  function addTextTrack() {
    // method1
    // textTrack_ = media_.addTextTrack('subtitles', 'English', 'eng');
    // textTrack_.mode = 'showing';
    // for (let i = 0; i < 60; i++) {
    //   let data = {
    //     start: i,
    //     end: i + 1,
    //     text: 'current time: ' + i.toString()
    //   }
    //   let cue = createCue(data);
    //   textTrack_.addCue(cue);
    // }

    //// method2
    //let textTrack = document.createElement('track');
    //textTrack.kind = 'subtitle';
    //textTrack.label = 'English';
    //textTrack.srclang = 'eng';
    //media.appendChild(textTrack);

    //textTrack = media.textTracks[0];
    //textTrack.mode = 'showing';

    // // BD
    // console.log('begin add first cue');
    // let cue = new Cue(10, 15, 'This is a placeholder text');
    // textTrack.addCue(cue);
    // console.log('after add first cue');

    // clearCurrentCues(textTrack);

    // console.log('begin add second cue');
    // let cue1 = new Cue(0, 12, 'This is a placeholder text1');
    // textTrack.addCue(cue1);
    // console.log('after add second cue');

    // let a = 2;
    // let b = a;
    // ED

    return;

    //
    // let cue = new Cue(0, 100, 'This is a placeholder text');
    // textTrack.addCue(cue);

    // for (let i = 0; i <= 10; i ++) {
    //  let cue = new Cue(i, i+1, 'current time: ' + i.toString());

    //// test1
    //let n = 5;
    //if (i % n == 0) {
    //  cue.align = "start"; 
    //} else if (i % n == 1) {
    //  cue.align = "center";
    //} else if (i % n == 2) {
    //  cue.align = "end";
    //} else if (i % n == 3) {
    //  cue.align = "left";
    //} else if (i % n == 4) {
    //  cue.align = "right";
    //}

    // test2, text
    //cue.lineAlign = "start";
    //cue.line = i;

    // test3
    //cue.positionAlign = "start";
    //cue.position = i*10;

    // chrome
    //cue.align = "start";
    //cue.line = 0;
    //cue.lineAlign = "start";
    //cue.position = "auto";
    //cue.size = 100;
    //cue.snapToLines = false;

    // firefox47
    //cue.align = "start";
    //cue.line = 0;
    //cue.lineAlign = "start";
    //cue.position = 10;
    //cue.positionAlign = "end";
    //cue.size = 100;
    //cue.snapToLines = false;

    // firefox53
    //cue.position = 'auto';
    //cue.positionAlign = 'center';

    //  textTrack.addCue(cue);
    //}
  }

  function getSubtitleTracks() {
    return textTracks_;
  }

  /**
   * @description Retuns undefined if current don't select any text track.
   */
  function getCurrentSubtitleTrack() {
    var currTrack = void 0;
    for (var i = 0; i < textTracks_.length; i++) {
      var track = textTracks_[i];
      if (track.id === currTrackId_) {
        currTrack = track;
      }
    }
    return currTrack;
  }

  function selectSubtitleTrack(id) {
    currTrackId_ = id;

    eventBus_.trigger(_events2.default.TRACK_CHANGED, {
      currTrackId: currTrackId_
    });
  }

  var instance = {
    getSubtitleTracks: getSubtitleTracks,
    getCurrentSubtitleTrack: getCurrentSubtitleTrack,
    selectSubtitleTrack: selectSubtitleTrack
  };

  setup();

  return instance;
}

TextTrackController.__h5player_factory_name = 'TextTrackController';
exports.default = _FactoryMaker2.default.getSingletonFactory(TextTrackController);

/***/ }),

/***/ "./src/controller/thumbnail_controller.js":
/*!************************************************!*\
  !*** ./src/controller/thumbnail_controller.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _VTTParser = __webpack_require__(/*! ../utils/VTTParser */ "./src/utils/VTTParser.js");

var _VTTParser2 = _interopRequireDefault(_VTTParser);

var _string_utils = __webpack_require__(/*! ../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _xhr_loader = __webpack_require__(/*! ../utils/xhr_loader */ "./src/utils/xhr_loader.js");

var _xhr_loader2 = _interopRequireDefault(_xhr_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ThumbnailController() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var xhrLoader_ = new _xhr_loader2.default();
  var vttParser_ = (0, _VTTParser2.default)(context_).getInstance();

  var track_ = void 0;
  var thumbnailsData_ = void 0;

  function setup() {
    eventBus_.on(_events2.default.THUMBNAIL_LOADING, onThumbnailLoading);
  }

  function onThumbnailLoading(data) {
    track_ = data.track;

    var request = {
      url: track_.file
    };
    var callbacks = {
      onSuccess: onRequestThumbnailSuccess
    };
    xhrLoader_.load(request, null, callbacks);
  }

  function onRequestThumbnailSuccess(buffer) {
    function parseVttText(text, baseUrl) {
      var thumbnailInfo = {};
      var subText = null;
      var index = text.indexOf('#');
      if (index > 0) {
        thumbnailInfo.url = text.slice(0, index);
      } else {
        thumbnailInfo.url = text;
      }
      if (thumbnailInfo.url.indexOf('://') < 0) {
        if (baseUrl) {
          if (baseUrl[baseUrl.length - 1] !== '/') {
            thumbnailInfo.url = baseUrl + '/' + thumbnailInfo.url;
          } else {
            thumbnailInfo.url = baseUrl + thumbnailInfo.url;
          }
        }
      }
      index = text.indexOf('=');
      if (index > 0) {
        subText = text.slice(index + 1).split(',');
        thumbnailInfo.x = subText[0] ? parseInt(subText[0]) : null;
        thumbnailInfo.y = subText[1] ? parseInt(subText[1]) : null;
        thumbnailInfo.w = subText[2] ? parseInt(subText[2]) : null;
        thumbnailInfo.h = subText[3] ? parseInt(subText[3]) : null;
      }
      return thumbnailInfo;
    }

    var data = _string_utils2.default.ab2str_v1(buffer);
    thumbnailsData_ = vttParser_.parse(data);

    var lastSlash = track_.file.lastIndexOf('/');
    var baseUrl = track_.file.substring(0, lastSlash);
    for (var i = 0; i < thumbnailsData_.length; i++) {
      thumbnailsData_[i].data = parseVttText(thumbnailsData_[i].data, baseUrl);
    }
  }

  function getThumbnail(time) {
    if (!thumbnailsData_) {
      return null;
    }

    for (var i in thumbnailsData_) {
      var info = thumbnailsData_[i];
      if (info.start <= time && time <= info.end) {
        return info;
      }
    }

    return null;
  }

  var instance_ = {
    getThumbnail: getThumbnail
  };
  setup();
  return instance_;
}

ThumbnailController.__h5player_factory_name = 'ThumbnailController';
exports.default = _FactoryMaker2.default.getSingletonFactory(ThumbnailController);

/***/ }),

/***/ "./src/core/Debug.js":
/*!***************************!*\
  !*** ./src/core/Debug.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _EventBus = __webpack_require__(/*! ./EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ./events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _FactoryMaker = __webpack_require__(/*! ./FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_LEVEL_NONE = 0; /**
                         * The copyright in this software is being made available under the BSD License,
                         * included below. This software may be subject to other third party and contributor
                         * rights, including patent rights, and no such rights are granted under this license.
                         *
                         * Copyright (c) 2013, Dash Industry Forum.
                         * All rights reserved.
                         *
                         * Redistribution and use in source and binary forms, with or without modification,
                         * are permitted provided that the following conditions are met:
                         *  * Redistributions of source code must retain the above copyright notice, this
                         *  list of conditions and the following disclaimer.
                         *  * Redistributions in binary form must reproduce the above copyright notice,
                         *  this list of conditions and the following disclaimer in the documentation and/or
                         *  other materials provided with the distribution.
                         *  * Neither the name of Dash Industry Forum nor the names of its
                         *  contributors may be used to endorse or promote products derived from this software
                         *  without specific prior written permission.
                         *
                         *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
                         *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                         *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
                         *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
                         *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
                         *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                         *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                         *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                         *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                         *  POSSIBILITY OF SUCH DAMAGE.
                         */

var LOG_LEVEL_FATAL = 1;
var LOG_LEVEL_ERROR = 2;
var LOG_LEVEL_WARNING = 3;
var LOG_LEVEL_INFO = 4;
var LOG_LEVEL_DEBUG = 5;

/**
 * @module Debug
 */
function Debug() {

  var context = this.context;
  var eventBus = (0, _EventBus2.default)(context).getInstance();

  var logFn = [];

  var instance = void 0,
      logToBrowserConsole = void 0,
      showLogTimestamp = void 0,
      showCalleeName = void 0,
      startTime = void 0;

  function setup() {
    logToBrowserConsole = true;
    showLogTimestamp = true;
    showCalleeName = true;
    startTime = new Date().getTime();

    if (typeof window !== 'undefined' && window.console) {
      logFn[LOG_LEVEL_FATAL] = getLogFn(window.console.error);
      logFn[LOG_LEVEL_ERROR] = getLogFn(window.console.error);
      logFn[LOG_LEVEL_WARNING] = getLogFn(window.console.warn);
      logFn[LOG_LEVEL_INFO] = getLogFn(window.console.info);
      logFn[LOG_LEVEL_DEBUG] = getLogFn(window.console.debug);
    }
  }

  function getLogFn(fn) {
    if (fn && fn.bind) {
      return fn.bind(window.console);
    }
    // if not define, return the default function for reporting logs
    return window.console.log.bind(window.console);
  }

  /**
   * Prepends a timestamp in milliseconds to each log message.
   * @param {boolean} value Set to true if you want to see a timestamp in each log message.
   * @default false
   * @memberof module:Debug
   * @instance
   */
  function setLogTimestampVisible(value) {
    showLogTimestamp = value;
  }
  /**
   * Prepends the callee object name, and media type if available, to each log message.
   * @param {boolean} value Set to true if you want to see the callee object name and media type in each log message.
   * @default false
   * @memberof module:Debug
   * @instance
   */
  function setCalleeNameVisible(value) {
    showCalleeName = value;
  }
  /**
   * Toggles logging to the browser's javascript console.  If you set to false you will still receive a log event with the same message.
   * @param {boolean} value Set to false if you want to turn off logging to the browser's console.
   * @default true
   * @memberof module:Debug
   * @instance
   */
  function setLogToBrowserConsole(value) {
    logToBrowserConsole = value;
  }
  /**
   * Use this method to get the state of logToBrowserConsole.
   * @returns {boolean} The current value of logToBrowserConsole
   * @memberof module:Debug
   * @instance
   */
  function getLogToBrowserConsole() {
    return logToBrowserConsole;
  }

  function fatal() {
    for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }

    doLog.apply(undefined, [LOG_LEVEL_FATAL].concat(params));
  }

  function error() {
    for (var _len2 = arguments.length, params = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      params[_key2] = arguments[_key2];
    }

    doLog.apply(undefined, [LOG_LEVEL_ERROR].concat(params));
  }

  function warn() {
    for (var _len3 = arguments.length, params = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      params[_key3] = arguments[_key3];
    }

    doLog.apply(undefined, [LOG_LEVEL_WARNING].concat(params));
  }

  function info() {
    for (var _len4 = arguments.length, params = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      params[_key4] = arguments[_key4];
    }

    doLog.apply(undefined, [LOG_LEVEL_INFO].concat(params));
  }

  function debug() {
    for (var _len5 = arguments.length, params = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      params[_key5] = arguments[_key5];
    }

    doLog.apply(undefined, [LOG_LEVEL_DEBUG].concat(params));
  }

  function log() {
    for (var _len6 = arguments.length, params = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      params[_key6] = arguments[_key6];
    }

    doLog.apply(undefined, [LOG_LEVEL_DEBUG].concat(params));
  }

  /**
   * This method will allow you send log messages to either the browser's console and/or dispatch an event to capture at the media player level.
   * @param {...*} arguments The message you want to log. The Arguments object is supported for this method so you can send in comma separated logging items.
   * @memberof module:Debug
   * @instance
   */
  function doLog(level) {
    var message = '';
    var logTime = null;

    if (showLogTimestamp) {
      // old from dashjs
      //logTime = new Date().getTime();
      //message += '[' + (logTime - startTime) + ']';
      // new by oldmtn
      logTime = new Date();
      message += '[' + ('0' + (logTime.getMonth() + 1)).slice(-2) + '-' + ('0' + logTime.getDate()).slice(-2) + ' ' + ('0' + logTime.getHours()).slice(-2) + ':' + ('0' + logTime.getMinutes()).slice(-2) + ':' + ('0' + logTime.getSeconds()).slice(-2) + '.' + ('0' + logTime.getMilliseconds()).slice(-3) + ']';
    }

    if (showCalleeName && this && this.getClassName) {
      message += '[' + this.getClassName() + ']';
      if (this.getType) {
        message += '[' + this.getType() + ']';
      }
    }

    if (message.length > 0) {
      message += ' ';
    }

    for (var _len7 = arguments.length, params = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      params[_key7 - 1] = arguments[_key7];
    }

    Array.apply(null, params).forEach(function (item) {
      message += item + ' ';
    });

    if (logFn[level]) {
      logFn[level](message);
    }

    eventBus.trigger(_events2.default.LOG, {
      message: message
    });
  }

  instance = {
    fatal: fatal,
    error: error,
    warn: warn,
    info: info,
    debug: debug,
    log: log,
    setLogTimestampVisible: setLogTimestampVisible,
    setCalleeNameVisible: setCalleeNameVisible,
    setLogToBrowserConsole: setLogToBrowserConsole,
    getLogToBrowserConsole: getLogToBrowserConsole
  };

  setup();

  return instance;
}

Debug.__h5player_factory_name = 'Debug';
var factory = _FactoryMaker2.default.getSingletonFactory(Debug);
factory.LOG_LEVEL_NONE = LOG_LEVEL_NONE;
factory.LOG_LEVEL_FATAL = LOG_LEVEL_FATAL;
factory.LOG_LEVEL_ERROR = LOG_LEVEL_ERROR;
factory.LOG_LEVEL_WARNING = LOG_LEVEL_WARNING;
factory.LOG_LEVEL_INFO = LOG_LEVEL_INFO;
factory.LOG_LEVEL_DEBUG = LOG_LEVEL_DEBUG;
exports.default = factory;

/***/ }),

/***/ "./src/core/EventBus.js":
/*!******************************!*\
  !*** ./src/core/EventBus.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ./FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EVENT_PRIORITY_LOW = 0; /**
                             * The copyright in this software is being made available under the BSD License,
                             * included below. This software may be subject to other third party and contributor
                             * rights, including patent rights, and no such rights are granted under this license.
                             *
                             * Copyright (c) 2013, Dash Industry Forum.
                             * All rights reserved.
                             *
                             * Redistribution and use in source and binary forms, with or without modification,
                             * are permitted provided that the following conditions are met:
                             *  * Redistributions of source code must retain the above copyright notice, this
                             *  list of conditions and the following disclaimer.
                             *  * Redistributions in binary form must reproduce the above copyright notice,
                             *  this list of conditions and the following disclaimer in the documentation and/or
                             *  other materials provided with the distribution.
                             *  * Neither the name of Dash Industry Forum nor the names of its
                             *  contributors may be used to endorse or promote products derived from this software
                             *  without specific prior written permission.
                             *
                             *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
                             *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                             *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
                             *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
                             *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
                             *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                             *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                             *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                             *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                             *  POSSIBILITY OF SUCH DAMAGE.
                             */

var EVENT_PRIORITY_HIGH = 5000;

function EventBus() {

  var handlers = {};

  function on(evType, listener, scope) {
    var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EVENT_PRIORITY_LOW;


    if (!evType) {
      throw new Error('event evType cannot be null or undefined');
    }
    if (!listener || typeof listener !== 'function') {
      throw new Error('listener must be a function: ' + listener);
    }

    if (getHandlerIdx(evType, listener, scope) >= 0) return;

    handlers[evType] = handlers[evType] || [];

    var handler = {
      callback: listener,
      scope: scope,
      priority: priority
    };

    var inserted = handlers[evType].some(function (item, idx) {
      if (priority > item.priority) {
        handlers[evType].splice(idx, 0, handler);
        return true;
      }
    });

    if (!inserted) {
      handlers[evType].push(handler);
    }
  }

  function off(evType, listener, scope) {
    if (!evType || !listener || !handlers[evType]) return;
    var idx = getHandlerIdx(evType, listener, scope);
    if (idx < 0) return;
    handlers[evType].splice(idx, 1);
  }

  function trigger(evType, payload) {
    if (!evType || !handlers[evType]) return;

    payload = payload || {};

    if (payload.hasOwnProperty('evType')) throw new Error('\'evType\' is a reserved word for event dispatching');

    payload.evType = evType;

    handlers[evType].forEach(function (handler) {
      return handler.callback.call(handler.scope, payload);
    });
  }

  function getHandlerIdx(evType, listener, scope) {

    var idx = -1;

    if (!handlers[evType]) return idx;

    handlers[evType].some(function (item, index) {
      if (item.callback === listener && (!scope || scope === item.scope)) {
        idx = index;
        return true;
      }
    });
    return idx;
  }

  function reset() {
    handlers = {};
  }

  var instance = {
    on: on,
    off: off,
    trigger: trigger,
    reset: reset
  };

  return instance;
}

EventBus.__h5player_factory_name = 'EventBus';
var factory = _FactoryMaker2.default.getSingletonFactory(EventBus);
factory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;
factory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;
exports.default = factory;

/***/ }),

/***/ "./src/core/FactoryMaker.js":
/*!**********************************!*\
  !*** ./src/core/FactoryMaker.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * @module FactoryMaker
 */
var FactoryMaker = function () {

  var instance = void 0;
  var extensions = [];
  var singletonContexts = [];

  function extend(name, childInstance, override, context) {
    var extensionContext = getExtensionContext(context);
    if (!extensionContext[name] && childInstance) {
      extensionContext[name] = {
        instance: childInstance,
        override: override
      };
    }
  }

  /**
   * Use this method from your extended object.  this.factory is injected into your object.
   * this.factory.getSingletonInstance(this.context, 'VideoModel')
   * will return the video model for use in the extended object.
   *
   * @param {Object} context - injected into extended object as this.context
   * @param {string} className - string name found in all dash.js objects
   * with name __h5player_factory_name Will be at the bottom. Will be the same as the object's name.
   * @returns {*} Context aware instance of specified singleton name.
   * @memberof module:FactoryMaker
   * @instance
   */
  function getSingletonInstance(context, className) {
    for (var i in singletonContexts) {
      var obj = singletonContexts[i];
      if (obj.context === context && obj.name === className) {
        return obj.instance;
      }
    }
    return null;
  }

  /**
   * Use this method to add an singleton instance to the system.  Useful for unit testing to mock objects etc.
   *
   * @param {Object} context
   * @param {string} className
   * @param {Object} instance
   * @memberof module:FactoryMaker
   * @instance
   */
  function setSingletonInstance(context, className, instance) {
    for (var i in singletonContexts) {
      var obj = singletonContexts[i];
      if (obj.context === context && obj.name === className) {
        singletonContexts[i].instance = instance;
        return;
      }
    }
    singletonContexts.push({
      name: className,
      context: context,
      instance: instance
    });
  }

  function getClassFactory(classConstructor) {
    return function (context) {
      if (context === undefined) {
        context = {};
      }

      return {
        create: function create() {
          return merge(classConstructor.__h5player_factory_name, classConstructor.apply({
            context: context
          }, arguments), context, arguments);
        }
      };
    };
  }

  function getSingletonFactory(classConstructor) {
    return function (context) {
      var instance = void 0;
      if (context === undefined) {
        context = {};
      }
      return {
        getInstance: function getInstance() {
          // If we don't have an instance yet check for one on the context
          if (!instance) {
            instance = getSingletonInstance(context, classConstructor.__h5player_factory_name);
          }
          // If there's no instance on the context then create one
          if (!instance) {
            instance = merge(classConstructor.__h5player_factory_name, classConstructor.apply({
              context: context
            }, arguments), context, arguments);
            singletonContexts.push({
              name: classConstructor.__h5player_factory_name,
              context: context,
              instance: instance
            });
          }
          return instance;
        }
      };
    };
  }

  function merge(name, classConstructor, context, args) {
    var extensionContext = getExtensionContext(context);
    var extensionObject = extensionContext[name];
    if (extensionObject) {
      var extension = extensionObject.instance;
      if (extensionObject.override) {
        //Override public methods in parent but keep parent.
        extension = extension.apply({
          context: context,
          factory: instance,
          parent: classConstructor
        }, args);
        for (var prop in extension) {
          if (classConstructor.hasOwnProperty(prop)) {
            classConstructor[prop] = extension[prop];
          }
        }
      } else {
        //replace parent object completely with new object. Same as dijon.
        return extension.apply({
          context: context,
          factory: instance
        }, args);
      }
    }
    return classConstructor;
  }

  function getExtensionContext(context) {
    var extensionContext = void 0;
    extensions.forEach(function (obj) {
      if (obj === context) {
        extensionContext = obj;
      }
    });
    if (!extensionContext) {
      extensionContext = extensions.push(context);
    }
    return extensionContext;
  }

  instance = {
    extend: extend,
    getSingletonInstance: getSingletonInstance,
    setSingletonInstance: setSingletonInstance,
    getSingletonFactory: getSingletonFactory,
    getClassFactory: getClassFactory
  };

  return instance;
}();

exports.default = FactoryMaker;

/***/ }),

/***/ "./src/core/errors.js":
/*!****************************!*\
  !*** ./src/core/errors.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a license error
  LICENSE_ERROR: 'licenseError'
};

var ErrorDetails = exports.ErrorDetails = {};

/***/ }),

/***/ "./src/core/events.js":
/*!****************************!*\
  !*** ./src/core/events.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 *
 */
var CoreEvents =
/**
 * @description Public facing external events to be used when developing a player that implements dash.js.
 */
function CoreEvents() {
    _classCallCheck(this, CoreEvents);

    // media element events
    this.MEDIA_CANPLAY = 'mediaCanPlay';
    this.MEDIA_CANPLAY_THROUGH = 'mediaCanPlayThrough';
    this.MEDIA_DURATION_CHANGED = 'mediaDurationChanged';
    this.MEDIA_ENDED = 'mediaEnded';
    this.MEDIA_LOADEDDATA = 'mediaLoadedData';
    this.MEDIA_LOADEDMETADATA = 'mediaLoadedMetadata';
    this.MEDIA_PAUSED = 'mediaPaused';
    this.MEDIA_PLAY = 'mediaPlay';
    this.MEDIA_PLAYING = 'mediaPlaying';
    this.MEDIA_SEEKING = 'mediaSeeking';
    this.MEDIA_SEEKED = 'mediaSeeked';
    this.MEDIA_TIMEUPDATE = 'mediaTimeupdate';
    this.MEDIA_VOLUME_CHANGED = 'mediaVolumeChanged';
    this.MEDIA_WAITING = 'mediaWaiting';

    // ads internal events
    this.AD_ERROR = 'adError';
    this.AD_STARTED = 'adStarted';
    this.AD_COMPLETE = 'adComplete';
    this.AD_PAUSED = 'adPaused';
    this.AD_RESUMED = 'adResumed';
    this.AD_CONTENT_PAUSE_REQUESTED = 'adContentPauseRequested';
    this.AD_CONTENT_RESUME_REQUESTED = 'adContentResumeRequested';
    this.AD_ADS_MANAGER_LOADED = 'adAdsManagerLoaded';
    this.AD_TIMEUPDATE = 'adTimeUpdate';
    this.AD_COMPANIONS = 'adCompanions';
    this.AD_VOLUME_CHANGED = 'adVolumeChanged';
    // ads custom events
    this.AD_LOADING_COMPLETE = 'adLoadingComplete';

    // DOM Events
    this.FULLSCREEN_CHANGE = 'fullscreenChange';

    // controller events
    this.STATE_CHANGE = 'stateChange';

    this.FINDING_PARSER = 'findingParser';
    this.FOUND_PARSER = 'foundParser';
    this.STREAM_UPDATED = 'streamUpdated'; // Loaded a stream has a specified bitrate.
    // log event
    this.LOG = 'log';
    this.ERROR = 'error';
    // thumbnail
    this.THUMBNAIL_LOADING = 'thumbnailLoading';
    // tracks(captions, thumbnails)
    this.TRACK_LOADING = 'trackLoading';
    this.TRACK_LOADED = 'trackLoaded';
    this.TRACK_ADDED = 'trackAdded';
    this.TRACK_CHANGED = 'trackChanged';
    // chromecast
    this.CAST_CONNECTED = 'castConnected';
    this.CAST_DISCONNECTED = 'castDisconnected';

    // Begin hls.js, for compatible hls.js
    this.MANIFEST_LOADING = 'hlsManifestLoading';
    this.MANIFEST_LOADED = 'hlsManifestLoaded';
    this.MANIFEST_PARSED = 'hlsManifestParsed';
    this.FRAG_LOADING = 'hlsFragLoading';
    this.FRAG_LOADED = 'hlsFragLoaded';
    this.INIT_PTS_FOUND = 'hlsInitPtsFound';
    this.FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment';
    this.FRAG_PARSING_DATA = 'hlsFragParsingData';
    this.FRAG_PARSED = 'hlsFragParsed';
    this.BUFFER_CODEC = 'hlsBufferCodec';
    this.BUFFER_APPENDING = 'hlsBufferAppending';
    this.BUFFER_APPENDED = 'hlsBufferAppended';
    this.BUFFER_EOS = 'hlsBufferEOS';
    this.MEDIA_ATTACHING = 'hlsMediaAttaching';
    this.MEDIA_ATTACHED = 'hlsMediaAttached';
    // End hls.js

    //
    this.TEST_MSG = 'testMsg';
};

var Events = new CoreEvents();
exports.default = Events;

/***/ }),

/***/ "./src/dash/dash_parser.js":
/*!*********************************!*\
  !*** ./src/dash/dash_parser.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import Events from '../core/events';
// import EventBus from '../core/EventBus';
// import Debug from '../core/Debug';

// import StringUtils from '../utils/string_utils';

// // Begin from Dashjs
// import X2JS from './dashjs/externals/xml2json';
// import {
//   replaceIDForTemplate,
//   replaceTokenForTemplate
// } from './dashjs/src/dash/utils/SegmentsUtils';

// import StringMatcher from './dashjs/src/dash/parser/matchers/StringMatcher';
// import DurationMatcher from './dashjs/src/dash/parser/matchers/DurationMatcher';
// import DateTimeMatcher from './dashjs/src/dash/parser/matchers/DateTimeMatcher';
// import NumericMatcher from './dashjs/src/dash/parser/matchers/NumericMatcher';
// // End from Dashjs

// import {
//   Fragment,
//   TrackInfo,
//   PeriodInfo
// } from '../common/common';

function DashParser() {
  //   let context_ = this.context;
  //   let eventBus_ = EventBus(context_).getInstance();
  //   let debug_ = Debug(context_).getInstance();

  //   let xhrLoader_ = context_.loader(context_).create();
  //   // parser reference variable
  //   let matchers_;
  //   let converter_;

  //   // Begin dash manifest info
  //   let streamInfo_;
  //   let aRep_;
  //   // End dash manifest info

  //   let manifestUrl_;

  //   // flag
  //   let fragCurrent_;
  //   let videoHeaderAdded_ = false;
  //   let vSegmentNumber_ = 0;

  //   let audioHeaderAdded_ = false;
  //   let aSegmentNumber_ = 0;

  //   let flagCurrSegmentType;

  //   function setup() {
  //     matchers_ = [
  //       new DurationMatcher(),
  //       new DateTimeMatcher(),
  //       new NumericMatcher(),
  //       new StringMatcher() // last in list to take precedence over NumericMatcher
  //     ];

  //     converter_ = new X2JS({
  //       escapeMode: false,
  //       attributePrefix: '',
  //       arrayAccessForm: 'property',
  //       emptyNodeForm: 'object',
  //       stripWhitespaces: false,
  //       enableToStringFunc: false,
  //       ignoreRoot: true,
  //       matchers: matchers_
  //     });
  //   }

  //   function getRepresentation(manifest) {
  //     function getSegmentDuration(segmentTemplate) {
  //       let duration = segmentTemplate.duration;
  //       if (segmentTemplate.timescale) {
  //         duration = segmentTemplate.duration / segmentTemplate.timescale;
  //       }

  //       return duration;
  //     }
  //     //
  //     let mediaPresentationDuration = manifest.mediaPresentationDuration;

  //     streamInfo_ = new PeriodInfo();
  //     streamInfo_.duration = mediaPresentationDuration;

  //     let period = manifest.Period_asArray[0];
  //     for (let i = 0; i < period.AdaptationSet_asArray.length; i++) {
  //       let adaptationSet = period.AdaptationSet_asArray[i];
  //       let segmentTemplate = adaptationSet.SegmentTemplate;
  //       let representation = adaptationSet.Representation;

  //       let cnt = mediaPresentationDuration / getSegmentDuration(segmentTemplate);
  //       let remainder = mediaPresentationDuration % getSegmentDuration(segmentTemplate);

  //       let track = new TrackInfo();
  //       track.rep = adaptationSet.Representation;
  //       track.segmentTemplate = adaptationSet.SegmentTemplate;
  //       track.segmentCnt = parseInt(cnt) + (remainder > 0 ? 1 : 0);
  //       track.endNumber = track.segmentCnt + segmentTemplate.startNumber;
  //       //
  //       if (representation.mimeType.indexOf('video') !== -1) {
  //         track.type = 'video';
  //         vSegmentNumber_ = parseInt(segmentTemplate.startNumber);
  //       } else {
  //         track.type = 'audio';
  //         aSegmentNumber_ = parseInt(segmentTemplate.startNumber);
  //       }

  //       debug_.log(`${track.type} segment, start number:${segmentTemplate.startNumber}, cnt:${track.segmentCnt}`);

  //       streamInfo_.tracks.push(track);
  //     }

  //     flagCurrSegmentType = 'video';
  //   }

  //   function loadManifest(url) {
  //     manifestUrl_ = url;

  //     videoHeaderAdded_ = false;
  //     vSegmentNumber_ = 0;
  //     audioHeaderAdded_ = false;
  //     aSegmentNumber_ = 0;

  //     function onSuccess(bytes) {
  //       let content = StringUtils.ab2str_v1(bytes);
  //       debug_.log('content: ' + content);

  //       let manifest = converter_.xml_str2json(content);
  //       getRepresentation(manifest);

  //       eventBus_.trigger(Events.MANIFEST_PARSED);

  //       eventBus_.trigger(Events.STREAM_UPDATED, streamInfo_);

  //       // trigger buffer codec;
  //       let tracks = {};
  //       let vTrack = findTrackInfo('video');
  //       if (vTrack) {
  //         tracks.video = {};
  //         tracks.video.container = 'video/mp4';
  //         tracks.video.codec = vTrack.rep.codecs;
  //       }
  //       let aTrack = findTrackInfo('audio');
  //       if (aTrack) {
  //         tracks.audio = {};
  //         tracks.audio.container = 'audio/mp4';
  //         tracks.audio.codec = aTrack.rep.codecs;
  //       }

  //       eventBus_.trigger(Events.BUFFER_CODEC, tracks);
  //     }

  //     let request = {
  //       url: manifestUrl_
  //     };
  //     let callbacks = {
  //       onSuccess: onSuccess
  //     }

  //     xhrLoader_.load(request, null, callbacks);
  //   }

  //   function getFragmentInitialization(track) {
  //     let initialization = replaceIDForTemplate(track.segmentTemplate.initialization, track.rep.id);

  //     let url = require('url');
  //     return url.resolve(manifestUrl_, initialization);
  //   }

  //   function getFragmentMedia(track, number) {
  //     let media = replaceTokenForTemplate(track.segmentTemplate.media, 'Number', number);
  //     media = replaceIDForTemplate(media, track.rep.id);

  //     let url = require('url');
  //     return url.resolve(manifestUrl_, media);
  //   }

  //   function getAudioFragment() {
  //     let frag = null;
  //     let audioTrack = findTrackInfo('audio');
  //     if (audioTrack) {
  //       if (audioHeaderAdded_ === false) {
  //         frag = new Fragment();
  //         frag.type = 'audio';
  //         frag.url = getFragmentInitialization(audioTrack);
  //         frag.content = 'initSegment';
  //         audioHeaderAdded_ = true;
  //       } else {
  //         if (aSegmentNumber_ < audioTrack.endNumber) {
  //           frag = new Fragment();
  //           frag.type = 'audio';
  //           frag.url = getFragmentMedia(audioTrack, aSegmentNumber_);
  //           frag.content = 'data';
  //           aSegmentNumber_++;
  //         } else {
  //           frag = null;
  //         }
  //       }
  //     }
  //     return frag;
  //   }

  //   function getVideoFragment() {
  //     let frag = null;
  //     let videoTrack = findTrackInfo('video');

  //     if (videoTrack) {
  //       if (videoHeaderAdded_ === false) {
  //         frag = new Fragment();
  //         frag.type = 'video';
  //         frag.url = getFragmentInitialization(videoTrack);
  //         frag.content = 'initSegment';
  //         videoHeaderAdded_ = true;
  //       } else {
  //         if (vSegmentNumber_ < videoTrack.endNumber) {
  //           frag = new Fragment();
  //           frag.type = 'video';
  //           frag.url = getFragmentMedia(videoTrack, vSegmentNumber_);
  //           frag.content = 'data';
  //           vSegmentNumber_++;
  //         } else {
  //           frag = null;
  //         }
  //       }
  //     }
  //     return frag;
  //   }

  //   function getNextFragment() {
  //     fragCurrent_ = null;
  //     do {
  //       if (flagCurrSegmentType === 'video') {
  //         fragCurrent_ = getVideoFragment();
  //         if (fragCurrent_) {
  //           flagCurrSegmentType = 'audio';
  //         } else {
  //           fragCurrent_ = getAudioFragment();
  //         }
  //       } else if (flagCurrSegmentType === 'audio') {
  //         fragCurrent_ = getAudioFragment();
  //         if (fragCurrent_) {
  //           flagCurrSegmentType = 'video';
  //         } else {
  //           fragCurrent_ = getVideoFragment();
  //         }
  //       }
  //     } while (false);

  //     return fragCurrent_;
  //   }

  //   function onFragmentDownloaded(e) {
  //     eventBus_.trigger(Events.BUFFER_APPENDING, {
  //       type: e.type,
  //       content: e.content,
  //       data: e.data
  //     });
  //   }

  //   function findTrackInfo(type) {
  //     let ret = null;
  //     for (let i = 0; i < streamInfo_.tracks.length; i++) {
  //       let track = streamInfo_.tracks[i];
  //       if (track.type === type) {
  //         ret = track;
  //         break;
  //       }
  //     }

  //     return ret;
  //   }

  //   let instance_ = {
  //     loadManifest: loadManifest,
  //     getNextFragment: getNextFragment
  //   };
  //   setup();
  //   return instance_;
}

DashParser.__h5player_factory_name = 'DashParser';
exports.default = _FactoryMaker2.default.getSingletonFactory(DashParser);

/***/ }),

/***/ "./src/externals/base64.js":
/*!*********************************!*\
  !*** ./src/externals/base64.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* $Date: 2007-06-12 18:02:31 $ */

// from: http://bannister.us/weblog/2007/06/09/simple-base64-encodedecode-javascript/
// Handles encode/decode of ASCII and Unicode strings.

var UTF8 = {};
UTF8.encode = function (s) {
  var u = [];
  for (var i = 0; i < s.length; ++i) {
    var c = s.charCodeAt(i);
    if (c < 0x80) {
      u.push(c);
    } else if (c < 0x800) {
      u.push(0xC0 | c >> 6);
      u.push(0x80 | 63 & c);
    } else if (c < 0x10000) {
      u.push(0xE0 | c >> 12);
      u.push(0x80 | 63 & c >> 6);
      u.push(0x80 | 63 & c);
    } else {
      u.push(0xF0 | c >> 18);
      u.push(0x80 | 63 & c >> 12);
      u.push(0x80 | 63 & c >> 6);
      u.push(0x80 | 63 & c);
    }
  }
  return u;
};
UTF8.decode = function (u) {
  var a = [];
  var i = 0;
  while (i < u.length) {
    var v = u[i++];
    if (v < 0x80) {
      // no need to mask byte
    } else if (v < 0xE0) {
      v = (31 & v) << 6;
      v |= 63 & u[i++];
    } else if (v < 0xF0) {
      v = (15 & v) << 12;
      v |= (63 & u[i++]) << 6;
      v |= 63 & u[i++];
    } else {
      v = (7 & v) << 18;
      v |= (63 & u[i++]) << 12;
      v |= (63 & u[i++]) << 6;
      v |= 63 & u[i++];
    }
    a.push(String.fromCharCode(v));
  }
  return a.join('');
};

var BASE64 = {};
(function (T) {
  var encodeArray = function encodeArray(u) {
    var i = 0;
    var a = [];
    var n = 0 | u.length / 3;
    while (0 < n--) {
      var v = (u[i] << 16) + (u[i + 1] << 8) + u[i + 2];
      i += 3;
      a.push(T.charAt(63 & v >> 18));
      a.push(T.charAt(63 & v >> 12));
      a.push(T.charAt(63 & v >> 6));
      a.push(T.charAt(63 & v));
    }
    if (2 == u.length - i) {
      var v = (u[i] << 16) + (u[i + 1] << 8);
      a.push(T.charAt(63 & v >> 18));
      a.push(T.charAt(63 & v >> 12));
      a.push(T.charAt(63 & v >> 6));
      a.push('=');
    } else if (1 == u.length - i) {
      var v = u[i] << 16;
      a.push(T.charAt(63 & v >> 18));
      a.push(T.charAt(63 & v >> 12));
      a.push('==');
    }
    return a.join('');
  };
  var R = function () {
    var a = [];
    for (var i = 0; i < T.length; ++i) {
      a[T.charCodeAt(i)] = i;
    }
    a['='.charCodeAt(0)] = 0;
    return a;
  }();
  var decodeArray = function decodeArray(s) {
    var i = 0;
    var u = [];
    var n = 0 | s.length / 4;
    while (0 < n--) {
      var v = (R[s.charCodeAt(i)] << 18) + (R[s.charCodeAt(i + 1)] << 12) + (R[s.charCodeAt(i + 2)] << 6) + R[s.charCodeAt(i + 3)];
      u.push(255 & v >> 16);
      u.push(255 & v >> 8);
      u.push(255 & v);
      i += 4;
    };
    if (u) {
      if ('=' == s.charAt(i - 2)) {
        u.pop();
        u.pop();
      } else if ('=' == s.charAt(i - 1)) {
        u.pop();
      }
    }
    return u;
  };
  var ASCII = {};
  ASCII.encode = function (s) {
    var u = [];
    for (var i = 0; i < s.length; ++i) {
      u.push(s.charCodeAt(i));
    }
    return u;
  };
  ASCII.decode = function (u) {
    for (var i = 0; i < s.length; ++i) {
      a[i] = String.fromCharCode(a[i]);
    }
    return a.join('');
  };
  BASE64.decodeArray = function (s) {
    var u = decodeArray(s);
    return new Uint8Array(u);
  };
  BASE64.encodeASCII = function (s) {
    var u = ASCII.encode(s);
    return encodeArray(u);
  };
  BASE64.decodeASCII = function (s) {
    var a = decodeArray(s);
    return ASCII.decode(a);
  };
  BASE64.encode = function (s) {
    var u = UTF8.encode(s);
    return encodeArray(u);
  };
  BASE64.decode = function (s) {
    var u = decodeArray(s);
    return UTF8.decode(u);
  };
})('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/');

/*The following polyfills are not used in dash.js but have caused multiplayer integration issues.
 Therefore commenting them out.
if (undefined === btoa) {
    var btoa = BASE64.encode;
}
if (undefined === atob) {
    var atob = BASE64.decode;
}
*/

if (true) {
  exports.decode = BASE64.decode;
  exports.decodeArray = BASE64.decodeArray;
}

/***/ }),

/***/ "./src/externals/underscore.js":
/*!*************************************!*\
  !*** ./src/externals/underscore.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function () {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global || this || {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype,
      ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function Ctor() {};

  // Create a safe reference to the Underscore object for use below.
  var _ = function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };
      // The 2-argument case is omitted because were not using it.
      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }
    return function () {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function cb(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function builtinIteratee(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function () {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0:
          return func.call(this, rest);
        case 1:
          return func.call(this, arguments[0], rest);
        case 2:
          return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function baseCreate(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function shallowProperty(key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function has(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  };

  var deepGet = function deepGet(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function isArrayLike(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function reducer(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function (obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function (obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function (context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function (obj, iteratee, context) {
    var result = -Infinity,
        lastComputed = -Infinity,
        value,
        computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function (obj, iteratee, context) {
    var result = Infinity,
        lastComputed = Infinity,
        value,
        computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function (obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function (obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function group(behavior, partition) {
    return function (obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function (result, value, key) {
    if (has(result, key)) result[key].push(value);else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function (result, value, key) {
    if (has(result, key)) result[key]++;else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function (result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function flatten(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0,
              len = value.length;
          while (j < len) {
            output[idx++] = value[j++];
          }
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function (array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function (arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function (array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function (list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
          length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function (array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0,
        length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function (func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function (callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function (func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function bound() {
      var position = 0,
          length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) {
        args.push(arguments[position++]);
      }return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function (obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memoize = function memoize(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function (func, wait, args) {
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function later() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function throttled() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, result;

    var later = function later(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function (args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) {
        result = args[i].call(this, result);
      }return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) {
      if (has(obj, key)) keys.push(key);
    } // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function (obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) {
      keys.push(key);
    } // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function createAssigner(keysFunc, defaults) {
    return function (obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj),
        key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function keyInObj(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function (obj, keys) {
    var result = {},
        iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function (obj, keys) {
    var iteratee = keys[0],
        context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function iteratee(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs),
        length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a === 'undefined' ? 'undefined' : _typeof(a);
    if (type !== 'function' && type !== 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor,
          bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a),
          key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function (obj) {
    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function (obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function (value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function (value) {
    return function () {
      return value;
    };
  };

  _.noop = function () {};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function (path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function (obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function (obj) {
    if (obj == null) {
      return function () {};
    }
    return function (path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) {
      accum[i] = iteratee(i);
    }return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function () {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function createEscaper(map) {
    var escaper = function escaper(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function (obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function escapeChar(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function template(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function (obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function chainResult(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function () {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function () {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/hls/hls_parser.js":
/*!*******************************!*\
  !*** ./src/hls/hls_parser.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _string_utils = __webpack_require__(/*! ../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _common = __webpack_require__(/*! ../common/common */ "./src/common/common.js");

var _m3u8Parser = __webpack_require__(/*! ../../third_party/hlsjs/src/loader/m3u8-parser */ "./third_party/hlsjs/src/loader/m3u8-parser.js");

var _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function HlsParser() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var streamInfo_ = void 0;

  // hls
  var currentSN_ = void 0;
  var fragCurrent_ = void 0;

  function setup() {
    eventBus_.on(_events2.default.MANIFEST_LOADED, onManifestLoaded);
  }

  // event callbacks
  function onManifestLoaded(data) {
    var content = _string_utils2.default.ab2str_v1(data.bytes);
    var url = data.url;
    debug_.log('content: ' + content);

    currentSN_ = 0;

    var track = new _common.TrackInfo();
    track.type = 'stream';
    track.levelDetails = _m3u8Parser2.default.parseLevelPlaylist(content, url, 0, 'main');

    streamInfo_ = new _common.PeriodInfo();
    streamInfo_.duration = track.levelDetails.totalduration;
    streamInfo_.tracks.push(track);

    eventBus_.trigger(_events2.default.MANIFEST_PARSED, streamInfo_);
  }

  // public functions
  function getType() {
    return 'hls';
  }

  function getNextFragment() {
    for (var i = 0; i < streamInfo_.tracks.length; i++) {
      var trackInfo = streamInfo_.tracks[i];
      if (trackInfo.type === 'stream') {
        // get initSegment first
        if (trackInfo.levelDetails.initSegment && !trackInfo.levelDetails.initSegment.data) {
          fragCurrent_ = trackInfo.levelDetails.initSegment;
        } else {
          if (currentSN_ === trackInfo.levelDetails.fragments.length) {
            fragCurrent_ = null;
          } else {
            fragCurrent_ = trackInfo.levelDetails.fragments[currentSN_];
            currentSN_++;
          }
        }
        break;
      }
    }

    return fragCurrent_;
  }

  var instance_ = {
    getType: getType,
    getNextFragment: getNextFragment
  };
  setup();
  return instance_;
}

HlsParser.__h5player_factory_name = 'HlsParser';
exports.default = _FactoryMaker2.default.getSingletonFactory(HlsParser);

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _events = __webpack_require__(/*! ./core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ./core/errors */ "./src/core/errors.js");

var _common_utils = __webpack_require__(/*! ./utils/common_utils */ "./src/utils/common_utils.js");

var _common_utils2 = _interopRequireDefault(_common_utils);

var _Player = __webpack_require__(/*! ./Player */ "./src/Player.js");

var _Player2 = _interopRequireDefault(_Player);

var _cast_receiver = __webpack_require__(/*! ./cast/cast_receiver */ "./src/cast/cast_receiver.js");

var _cast_receiver2 = _interopRequireDefault(_cast_receiver);

var _ui_engine = __webpack_require__(/*! ./ui/js/ui_engine */ "./src/ui/js/ui_engine.js");

var _ui_engine2 = _interopRequireDefault(_ui_engine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Shove both of these into the global scope
var context = typeof window !== 'undefined' && window || global;

var oldmtn = context.oldmtn;
if (!oldmtn) {
  oldmtn = context.oldmtn = {};
}

oldmtn.Player = _Player2.default;
oldmtn.Events = _events2.default;
oldmtn.ErrorTypes = _errors.ErrorTypes;
oldmtn.CastReceiver = _cast_receiver2.default;

oldmtn.CommonUtils = _common_utils2.default;

oldmtn.UIEngine = _ui_engine2.default;

/////////////////////////////////////////////////////////////////////////

exports.default = oldmtn;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/loader/fragment_loader.js":
/*!***************************************!*\
  !*** ./src/loader/fragment_loader.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _xhr_loader = __webpack_require__(/*! ../utils/xhr_loader */ "./src/utils/xhr_loader.js");

var _xhr_loader2 = _interopRequireDefault(_xhr_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FragmentLoader() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var xhrLoader_ = new _xhr_loader2.default();

  var request_ = void 0;
  function setup() {
    eventBus_.on(_events2.default.FRAG_LOADING, onFragLoading);
  }

  function onFragLoading(e) {
    var frag = e.frag;
    request_ = {
      frag: frag,
      url: frag.url,
      rangeStart: frag.byteRangeStartOffset,
      rangeEnd: frag.byteRangeEndOffset
    };
    var callbacks = {
      onSuccess: loadsuccess
    };

    debug_.log('+onFragLoading, ' + request_.url + ', [' + request_.rangeStart + ', ' + request_.rangeEnd + '], sn:' + request_.frag.sn);
    xhrLoader_.load(request_, null, callbacks);
  }

  function loadsuccess(payload) {
    var frag = request_.frag;
    frag.data = payload;
    eventBus_.trigger(_events2.default.FRAG_LOADED, { frag: frag });
  }

  var instance_ = {};

  setup();
  return instance_;
}

FragmentLoader.__h5player_factory_name = 'FragmentLoader';
exports.default = _FactoryMaker2.default.getClassFactory(FragmentLoader);

/***/ }),

/***/ "./src/loader/playlist_loader.js":
/*!***************************************!*\
  !*** ./src/loader/playlist_loader.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _string_utils = __webpack_require__(/*! ../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _xhr_loader = __webpack_require__(/*! ../utils/xhr_loader */ "./src/utils/xhr_loader.js");

var _xhr_loader2 = _interopRequireDefault(_xhr_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PlaylistLoader() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var xhrLoader_ = new _xhr_loader2.default();
  var request_ = void 0;

  function setup() {
    eventBus_.on(_events2.default.MANIFEST_LOADING, onManifestLoading);
  }

  function onManifestLoading(data) {
    request_ = {
      url: data.url
    };
    var callbacks = {
      onSuccess: loadsuccess
    };

    xhrLoader_.load(request_, null, callbacks);
  }

  function loadsuccess(bytes) {
    eventBus_.trigger(_events2.default.MANIFEST_LOADED, { bytes: bytes, url: request_.url });
  }

  var instance_ = {};
  setup();
  return instance_;
}

PlaylistLoader.__h5player_factory_name = 'PlaylistLoader';
exports.default = _FactoryMaker2.default.getSingletonFactory(PlaylistLoader);

/***/ }),

/***/ "./src/loader/track_loader.js":
/*!************************************!*\
  !*** ./src/loader/track_loader.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _VTTParser = __webpack_require__(/*! ../utils/VTTParser */ "./src/utils/VTTParser.js");

var _VTTParser2 = _interopRequireDefault(_VTTParser);

var _string_utils = __webpack_require__(/*! ../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _ajax = __webpack_require__(/*! ../utils/ajax */ "./src/utils/ajax.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TrackLoader() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var vttParser_ = (0, _VTTParser2.default)(context_).getInstance();

  function setup() {
    eventBus_.on(_events2.default.TRACK_LOADING, onTrackLoading);
  }

  function onTrackLoading(data) {
    var track_ = data.track;

    function successHandler(xhr) {
      var data = xhr.responseText;
      var cueData = vttParser_.parse(data);
      track_.data = cueData;

      eventBus_.trigger(_events2.default.TRACK_LOADED, { track: track_ });
    }

    function errorHandler(xhr) {}

    (0, _ajax.ajax)(track_.file, successHandler, errorHandler);
  }

  var instance_ = {};

  setup();
  return instance_;
}

TrackLoader.__h5player_factory_name = 'TrackLoader';
exports.default = _FactoryMaker2.default.getSingletonFactory(TrackLoader);

/***/ }),

/***/ "./src/pd/pd_parser.js":
/*!*****************************!*\
  !*** ./src/pd/pd_parser.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _events = __webpack_require__(/*! ../core/events */ "./src/core/events.js");

var _events2 = _interopRequireDefault(_events);

var _EventBus = __webpack_require__(/*! ../core/EventBus */ "./src/core/EventBus.js");

var _EventBus2 = _interopRequireDefault(_EventBus);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

var _common = __webpack_require__(/*! ../common/common */ "./src/common/common.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PDParser() {
  var context_ = this.context;
  var eventBus_ = (0, _EventBus2.default)(context_).getInstance();
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var streamInfo_ = void 0;
  var flagGotFragment = false;

  function getType() {
    return 'pd';
  }

  function loadManifest(url) {
    streamInfo_ = new _common.PeriodInfo();
    streamInfo_.url = url;
    eventBus_.trigger(_events2.default.MANIFEST_PARSED);
  }

  function getNextFragment() {
    if (!flagGotFragment) {
      flagGotFragment = true;
      var frag = {};
      frag.type = 'pd';
      frag.url = streamInfo_.url;
      return frag;
    } else {
      return null;
    }
  }

  var instance = {
    getType: getType,
    loadManifest: loadManifest,
    getNextFragment: getNextFragment
  };
  return instance;
}

PDParser.__h5player_factory_name = 'PDParser';
exports.default = _FactoryMaker2.default.getSingletonFactory(PDParser);

/***/ }),

/***/ "./src/protection/controller/ProtectionKeyController.js":
/*!**************************************************************!*\
  !*** ./src/protection/controller/ProtectionKeyController.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _KeySystemClearKey = __webpack_require__(/*! ./../drm/KeySystemClearKey */ "./src/protection/drm/KeySystemClearKey.js");

var _KeySystemClearKey2 = _interopRequireDefault(_KeySystemClearKey);

var _KeySystemWidevine = __webpack_require__(/*! ./../drm/KeySystemWidevine */ "./src/protection/drm/KeySystemWidevine.js");

var _KeySystemWidevine2 = _interopRequireDefault(_KeySystemWidevine);

var _KeySystemPlayReady = __webpack_require__(/*! ./../drm/KeySystemPlayReady */ "./src/protection/drm/KeySystemPlayReady.js");

var _KeySystemPlayReady2 = _interopRequireDefault(_KeySystemPlayReady);

var _KeySystemCCPlayReady = __webpack_require__(/*! ./../drm/KeySystemCCPlayReady */ "./src/protection/drm/KeySystemCCPlayReady.js");

var _KeySystemCCPlayReady2 = _interopRequireDefault(_KeySystemCCPlayReady);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ProtectionKeyController() {
  var context_ = this.context;

  var instance_ = void 0;
  var keySystems_ = void 0;

  function initialize() {
    keySystems_ = [];

    var keySystem;

    // ClearKey
    keySystem = (0, _KeySystemClearKey2.default)(context_).getInstance();
    keySystems_.push(keySystem);

    // PlayReady
    keySystem = (0, _KeySystemPlayReady2.default)(context_).getInstance();
    keySystems_.push(keySystem);

    // Widevine
    keySystem = (0, _KeySystemWidevine2.default)(context_).getInstance();
    keySystems_.push(keySystem);

    // Chromecast PlayReady
    keySystem = (0, _KeySystemCCPlayReady2.default)(context_).getInstance();
    keySystems_.push(keySystem);
  }

  function getKeySystems() {
    return keySystems;
  }

  function getKeySystemBySystemString(systemString) {
    if (window.cast && window.cast.__platform__) {
      if (systemString === 'com.microsoft.playready') {
        systemString = 'com.chromecast.playready';
      }
    }

    for (var i = 0; i < keySystems_.length; i++) {
      if (keySystems_[i].systemString === systemString) {
        return keySystems_[i];
      }
    }
    return null;
  }

  instance_ = {
    getKeySystems: getKeySystems,
    getKeySystemBySystemString: getKeySystemBySystemString
  };

  initialize();
  return instance_;
}

ProtectionKeyController.__h5player_factory_name = 'ProtectionKeyController';
exports.default = _FactoryMaker2.default.getSingletonFactory(ProtectionKeyController);

/***/ }),

/***/ "./src/protection/drm/KeySystemCCPlayReady.js":
/*!****************************************************!*\
  !*** ./src/protection/drm/KeySystemCCPlayReady.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CommonEncryption = __webpack_require__(/*! ../vo/CommonEncryption */ "./src/protection/vo/CommonEncryption.js");

var _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);

var _Error = __webpack_require__(/*! ../../utils/Error */ "./src/utils/Error.js");

var _Error2 = _interopRequireDefault(_Error);

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _base = __webpack_require__(/*! ../../externals/base64 */ "./src/externals/base64.js");

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Microsoft PlayReady DRM
 *
 * @class
 * @implements KeySystem
 */
var uuid = '9a04f079-9840-4286-ab92-e65be0885f95';
var systemString = 'com.chromecast.playready';
var schemeIdURI = 'urn:uuid:' + uuid;

function KeySystemCCPlayReady() {

  var instance_ = void 0;
  var messageFormat = 'utf16';

  function getRequestHeadersFromMessage(message) {
    var headers = {};
    headers['Content-Type'] = 'text/xml; charset=utf-8';
    headers['SOAPAction'] = 'http://schemas.microsoft.com/DRM/2007/03/protocols/AcquireLicense';
    return headers;
  }

  function getLicenseRequestFromMessage(message) {
    console.log('DRM: cc, getLicenseRequestFromMessage');
    return new Uint8Array(message);
  }

  function getLicenseServerURLFromInitData(initData) {
    if (initData) {
      var data = new DataView(initData);
      var numRecords = data.getUint16(4, true);
      var offset = 6;
      var parser = new DOMParser();

      for (var i = 0; i < numRecords; i++) {
        // Parse the PlayReady Record header
        var recordType = data.getUint16(offset, true);
        offset += 2;
        var recordLength = data.getUint16(offset, true);
        offset += 2;
        if (recordType !== 0x0001) {
          offset += recordLength;
          // VO BEGIN - https://sh.visualon.com/node/64225
          if (offset >= data.byteLength - 2) {
            return null;
          }
          // VO END
          continue;
        }

        var recordData = initData.slice(offset, offset + recordLength);
        var record = String.fromCharCode.apply(null, new Uint16Array(recordData));
        var xmlDoc = parser.parseFromString(record, 'application/xml');

        // First try <LA_URL>
        if (xmlDoc.getElementsByTagName('LA_URL')[0]) {
          var laURL = xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue;
          if (laURL) {
            return laURL;
          }
        }

        // Optionally, try <LUI_URL>
        if (xmlDoc.getElementsByTagName('LUI_URL')[0]) {
          var luiurl = xmlDoc.getElementsByTagName('LUI_URL')[0].childNodes[0].nodeValue;
          if (luiurl) {
            return luiurl;
          }
        }
      }
    }

    return null;
  }

  function getInitData(cpData) {
    // * desc@ getInitData
    // *   generate PSSH data from PROHeader defined in MPD file
    // *   PSSH format:
    // *   size (4)
    // *   box type(PSSH) (8)
    // *   Protection SystemID (16)
    // *   protection system data size (4) - length of decoded PROHeader
    // *   decoded PROHeader data from MPD file
    var PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00]); //'PSSH' 8 bytes
    var playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);

    var byteCursor = 0;
    var uint8arraydecodedPROHeader = null;

    var PROSize, PSSHSize, PSSHBoxBuffer, PSSHBox, PSSHData;

    // Handle common encryption PSSH
    if ('pssh' in cpData) {
      return _CommonEncryption2.default.parseInitDataFromContentProtection(cpData);
    }
    // Handle native MS PlayReady ContentProtection elements
    if ('pro' in cpData) {
      uint8arraydecodedPROHeader = _base2.default.decodeArray(cpData.pro.__text);
    } else if ('prheader' in cpData) {
      uint8arraydecodedPROHeader = _base2.default.decodeArray(cpData.prheader.__text);
    } else {
      return null;
    }

    PROSize = uint8arraydecodedPROHeader.length;
    PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;

    PSSHBoxBuffer = new ArrayBuffer(PSSHSize);

    PSSHBox = new Uint8Array(PSSHBoxBuffer);
    PSSHData = new DataView(PSSHBoxBuffer);

    PSSHData.setUint32(byteCursor, PSSHSize);
    byteCursor += 0x4;

    PSSHBox.set(PSSHBoxType, byteCursor);
    byteCursor += PSSHBoxType.length;

    PSSHBox.set(playreadySystemID, byteCursor);
    byteCursor += playreadySystemID.length;

    PSSHData.setUint32(byteCursor, PROSize);
    byteCursor += 0x4;

    PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);
    byteCursor += PROSize;

    return PSSHBox.buffer;
  }

  /**
   * It seems that some PlayReady implementations return their XML-based CDM
   * messages using UTF16, while others return them as UTF8.  Use this function
   * to modify the message format to expect when parsing CDM messages.
   *
   * @param {string} format the expected message format.  Either "utf8" or "utf16".
   * @throws {Error} Specified message format is not one of "utf8" or "utf16"
   */
  function setPlayReadyMessageFormat(format) {
    if (format !== 'utf8' && format !== 'utf16') {
      throw new _Error2.default('Illegal PlayReady message format! -- ' + format);
    }
    messageFormat = format;
  }

  instance_ = {
    uuid: uuid,
    schemeIdURI: schemeIdURI,
    systemString: systemString,
    getInitData: getInitData,
    getRequestHeadersFromMessage: getRequestHeadersFromMessage,
    getLicenseRequestFromMessage: getLicenseRequestFromMessage,
    getLicenseServerURLFromInitData: getLicenseServerURLFromInitData,
    setPlayReadyMessageFormat: setPlayReadyMessageFormat
  };

  return instance_;
}

KeySystemCCPlayReady.__h5player_factory_name = 'KeySystemCCPlayReady';
exports.default = _FactoryMaker2.default.getSingletonFactory(KeySystemCCPlayReady);

/***/ }),

/***/ "./src/protection/drm/KeySystemClearKey.js":
/*!*************************************************!*\
  !*** ./src/protection/drm/KeySystemClearKey.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuid = '1077efec-c0b2-4d02-ace3-3c1e52e2fb4b'; /**
                                                    * The copyright in this software is being made available under the BSD License,
                                                    * included below. This software may be subject to other third party and contributor
                                                    * rights, including patent rights, and no such rights are granted under this license.
                                                    *
                                                    * Copyright (c) 2013, Dash Industry Forum.
                                                    * All rights reserved.
                                                    *
                                                    * Redistribution and use in source and binary forms, with or without modification,
                                                    * are permitted provided that the following conditions are met:
                                                    *  * Redistributions of source code must retain the above copyright notice, this
                                                    *  list of conditions and the following disclaimer.
                                                    *  * Redistributions in binary form must reproduce the above copyright notice,
                                                    *  this list of conditions and the following disclaimer in the documentation and/or
                                                    *  other materials provided with the distribution.
                                                    *  * Neither the name of Dash Industry Forum nor the names of its
                                                    *  contributors may be used to endorse or promote products derived from this software
                                                    *  without specific prior written permission.
                                                    *
                                                    *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
                                                    *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                                                    *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
                                                    *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
                                                    *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
                                                    *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                                                    *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                    *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                                                    *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                                                    *  POSSIBILITY OF SUCH DAMAGE.
                                                    */

var systemString = 'org.w3.clearkey';
var schemeIdURI = 'urn:uuid:' + uuid;

function KeySystemClearKey() {

  var instance = void 0;
  /**
   * Returns desired clearkeys (as specified in the CDM message) from protection data
   *
   * @param {ProtectionData} protectionData the protection data
   * @param {ArrayBuffer} message the ClearKey CDM message
   * @returns {ClearKeyKeySet} the key set or null if none found
   * @throws {Error} if a keyID specified in the CDM message was not found in the
   * protection data
   * @memberof KeySystemClearKey
   */
  function getClearKeysFromProtectionData(protectionData, message) {
    var clearkeySet = null;
    // if (protectionData) {
    //     // ClearKey is the only system that does not require a license server URL, so we
    //     // handle it here when keys are specified in protection data
    //     var jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message)));
    //     var keyPairs = [];
    //     for (var i = 0; i < jsonMsg.kids.length; i++) {
    //         var clearkeyID = jsonMsg.kids[i];
    //         var clearkey = (protectionData.clearkeys.hasOwnProperty(clearkeyID)) ? protectionData.clearkeys[clearkeyID] : null;
    //         if (!clearkey) {
    //             throw new Error('DRM: ClearKey keyID (' + clearkeyID + ') is not known!');
    //         }
    //         // KeyIDs from CDM are not base64 padded.  Keys may or may not be padded
    //         keyPairs.push(new KeyPair(clearkeyID, clearkey));
    //     }
    //     clearkeySet = new ClearKeyKeySet(keyPairs);
    // }
    return clearkeySet;
  }

  function getInitData(cp) {
    return CommonEncryption.parseInitDataFromContentProtection(cp);
  }

  function getRequestHeadersFromMessage() /*message*/{
    return null;
  }

  function getLicenseRequestFromMessage(message) {
    return new Uint8Array(message);
  }

  function getLicenseServerURLFromInitData() /*initData*/{
    return null;
  }

  instance = {
    uuid: uuid,
    schemeIdURI: schemeIdURI,
    systemString: systemString,
    getInitData: getInitData,
    getRequestHeadersFromMessage: getRequestHeadersFromMessage,
    getLicenseRequestFromMessage: getLicenseRequestFromMessage,
    getLicenseServerURLFromInitData: getLicenseServerURLFromInitData,
    getClearKeysFromProtectionData: getClearKeysFromProtectionData
  };

  return instance;
}

KeySystemClearKey.__h5player_factory_name = 'KeySystemClearKey';
exports.default = _FactoryMaker2.default.getSingletonFactory(KeySystemClearKey);

/***/ }),

/***/ "./src/protection/drm/KeySystemPlayReady.js":
/*!**************************************************!*\
  !*** ./src/protection/drm/KeySystemPlayReady.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CommonEncryption = __webpack_require__(/*! ../vo/CommonEncryption */ "./src/protection/vo/CommonEncryption.js");

var _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);

var _Error = __webpack_require__(/*! ../../utils/Error */ "./src/utils/Error.js");

var _Error2 = _interopRequireDefault(_Error);

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _base = __webpack_require__(/*! ../../externals/base64 */ "./src/externals/base64.js");

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Microsoft PlayReady DRM
 *
 * @class
 * @implements KeySystem
 */
var uuid = '9a04f079-9840-4286-ab92-e65be0885f95';
var systemString = 'com.microsoft.playready';
var schemeIdURI = 'urn:uuid:' + uuid;

function KeySystemPlayReady() {

  var instance_ = void 0;
  var messageFormat = 'utf16';

  function getRequestHeadersFromMessage(message) {
    var msg, xmlDoc;
    var headers = {};
    var parser = new DOMParser();
    var dataview = messageFormat === 'utf16' ? new Uint16Array(message) : new Uint8Array(message);

    msg = String.fromCharCode.apply(null, dataview);
    xmlDoc = parser.parseFromString(msg, 'application/xml');

    var headerNameList = xmlDoc.getElementsByTagName('name');
    var headerValueList = xmlDoc.getElementsByTagName('value');
    for (var i = 0; i < headerNameList.length; i++) {
      headers[headerNameList[i].childNodes[0].nodeValue] = headerValueList[i].childNodes[0].nodeValue;
    }
    // some versions of the PlayReady CDM return 'Content' instead of 'Content-Type'.
    // this is NOT w3c conform and license servers may reject the request!
    // -> rename it to proper w3c definition!
    if (headers.hasOwnProperty('Content')) {
      headers['Content-Type'] = headers.Content;
      delete headers.Content;
    }
    return headers;
  }

  function getLicenseRequestFromMessage(message) {
    var msg, xmlDoc;
    var licenseRequest = null;
    var parser = new DOMParser();
    var dataview = messageFormat === 'utf16' ? new Uint16Array(message) : new Uint8Array(message);

    msg = String.fromCharCode.apply(null, dataview);
    xmlDoc = parser.parseFromString(msg, 'application/xml');

    if (xmlDoc.getElementsByTagName('Challenge')[0]) {
      var Challenge = xmlDoc.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue;
      if (Challenge) {
        licenseRequest = _base2.default.decode(Challenge);
      }
    }
    return licenseRequest;
  }

  function getLicenseServerURLFromInitData(initData) {
    if (initData) {
      var data = new DataView(initData);
      var numRecords = data.getUint16(4, true);
      var offset = 6;
      var parser = new DOMParser();

      for (var i = 0; i < numRecords; i++) {
        // Parse the PlayReady Record header
        var recordType = data.getUint16(offset, true);
        offset += 2;
        var recordLength = data.getUint16(offset, true);
        offset += 2;
        if (recordType !== 0x0001) {
          offset += recordLength;
          // VO BEGIN - https://sh.visualon.com/node/64225
          if (offset >= data.byteLength - 2) {
            return null;
          }
          // VO END
          continue;
        }

        var recordData = initData.slice(offset, offset + recordLength);
        var record = String.fromCharCode.apply(null, new Uint16Array(recordData));
        var xmlDoc = parser.parseFromString(record, 'application/xml');

        // First try <LA_URL>
        if (xmlDoc.getElementsByTagName('LA_URL')[0]) {
          var laURL = xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue;
          if (laURL) {
            return laURL;
          }
        }

        // Optionally, try <LUI_URL>
        if (xmlDoc.getElementsByTagName('LUI_URL')[0]) {
          var luiurl = xmlDoc.getElementsByTagName('LUI_URL')[0].childNodes[0].nodeValue;
          if (luiurl) {
            return luiurl;
          }
        }
      }
    }

    return null;
  }

  function getInitData(cpData) {
    // * desc@ getInitData
    // *   generate PSSH data from PROHeader defined in MPD file
    // *   PSSH format:
    // *   size (4)
    // *   box type(PSSH) (8)
    // *   Protection SystemID (16)
    // *   protection system data size (4) - length of decoded PROHeader
    // *   decoded PROHeader data from MPD file
    var PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00]); //'PSSH' 8 bytes
    var playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);

    var byteCursor = 0;
    var uint8arraydecodedPROHeader = null;

    var PROSize, PSSHSize, PSSHBoxBuffer, PSSHBox, PSSHData;

    // Handle common encryption PSSH
    if ('pssh' in cpData) {
      return _CommonEncryption2.default.parseInitDataFromContentProtection(cpData);
    }
    // Handle native MS PlayReady ContentProtection elements
    if ('pro' in cpData) {
      uint8arraydecodedPROHeader = _base2.default.decodeArray(cpData.pro.__text);
    } else if ('prheader' in cpData) {
      uint8arraydecodedPROHeader = _base2.default.decodeArray(cpData.prheader.__text);
    } else {
      return null;
    }

    PROSize = uint8arraydecodedPROHeader.length;
    PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;

    PSSHBoxBuffer = new ArrayBuffer(PSSHSize);

    PSSHBox = new Uint8Array(PSSHBoxBuffer);
    PSSHData = new DataView(PSSHBoxBuffer);

    PSSHData.setUint32(byteCursor, PSSHSize);
    byteCursor += 0x4;

    PSSHBox.set(PSSHBoxType, byteCursor);
    byteCursor += PSSHBoxType.length;

    PSSHBox.set(playreadySystemID, byteCursor);
    byteCursor += playreadySystemID.length;

    PSSHData.setUint32(byteCursor, PROSize);
    byteCursor += 0x4;

    PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);
    byteCursor += PROSize;

    return PSSHBox.buffer;
  }

  /**
   * It seems that some PlayReady implementations return their XML-based CDM
   * messages using UTF16, while others return them as UTF8.  Use this function
   * to modify the message format to expect when parsing CDM messages.
   *
   * @param {string} format the expected message format.  Either "utf8" or "utf16".
   * @throws {Error} Specified message format is not one of "utf8" or "utf16"
   */
  function setPlayReadyMessageFormat(format) {
    if (format !== 'utf8' && format !== 'utf16') {
      throw new _Error2.default('Illegal PlayReady message format! -- ' + format);
    }
    messageFormat = format;
  }

  instance_ = {
    uuid: uuid,
    schemeIdURI: schemeIdURI,
    systemString: systemString,
    getInitData: getInitData,
    getRequestHeadersFromMessage: getRequestHeadersFromMessage,
    getLicenseRequestFromMessage: getLicenseRequestFromMessage,
    getLicenseServerURLFromInitData: getLicenseServerURLFromInitData,
    setPlayReadyMessageFormat: setPlayReadyMessageFormat
  };

  return instance_;
}

KeySystemPlayReady.__h5player_factory_name = 'KeySystemPlayReady';
exports.default = _FactoryMaker2.default.getSingletonFactory(KeySystemPlayReady);

/***/ }),

/***/ "./src/protection/drm/KeySystemWidevine.js":
/*!*************************************************!*\
  !*** ./src/protection/drm/KeySystemWidevine.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _CommonEncryption = __webpack_require__(/*! ../vo/CommonEncryption */ "./src/protection/vo/CommonEncryption.js");

var _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuid = 'edef8ba9-79d6-4ace-a3c8-27dcd51d21ed';
var systemString = 'com.widevine.alpha';
var schemeIdURI = 'urn:uuid:' + uuid;

function KeySystemWidevine() {

  var instance_ = void 0;

  function getInitData(cp) {
    return _CommonEncryption2.default.parseInitDataFromContentProtection(cp);
  }

  function getRequestHeadersFromMessage() /*message*/{
    return null;
  }

  function getLicenseRequestFromMessage(message) {
    return new Uint8Array(message);
  }

  function getLicenseServerURLFromInitData() /*initData*/{
    return null;
  }

  instance_ = {
    uuid: uuid,
    schemeIdURI: schemeIdURI,
    systemString: systemString,
    getInitData: getInitData,
    getRequestHeadersFromMessage: getRequestHeadersFromMessage,
    getLicenseRequestFromMessage: getLicenseRequestFromMessage,
    getLicenseServerURLFromInitData: getLicenseServerURLFromInitData
  };

  return instance_;
}

KeySystemWidevine.__h5player_factory_name = 'KeySystemWidevine';
exports.default = _FactoryMaker2.default.getSingletonFactory(KeySystemWidevine);

/***/ }),

/***/ "./src/protection/models/ProtectionModel_21Jan2015.js":
/*!************************************************************!*\
  !*** ./src/protection/models/ProtectionModel_21Jan2015.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _string_utils = __webpack_require__(/*! ../../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _CommonEncryption = __webpack_require__(/*! ../vo/CommonEncryption */ "./src/protection/vo/CommonEncryption.js");

var _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);

var _MediaCapability = __webpack_require__(/*! ../vo/MediaCapability */ "./src/protection/vo/MediaCapability.js");

var _MediaCapability2 = _interopRequireDefault(_MediaCapability);

var _KeySystemConfiguration = __webpack_require__(/*! ../vo/KeySystemConfiguration */ "./src/protection/vo/KeySystemConfiguration.js");

var _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);

var _KeySystemWidevine = __webpack_require__(/*! ../drm/KeySystemWidevine */ "./src/protection/drm/KeySystemWidevine.js");

var _KeySystemWidevine2 = _interopRequireDefault(_KeySystemWidevine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This takes the place of a license server.
// kids is an array of base64-encoded key IDs
// keys is an array of base64-encoded keys
function generateLicense(message, key) {
  // Parse the clearkey license request.
  var request = JSON.parse(new TextDecoder().decode(message));
  // We only know one key, so there should only be one key ID.
  // A real license server could easily serve multiple keys.
  console.assert(request.kids.length === 1);

  var keyObj = {
    kty: 'oct',
    //alg: 'A128KW',
    kid: request.kids[0],
    k: _string_utils2.default.u8arrToB64(key)
  };
  return new TextEncoder().encode(JSON.stringify({
    keys: [keyObj]
  }));
}

function dumpKSConfig(ksString, ksConfig) {
  console.log('H5Player, requestMediaKeySystemAccess, keySystem_ = ' + ksString);
  console.log('H5Player, requestMediaKeySystemAccess, config, initDataTypes: ' + ksConfig.initDataTypes[0]);
  console.log('H5Player, requestMediaKeySystemAccess, config, distinctiveIdentifier: ' + ksConfig.distinctiveIdentifier);
  console.log('H5Player, requestMediaKeySystemAccess, config, persistentState: ' + ksConfig.persistentState);
  console.log('H5Player, requestMediaKeySystemAccess, config, sessionTypes: ' + ksConfig.sessionTypes[0]);
  console.log('H5Player, requestMediaKeySystemAccess, config, videoCapabilities[0].contentType: ' + ksConfig.videoCapabilities[0].contentType);
  console.log('H5Player, requestMediaKeySystemAccess, config, videoCapabilities[0].robustness: ' + ksConfig.videoCapabilities[0].robustness);

  // liteH5Player.debug.js:3558 H5Player, requestMediaKeySystemAccess, keySystem_ = com.chromecast.playready
  // liteH5Player.debug.js:3559 H5Player, requestMediaKeySystemAccess, config, initDataTypes: cenc
  // liteH5Player.debug.js:3560 H5Player, requestMediaKeySystemAccess, config, distinctiveIdentifier: optional
  // liteH5Player.debug.js:3561 H5Player, requestMediaKeySystemAccess, config, persistentState: optional
  // liteH5Player.debug.js:3562 H5Player, requestMediaKeySystemAccess, config, sessionTypes: temporary
  // liteH5Player.debug.js:3563 H5Player, requestMediaKeySystemAccess, config, videoCapabilities[0].contentType: video/mp4; codecs="avc1.42C014"
  // liteH5Player.debug.js:3564 H5Player, requestMediaKeySystemAccess, config, videoCapabilities[0].robustness: 

  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, keySystem: com.chromecast.playready
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, videoCapabilities = [object Object]
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, distinctiveIdentifier = optional
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, persistentState = optional
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, sessionTypes = temporary
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, label = com.chromecast.playready
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, drmInfos = [object Object]
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, videoCapabilities[0].contentType video/mp4; codecs="avc1.42C014"
  // shaka-player.compiled.debug.js:100 DRM: queryMediaKeys_, videoCapabilities[0].robustness 

  // for (var i in ksConfig) {
  //     console.log('H5Player, ' + i + ' = ' + ksConfig[i]);
  // }
}

/**
 * Most recent EME implementation
 *
 * Implemented by Google Chrome v36+ (Windows, OSX, Linux), Edge
 */
function ProtectionModel_21Jan2015() {
  var media_ = null;

  var initDataType_ = null;
  var initData_ = null;
  var keySystem_ = null;
  var session_ = null;
  var streamInfo_ = null;

  var promiseAction_ = null;

  function attachMedia(media) {
    media_ = media;
    media_.addEventListener('encrypted', onNeedKey, false);
  }

  function detachMedia() {
    if (media_) {
      media_.removeEventListener('encrypted', onNeedKey, false);
      media_ = null;
    }
  }

  function setKeySystem(keySystem) {
    keySystem_ = keySystem;
  }

  // ev.initData: it is pssh data hidden in mp4 pssh box
  function onNeedKey(ev) {
    console.log('onNeedKey, initDataType: ' + ev.initDataType);
    console.log('onNeedKey, initData length: ' + ev.initData.byteLength);
    console.log('onNeedKey, initData', _string_utils2.default.ab2str_v1(ev.initData));

    // 
    if (streamInfo_.drm.initDataType && streamInfo_.drm.initData) {
      initDataType_ = streamInfo_.drm.initDataType;
      initData_ = streamInfo_.drm.initData;
    } else {
      initDataType_ = ev.initDataType;
      initData_ = ev.initData;
    }

    // BD
    var pssh = _CommonEncryption2.default.parsePSSHList(ev.initData);
    var a1 = _string_utils2.default.ab2str_v1(pssh['edef8ba9-79d6-4ace-a3c8-27dcd51d21ed']);
    var a2 = _string_utils2.default.ab2str_v1(pssh['9a04f079-9840-4286-ab92-e65be0885f95']);
    console.log('DRM, a1: ' + a1);
    console.log('DRM, a2: ' + a2);
    // ED

    if (!promiseAction_) {
      promiseAction_ = requestKeySystemAccess();
    }
  }

  function onSessionMessage(ev) {
    console.log('message event: ', ev);
    // If you had a license server, you would make an asynchronous XMLHttpRequest
    // with event.message as the body.  The response from the server, as a
    // Uint8Array, would then be passed to session.update().
    // Instead, we will generate the license synchronously on the client, using
    // the hard-coded KEY at the top.

    console.log('session message, length: ' + ev.message.byteLength);
    console.log('session message, data:', _string_utils2.default.ab2str_v1(ev.message));

    // Determine license server URL
    var laUrl = streamInfo_.drm.laUrl;

    if (!laUrl) {
      console.log('DRM: no license url');

      if (streamInfo_.drm.type === 'org.w3.clearkey') {
        var license = generateLicense(event.message, streamInfo_.drm.key);
        console.log('license: ', license);
        var session = ev.target;
        session.update(license);
      }

      return;
    }
    //
    // All remaining key system scenarios require a request to a remote license server
    var xhr = new XMLHttpRequest();

    xhr.open('POST', laUrl, true);
    xhr.responseType = 'arraybuffer';
    xhr.timeout = 0;
    xhr.withCredentials = false;

    console.log('DRM: open method: POST');
    console.log('DRM: timeout: ' + xhr.timeout);
    console.log('DRM: withCredentials: ' + xhr.withCredentials);
    console.log('DRM: message: ' + _string_utils2.default.ab2str_v1(ev.message));
    xhr.onload = function (event) {
      if (this.status == 200) {
        var data = this.response;

        console.log('DRM: request response length: ' + data.byteLength);
        session_.update(new Uint8Array(this.response));
      }
    };
    xhr.onabort = function () {
      console.log('license request abort');
    };
    xhr.onerror = function () {
      console.log('license request error');
    };

    // BD
    var updateHeaders = function updateHeaders(headers) {
      var key;
      if (headers) {
        for (key in headers) {
          console.log('DRM: key: ' + key + ', value: ' + headers[key]);
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    };

    updateHeaders(streamInfo_.drm.headers);
    // ED

    //xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');
    //xhr.setRequestHeader('SOAPAction', '\"http://schemas.microsoft.com/DRM/2007/03/protocols/AcquireLicense\"');
    var body = keySystem_.getLicenseRequestFromMessage(ev.message);
    console.log('body: ', body);
    xhr.send(body);
  }

  function onSessionChange(ev) {
    var a = 2;
    var b = a;
  }

  function setDrmInfo(streamInfo) {
    console.log('--setDrmInfo in 21Jan2015--');
    streamInfo_ = streamInfo;
  }

  function requestKeySystemAccess() {
    var audioCapabilities = [];
    var videoCapabilities = [];
    var robustnessLevel = ''; // SW_SECURE_CRYPTO
    if (streamInfo_.drm.audioCodec) {
      audioCapabilities.push(new _MediaCapability2.default(streamInfo_.drm.audioCodec, robustnessLevel));
    }
    if (streamInfo_.drm.videoCodec) {
      videoCapabilities.push(new _MediaCapability2.default(streamInfo_.drm.videoCodec, robustnessLevel));
    }

    var ksConfig = new _KeySystemConfiguration2.default(audioCapabilities, videoCapabilities, 'optional', 'optional', ['temporary']);

    var configs_ = [];
    configs_.push(ksConfig);

    // BD
    //dumpKSConfig(keySystem_.systemString, ksConfig);
    // ED

    return navigator.requestMediaKeySystemAccess(keySystem_.systemString, configs_).then(function (keySystemAccess) {
      console.log('H5Player, requestMediaKeySystemAccess is ok');
      return keySystemAccess.createMediaKeys();
    }).then(function (mediaKeys) {
      console.log('H5Player, createMediaKeys is ok, mediaKeys: ' + mediaKeys);
      var ret = media_.setMediaKeys(mediaKeys);
      return ret;
    }).then(function () {
      // create session
      var mediaKeys = media_.mediaKeys;
      session_ = mediaKeys.createSession('temporary');
      session_.addEventListener('message', onSessionMessage, false);
      session_.addEventListener('keystatuseschange', onSessionChange, false);
      session_.generateRequest(initDataType_, initData_).then(function () {
        console.log('generateRequest is ok');
      }).catch(function (error) {
        console.error('generateRequest failed at: ', error);
      });
    }).catch(function (error) {
      console.error('Failed to set up MediaKeys', error);
    });
  }

  var instance_ = {
    attachMedia: attachMedia,
    detachMedia: detachMedia,
    setKeySystem: setKeySystem,
    setDrmInfo: setDrmInfo
  };
  return instance_;
}

exports.default = ProtectionModel_21Jan2015;

/***/ }),

/***/ "./src/protection/models/ProtectionModel_3Feb2014.js":
/*!***********************************************************!*\
  !*** ./src/protection/models/ProtectionModel_3Feb2014.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _string_utils = __webpack_require__(/*! ../../utils/string_utils */ "./src/utils/string_utils.js");

var _string_utils2 = _interopRequireDefault(_string_utils);

var _MediaCapability = __webpack_require__(/*! ../vo/MediaCapability */ "./src/protection/vo/MediaCapability.js");

var _MediaCapability2 = _interopRequireDefault(_MediaCapability);

var _KeySystemConfiguration = __webpack_require__(/*! ../vo/KeySystemConfiguration */ "./src/protection/vo/KeySystemConfiguration.js");

var _KeySystemConfiguration2 = _interopRequireDefault(_KeySystemConfiguration);

var _KSUtils = __webpack_require__(/*! ../vo/KSUtils */ "./src/protection/vo/KSUtils.js");

var _KSUtils2 = _interopRequireDefault(_KSUtils);

var _CommonEncryption = __webpack_require__(/*! ../vo/CommonEncryption */ "./src/protection/vo/CommonEncryption.js");

var _CommonEncryption2 = _interopRequireDefault(_CommonEncryption);

var _base = __webpack_require__(/*! ../../externals/base64 */ "./src/externals/base64.js");

var _base2 = _interopRequireDefault(_base);

var _KeySystemPlayReady = __webpack_require__(/*! ../drm/KeySystemPlayReady */ "./src/protection/drm/KeySystemPlayReady.js");

var _KeySystemPlayReady2 = _interopRequireDefault(_KeySystemPlayReady);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Most recent EME implementation
 *
 * Implemented by IE11
 */
function ProtectionModel_3Feb2014(media) {
  var context_ = this.context;
  var media_ = null;
  var streamInfo_ = null;
  var session_ = null;
  var keySystem_ = null;
  var mediaKeys_ = null;

  function attachMedia(media) {
    media_ = media;

    media_.addEventListener('msneedkey', onNeedKey);
  }

  function detachMedia() {
    if (media_) {
      media_.addEventListener('msneedkey', onNeedKey);
    }
  }

  function setKeySystem(keySystem) {
    keySystem_ = keySystem;
  }

  function setDrmInfo(streamInfo) {
    streamInfo_ = streamInfo;
  }

  function onNeedKey(ev) {
    var initDataType = 'cenc';
    // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).
    // Convert to ArrayBuffer
    var abInitData = ev.initData;
    if (ArrayBuffer.isView(abInitData)) {
      abInitData = abInitData.buffer;
    }

    var pssh = _CommonEncryption2.default.parsePSSHList(abInitData);
    var uuid = _KSUtils2.default.GetKSUUID(streamInfo_.drm.type);

    var actualInitData = pssh[uuid];

    // select key system
    if (media_.readyState >= 1) {
      mediaKeys_ = new window.MSMediaKeys(keySystem_.systemString);
      media_.msSetMediaKeys(mediaKeys_);

      session_ = mediaKeys_.createSession(streamInfo.drm.videoCodec, new Uint8Array(abInitData));
      session_.addEventListener('mskeyerror', onSessionError);
      session_.addEventListener('mskeymessage', onSessionMessage);
      session_.addEventListener('mskeyadded', onSessionAdded);
      session_.addEventListener('mskeyclose', onSessionClose);
    }
  }

  function onSessionError(ev) {}

  function onSessionMessage(ev) {
    console.log('DRM: Key Message');

    var abMessage = ev.message;
    if (ArrayBuffer.isView(abMessage)) {
      abMessage = abMessage.buffer;
    }

    // license request here
    var xhr = new XMLHttpRequest();
    xhr.open('POST', streamInfo_.drm.laUrl, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function () {
      if (this.status === 200) {
        session_.update(new Uint8Array(this.response));
      }
    };
    xhr.onabort = function () {
      console.log('DRM: xhr abort');
    };
    xhr.onerror = function () {
      console.log('DRM: xhr error');
    };

    // 
    var headers = keySystem_.getRequestHeadersFromMessage(abMessage);
    for (var key in headers) {
      if ('authorization' === key.toLowerCase()) {
        xhr.withCredentials = true;
      }
      xhr.setRequestHeader(key, headers[key]);
    }

    xhr.send(keySystem_.getLicenseRequestFromMessage(abMessage));
  }

  function onSessionAdded(ev) {
    console.log('DRM: Key added');
  }

  function onSessionClose(ev) {}

  function requestKeySystemAccess() {
    var ksString = _KSUtils2.default.GetKSString(streamInfo_.drm.type);

    var audioCapabilities = [];
    var videoCapabilities = [];
    var robustnessLevel = '';
    if (streamInfo_.drm.audioCodec) {
      audioCapabilities.push(new _MediaCapability2.default(streamInfo_.drm.audioCodec, robustnessLevel));
    }
    if (streamInfo_.drm.videoCodec) {
      videoCapabilities.push(new _MediaCapability2.default(streamInfo_.drm.videoCodec, robustnessLevel));
    }

    var ksConfig = new _KeySystemConfiguration2.default(audioCapabilities, videoCapabilities, 'optional', 'optional', ['temporary']);

    var configs_ = [];
    configs_.push(ksConfig);

    // check is supported?
    for (var configIdx = 0; configIdx < configs_.length; configIdx++) {
      var videos = configs_[configIdx].videoCapabilities;

      // Look for supported video container/codecs
      if (videos && videos.length !== 0) {
        for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {
          if (window['MSMediaKeys'].isTypeSupported(ksString, videos[videoIdx].contentType)) {}
        }
      }
    }

    // 
    selectKeySystem(ksString);
  }

  function selectKeySystem(ksString) {
    var mediaKeys = new window['MSMediaKeys'](ksString);

    if (media_.readyState >= 1) {
      media_.msSetMediaKeys(mediaKeys);
    }
  }

  function createKeySession(initData) {}

  var instance_ = {
    attachMedia: attachMedia,
    detachMedia: detachMedia,
    setKeySystem: setKeySystem,
    setDrmInfo: setDrmInfo
  };
  return instance_;
}

exports.default = ProtectionModel_3Feb2014;

/***/ }),

/***/ "./src/protection/vo/CommonEncryption.js":
/*!***********************************************!*\
  !*** ./src/protection/vo/CommonEncryption.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _base = __webpack_require__(/*! ../../externals/base64 */ "./src/externals/base64.js");

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * The copyright in this software is being made available under the BSD License,
                                                                                                                                                           * included below. This software may be subject to other third party and contributor
                                                                                                                                                           * rights, including patent rights, and no such rights are granted under this license.
                                                                                                                                                           *
                                                                                                                                                           * Copyright (c) 2013, Dash Industry Forum.
                                                                                                                                                           * All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           * Redistribution and use in source and binary forms, with or without modification,
                                                                                                                                                           * are permitted provided that the following conditions are met:
                                                                                                                                                           *  * Redistributions of source code must retain the above copyright notice, this
                                                                                                                                                           *  list of conditions and the following disclaimer.
                                                                                                                                                           *  * Redistributions in binary form must reproduce the above copyright notice,
                                                                                                                                                           *  this list of conditions and the following disclaimer in the documentation and/or
                                                                                                                                                           *  other materials provided with the distribution.
                                                                                                                                                           *  * Neither the name of Dash Industry Forum nor the names of its
                                                                                                                                                           *  contributors may be used to endorse or promote products derived from this software
                                                                                                                                                           *  without specific prior written permission.
                                                                                                                                                           *
                                                                                                                                                           *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
                                                                                                                                                           *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                                                                                                                                                           *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
                                                                                                                                                           *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
                                                                                                                                                           *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
                                                                                                                                                           *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                                                                                                                                                           *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                                                                                                                           *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                                                                                                                                                           *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                                                                                                                                                           *  POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                           */

var CommonEncryption = function () {
  function CommonEncryption() {
    _classCallCheck(this, CommonEncryption);
  }

  /**
   * Find and return the ContentProtection element in the given array
   * that indicates support for MPEG Common Encryption
   *
   * @param {Array} cpArray array of content protection elements
   * @returns {Object|null} the Common Encryption content protection element or
   * null if one was not found
   */
  CommonEncryption.findCencContentProtection = function findCencContentProtection(cpArray) {
    var retVal = null;
    for (var i = 0; i < cpArray.length; ++i) {
      var cp = cpArray[i];
      if (cp.schemeIdUri.toLowerCase() === 'urn:mpeg:dash:mp4protection:2011' && cp.value.toLowerCase() === 'cenc') retVal = cp;
    }
    return retVal;
  };

  /**
   * Returns just the data portion of a single PSSH
   *
   * @param {ArrayBuffer} pssh - the PSSH
   * @return {ArrayBuffer} data portion of the PSSH
   */


  CommonEncryption.getPSSHData = function getPSSHData(pssh) {
    var offset = 8; // Box size and type fields
    var view = new DataView(pssh);

    // Read version
    var version = view.getUint8(offset);

    offset += 20; // Version (1), flags (3), system ID (16)

    if (version > 0) {
      offset += 4 + 16 * view.getUint32(offset); // Key ID count (4) and All key IDs (16*count)
    }

    offset += 4; // Data size
    return pssh.slice(offset);
  };

  /**
   * Returns the PSSH associated with the given key system from the concatenated
   * list of PSSH boxes in the given initData
   *
   * @param {KeySystem} keySystem the desired
   * key system
   * @param {ArrayBuffer} initData 'cenc' initialization data.  Concatenated list of PSSH.
   * @returns {ArrayBuffer|null} The PSSH box data corresponding to the given key system, null if not found
   * or null if a valid association could not be found.
   */


  CommonEncryption.getPSSHForKeySystem = function getPSSHForKeySystem(keySystem, initData) {
    var psshList = CommonEncryption.parsePSSHList(initData);
    if (psshList.hasOwnProperty(keySystem.uuid.toLowerCase())) {
      return psshList[keySystem.uuid.toLowerCase()];
    }
    return null;
  };

  /**
   * Parse a standard common encryption PSSH which contains a simple
   * base64-encoding of the init data
   *
   * @param {Object} cpData the ContentProtection element
   * @returns {ArrayBuffer|null} the init data or null if not found
   */


  CommonEncryption.parseInitDataFromContentProtection = function parseInitDataFromContentProtection(cpData) {
    if ('pssh' in cpData) {
      return _base2.default.decodeArray(cpData.pssh.__text).buffer;
    }
    return null;
  };

  /**
   * Parses list of PSSH boxes into keysystem-specific PSSH data
   *
   * @param {ArrayBuffer} data - the concatenated list of PSSH boxes as provided by
   * CDM as initialization data when CommonEncryption content is detected
   * @returns {Object|Array} an object that has a property named according to each of
   * the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000)
   * and a ArrayBuffer (the entire PSSH box) as the property value
   */
  // you can refer https://www.w3.org/TR/eme-initdata-cenc/ for more detail.


  CommonEncryption.parsePSSHList = function parsePSSHList(data) {

    if (data === null) return [];

    var dv = new DataView(data);
    var done = false;
    var pssh = {};

    // TODO: Need to check every data read for end of buffer
    var byteCursor = 0;
    while (!done) {

      var size, nextBox, version, systemID, psshDataSize;
      var boxStart = byteCursor;

      if (byteCursor >= dv.buffer.byteLength) break;

      /* Box size */
      size = dv.getUint32(byteCursor);
      nextBox = byteCursor + size;
      byteCursor += 4;

      /* Verify PSSH */
      if (dv.getUint32(byteCursor) !== 0x70737368) {
        byteCursor = nextBox;
        continue;
      }
      byteCursor += 4;

      /* Version must be 0 or 1 */
      version = dv.getUint8(byteCursor);
      if (version !== 0 && version !== 1) {
        byteCursor = nextBox;
        continue;
      }
      byteCursor++;

      byteCursor += 3; /* skip flags */

      // 16-byte UUID/SystemID
      systemID = '';
      var i, val;
      for (i = 0; i < 4; i++) {
        val = dv.getUint8(byteCursor + i).toString(16);
        systemID += val.length === 1 ? '0' + val : val;
      }
      byteCursor += 4;
      systemID += '-';
      for (i = 0; i < 2; i++) {
        val = dv.getUint8(byteCursor + i).toString(16);
        systemID += val.length === 1 ? '0' + val : val;
      }
      byteCursor += 2;
      systemID += '-';
      for (i = 0; i < 2; i++) {
        val = dv.getUint8(byteCursor + i).toString(16);
        systemID += val.length === 1 ? '0' + val : val;
      }
      byteCursor += 2;
      systemID += '-';
      for (i = 0; i < 2; i++) {
        val = dv.getUint8(byteCursor + i).toString(16);
        systemID += val.length === 1 ? '0' + val : val;
      }
      byteCursor += 2;
      systemID += '-';
      for (i = 0; i < 6; i++) {
        val = dv.getUint8(byteCursor + i).toString(16);
        systemID += val.length === 1 ? '0' + val : val;
      }
      byteCursor += 6;

      systemID = systemID.toLowerCase();

      /* PSSH Data Size */
      psshDataSize = dv.getUint32(byteCursor);
      byteCursor += 4;

      /* PSSH Data */
      pssh[systemID] = dv.buffer.slice(boxStart, nextBox);
      byteCursor = nextBox;
    }

    return pssh;
  };

  return CommonEncryption;
}();

exports.default = CommonEncryption;

/***/ }),

/***/ "./src/protection/vo/KSUtils.js":
/*!**************************************!*\
  !*** ./src/protection/vo/KSUtils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KSUtils = {
  GetKSString: function GetKSString(drmType) {
    if (drmType === 'widevine') {
      return 'com.widevine.alpha';
    } else if (drmType === 'playready') {
      return 'com.microsoft.playready';
    } else if (drmType === 'chromecast.playready') {
      return 'com.chromecast.playready';
    }
  },

  GetKSUUID: function GetKSUUID(drmType) {
    if (drmType === 'widevine') {
      return 'edef8ba9-79d6-4ace-a3c8-27dcd51d21ed';
    } else if (drmType === 'playready') {
      return '9a04f079-9840-4286-ab92-e65be0885f95';
    } else if (drmType === 'chromecast.playready') {
      return '9a04f079-9840-4286-ab92-e65be0885f95';
    }
  }
};

module.exports = KSUtils;

/***/ }),

/***/ "./src/protection/vo/KeySystemConfiguration.js":
/*!*****************************************************!*\
  !*** ./src/protection/vo/KeySystemConfiguration.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @classdesc Represents a set of configurations that describe the capabilities desired for
 *  support by a given CDM
 * @ignore
 */
var KeySystemConfiguration =
/**
 * @param {Array.<MediaCapability>} audioCapabilities array of
 * desired audio capabilities.  Higher preference capabilities should be placed earlier
 * in the array.
 * @param {Array.<MediaCapability>} videoCapabilities array of
 * desired video capabilities.  Higher preference capabilities should be placed earlier
 * in the array.
 * @param {string} distinctiveIdentifier desired use of distinctive identifiers.
 * One of "required", "optional", or "not-allowed"
 * @param {string} persistentState desired support for persistent storage of
 * key systems.  One of "required", "optional", or "not-allowed"
 * @param {Array.<string>} sessionTypes List of session types that must
 * be supported by the key system
 * @class
 */
function KeySystemConfiguration(audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, sessionTypes) {
  _classCallCheck(this, KeySystemConfiguration);

  // new
  //this.initDataTypes = [ 'keyids' ];
  this.initDataTypes = ['cenc'];

  if (audioCapabilities && audioCapabilities.length) {
    this.audioCapabilities = audioCapabilities;
  }
  if (videoCapabilities && videoCapabilities.length) {
    this.videoCapabilities = videoCapabilities;
  }
  this.distinctiveIdentifier = distinctiveIdentifier;
  this.persistentState = persistentState;
  this.sessionTypes = sessionTypes;
};

exports.default = KeySystemConfiguration;

/***/ }),

/***/ "./src/protection/vo/MediaCapability.js":
/*!**********************************************!*\
  !*** ./src/protection/vo/MediaCapability.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * @classdesc A media capability
 * @ignore
 */
var MediaCapability =
/**
 * @param {string} contentType MIME type and codecs (RFC6386)
 * @param {string} robustness
 * @class
 * @ignore
 */
function MediaCapability(contentType, robustness) {
  _classCallCheck(this, MediaCapability);

  this.contentType = contentType;
  this.robustness = robustness;
};

exports.default = MediaCapability;

/***/ }),

/***/ "./src/ui/assets/img/logo.png":
/*!************************************!*\
  !*** ./src/ui/assets/img/logo.png ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "./assets/img/logo.png";

/***/ }),

/***/ "./src/ui/css/ui_skin_youtube.scss":
/*!*****************************************!*\
  !*** ./src/ui/css/ui_skin_youtube.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/ui/js/components/ui_ads_container.js":
/*!**************************************************!*\
  !*** ./src/ui/js/components/ui_ads_container.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

var _consts = __webpack_require__(/*! ../consts */ "./src/ui/js/consts.js");

var _consts2 = _interopRequireDefault(_consts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UIAdsContainer = function () {
  function UIAdsContainer(props) {
    _classCallCheck(this, UIAdsContainer);

    this.props = props;
    this.main = this.props.main;
    this.player = this.main.player;

    this.vopAdContainer = document.querySelector('.vop-ads-container');
    this.onAdContainerMouseDown = this.onAdContainerMouseDown.bind(this);
    this.vopAdContainer.addEventListener('mousedown', this.onAdContainerMouseDown);

    //
    this.onAdStarted = this.onAdStarted.bind(this);
    this.onAdComplete = this.onAdComplete.bind(this);
    this.player.on(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.on(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  }

  UIAdsContainer.prototype.onAdStarted = function onAdStarted(e) {
    // BD
    var videos = document.getElementsByTagName('video');
    myPrintLog('onAdStarted, linear: ' + e.linear + ', videos length: ' + videos.length);
    // ED

    if (!this.vopPlayer) {
      this.vopPlayer = document.querySelector('.html5-video-player');
    }

    this.flagAdStarted = true;
    this.flagIsLinearAd = e.linear;
    this.flagIsVpaidAd = e.vpaid;

    // update control bar ui
    if (this.flagIsVpaidAd) {
      this.vopAdContainer.style.zIndex = '3';
    } else {
      if (this.flagIsLinearAd) {
        this.vopAdContainer.style.zIndex = '1';
      } else {
        var adDstWidth = this.vopPlayer.clientWidth;
        var adDstHeight = e.height + 10;
        this.player.resize(adDstWidth, e.height + 5);
        this.vopAdContainer.style.bottom = _consts2.default.BOTTOM_BAR_HEIGHT.toString() + 'px';
        //this.vopAdContainer.style.width = adDstWidth.toString() + 'px';
        this.vopAdContainer.style.height = adDstHeight.toString() + 'px';
        this.vopAdContainer.style.zIndex = '1';

        // Consider ad height.
        //this.updateCaptionOverlay();
      }
    }
  };

  UIAdsContainer.prototype.onAdComplete = function onAdComplete(e) {
    myPrintLog('onAdComplete, linear: ' + this.flagIsLinearAd);
    this.flagAdStarted = false;

    if (this.flagIsVpaidAd) {
      this.vopAdContainer.style.zIndex = 'auto';
    } else {
      if (this.flagIsLinearAd) {
        this.vopAdContainer.style.zIndex = 'auto';
      } else {
        this.vopAdContainer.style.zIndex = 'auto';
      }
    }
  };

  UIAdsContainer.prototype.onAdContainerMouseDown = function onAdContainerMouseDown(e) {
    // If ad is playing, it will overlay on the top of 'html5-video-player',
    // when click on ad, we should stop this event transfer to its parent.
    if (this.flagAdStarted) {
      e.stopPropagation();
    }
  };

  return UIAdsContainer;
}();

exports.default = UIAdsContainer;

/***/ }),

/***/ "./src/ui/js/components/ui_airplay_toggle_button.js":
/*!**********************************************************!*\
  !*** ./src/ui/js/components/ui_airplay_toggle_button.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIAirplayToggleButton = function (_Component) {
  _inherits(UIAirplayToggleButton, _Component);

  function UIAirplayToggleButton(props) {
    _classCallCheck(this, UIAirplayToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UIAirplayToggleButton.prototype.componentDidMount = function componentDidMount() {
    this.vopAirplayButton = document.querySelector('.vop-airplay-button');

    this.onAdStarted = this.onAdStarted.bind(this);
    this.onAdComplete = this.onAdComplete.bind(this);
    this.player.on(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.on(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  };

  UIAirplayToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.off(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  };

  UIAirplayToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { className: 'vop-button vop-airplay-button', title: 'airplay',
      onClick: this.onUICmdAirplay.bind(this) });
  };

  UIAirplayToggleButton.prototype.onUICmdAirplay = function onUICmdAirplay() {
    this.player.showPlaybackTargetPicker();
  };

  UIAirplayToggleButton.prototype.onAdStarted = function onAdStarted(e) {
    this.flagAdStarted = true;
    this.flagIsLinearAd = e.linear;
    this.flagIsVpaidAd = e.vpaid;

    if (this.flagAdStarted && this.flagIsLinearAd) {
      this.vopAirplayButton.style.display = 'none';
    } else {
      this.vopAirplayButton.style.display = 'inline-block';
    }
  };

  UIAirplayToggleButton.prototype.onAdComplete = function onAdComplete() {
    this.vopAirplayButton.style.display = 'inline-block';
  };

  return UIAirplayToggleButton;
}(_preact.Component);

exports.default = UIAirplayToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_audio_track_menu.js":
/*!*****************************************************!*\
  !*** ./src/ui/js/components/ui_audio_track_menu.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIAudioTrackMenu = function (_Component) {
  _inherits(UIAudioTrackMenu, _Component);

  function UIAudioTrackMenu(props) {
    _classCallCheck(this, UIAudioTrackMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuBackClick_ = _this.onMenuBackClick.bind(_this);
    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    _this.audioTrackData = {
      audioTrackList: [{
        id: '1',
        lang: 'English'
      }, {
        id: '2',
        lang: 'French'
      }, {
        id: '3',
        lang: 'Chinese'
      }, {
        id: '4',
        lang: 'Dutch'
      }, {
        id: '5',
        lang: 'Spanish'
      }, {
        id: '6',
        lang: 'Korean'
      }],
      currAudioTrackId: '1'
    };
    _this.state = {
      audioTrackData: _this.audioTrackData
    };
    return _this;
  }

  UIAudioTrackMenu.prototype.componentDidMount = function componentDidMount() {
    this.vopAudioTrackMenu = document.querySelector('.vop-audio-track-menu');
  };

  UIAudioTrackMenu.prototype.render = function render() {
    var _this2 = this;

    console.log('UIAudioTrackMenu, render');

    var audioTrackData = this.state.audioTrackData;


    var menuitems = audioTrackData.audioTrackList.map(function (item, index) {
      return (0, _preact.h)(
        'div',
        { key: index, className: 'vop-menuitem', role: 'menuitemradio',
          'aria-checked': audioTrackData.currAudioTrackId === item.id,
          'data-id': item.id, onClick: _this2.onMenuItemClick_,
          tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-label' },
          (0, _preact.h)(
            'span',
            null,
            item.lang
          )
        )
      );
    });

    return (0, _preact.h)(
      'div',
      { className: 'vop-audio-track-menu', style: 'display: none;' },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-header' },
        (0, _preact.h)(
          'button',
          { className: 'vop-panel-title', onClick: this.onMenuBackClick_ },
          'AudioTrack'
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UIAudioTrackMenu.prototype.onMenuBackClick = function onMenuBackClick(e) {
    this.main.settingMenuUIData.currMenu = 'settings_menu';
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UIAudioTrackMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    var nextFocus = e.currentTarget;
    this.audioTrackData.currAudioTrackId = nextFocus.dataset.id;
    this.setState({
      audioTrackData: this.audioTrackData
    });
  };

  UIAudioTrackMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'fcc_menu') {
      return;
    }
    this.main.onAudioTrackMenuItemBlur(e);
  };

  UIAudioTrackMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'audio_track_menu') {
      this.vopAudioTrackMenu.style.display = 'block';
      var v = this.vopAudioTrackMenu.querySelector('.vop-menuitem');
      if (v) {
        v.focus();
      }
    } else {
      this.vopAudioTrackMenu.style.display = 'none';
    }
  };

  return UIAudioTrackMenu;
}(_preact.Component);

exports.default = UIAudioTrackMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_bottom_bar.js":
/*!***********************************************!*\
  !*** ./src/ui/js/components/ui_bottom_bar.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_progress_bar = __webpack_require__(/*! ./ui_progress_bar */ "./src/ui/js/components/ui_progress_bar.js");

var _ui_progress_bar2 = _interopRequireDefault(_ui_progress_bar);

var _ui_control_bar = __webpack_require__(/*! ./ui_control_bar */ "./src/ui/js/components/ui_control_bar.js");

var _ui_control_bar2 = _interopRequireDefault(_ui_control_bar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIBottomBar = function (_Component) {
  _inherits(UIBottomBar, _Component);

  function UIBottomBar(props) {
    _classCallCheck(this, UIBottomBar);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UIBottomBar.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-bottom-bar',
        onMouseDown: this.onUICmdControlBarMouseDown.bind(this) },
      (0, _preact.h)(_ui_progress_bar2.default, { main: this.main }),
      (0, _preact.h)(_ui_control_bar2.default, { main: this.main })
    );
  };

  UIBottomBar.prototype.onUICmdControlBarMouseDown = function onUICmdControlBarMouseDown(e) {
    e.stopPropagation();
  };

  return UIBottomBar;
}(_preact.Component);

exports.default = UIBottomBar;

/***/ }),

/***/ "./src/ui/js/components/ui_buffering_overlay.js":
/*!******************************************************!*\
  !*** ./src/ui/js/components/ui_buffering_overlay.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIBufferingOverlay = function (_Component) {
  _inherits(UIBufferingOverlay, _Component);

  function UIBufferingOverlay(props) {
    _classCallCheck(this, UIBufferingOverlay);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;

    _this.onMediaPlaying = _this.onMediaPlaying.bind(_this);
    _this.onMediaWaiting = _this.onMediaWaiting.bind(_this);

    _this.player.on(oldmtn.Events.MEDIA_WAITING, _this.onMediaWaiting);
    _this.player.on(oldmtn.Events.MEDIA_PLAYING, _this.onMediaPlaying);
    return _this;
  }

  UIBufferingOverlay.prototype.componentDidMount = function componentDidMount() {};

  UIBufferingOverlay.prototype.componentWillUnmount = function componentWillUnmount() {};

  UIBufferingOverlay.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-spinner' },
      (0, _preact.h)(
        'div',
        { className: 'vop-spinner-container' },
        (0, _preact.h)(
          'div',
          { className: 'vop-spinner-rotator' },
          (0, _preact.h)(
            'div',
            { className: 'vop-spinner-left' },
            (0, _preact.h)('div', { className: 'vop-spinner-circle' })
          ),
          (0, _preact.h)(
            'div',
            { className: 'vop-spinner-right' },
            (0, _preact.h)('div', { className: 'vop-spinner-circle' })
          )
        )
      )
    );
  };

  UIBufferingOverlay.prototype.onMediaWaiting = function onMediaWaiting() {
    if (!this.vopPlayer) {
      this.vopPlayer = document.querySelector('.html5-video-player');
    }
    _ui_tools2.default.addClass(this.vopPlayer, 'vop-buffering');
  };

  UIBufferingOverlay.prototype.onMediaPlaying = function onMediaPlaying() {
    if (!this.vopPlayer) {
      this.vopPlayer = document.querySelector('.html5-video-player');
    }
    _ui_tools2.default.removeClass(this.vopPlayer, 'vop-buffering');
  };

  return UIBufferingOverlay;
}(_preact.Component);

exports.default = UIBufferingOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_caption_overlay.js":
/*!****************************************************!*\
  !*** ./src/ui/js/components/ui_caption_overlay.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _consts = __webpack_require__(/*! ../consts */ "./src/ui/js/consts.js");

var _consts2 = _interopRequireDefault(_consts);

var _underscore = __webpack_require__(/*! ../../../externals/underscore */ "./src/externals/underscore.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UICaptionOverlay = function (_Component) {
  _inherits(UICaptionOverlay, _Component);

  function UICaptionOverlay(props) {
    _classCallCheck(this, UICaptionOverlay);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onTrackAdded = _this.onTrackAdded.bind(_this);
    _this.onTrackChanged = _this.onTrackChanged.bind(_this);
    _this.player.on(oldmtn.Events.TRACK_ADDED, _this.onTrackAdded);
    _this.player.on(oldmtn.Events.TRACK_CHANGED, _this.onTrackChanged);

    _this.onMediaTimeupdated = _this.onMediaTimeupdated.bind(_this);
    _this.player.on(oldmtn.Events.MEDIA_TIMEUPDATE, _this.onMediaTimeupdated);

    _this.onAutoHideChange = _this.onAutoHideChange.bind(_this);
    _this.evEmitter.on(_events2.default.AUTOHIDE_CHANGE, _this.onAutoHideChange);
    return _this;
  }

  UICaptionOverlay.prototype.componentDidMount = function componentDidMount() {
    this.vopCaptionOverlay = document.querySelector('.vop-caption-overlay');
  };

  UICaptionOverlay.prototype.render = function render() {
    var captionStyle = {};
    captionStyle.backgroundColor = 'yellow';
    captionStyle.color = 'red';

    // line-height: normal;
    // text-align: center;

    return (0, _preact.h)('div', { className: 'vop-caption-overlay', style: captionStyle });
  };

  UICaptionOverlay.prototype.onMediaTimeupdated = function onMediaTimeupdated(e) {
    var pos = this.player.getPosition();

    var cues = [];
    if (this.textTrack_) {
      cues = this.getCurrentCues(this.textTrack_.data, pos);
    }

    this.updateCurrentCues(cues);
    this.renderCues();
  };

  UICaptionOverlay.prototype.onAutoHideChange = function onAutoHideChange(e) {
    var height = _consts2.default.BOTTOM_BAR_HEIGHT;
    if (e.autohide) {
      this.vopCaptionOverlay.style.bottom = '0px';
    } else {
      this.vopCaptionOverlay.style.bottom = height.toString() + 'px';
    }
  };

  UICaptionOverlay.prototype.onTrackAdded = function onTrackAdded(e) {
    if (this.currTrackId_ !== e.currTrackId) {
      this.currTrackId_ = e.currTrackId;
      this.textTrack_ = e.track;
    }
  };

  UICaptionOverlay.prototype.onTrackChanged = function onTrackChanged(e) {
    if (this.currTrackId_ !== e.currTrackId) {
      this.currTrackId_ = e.currTrackId;
      this.textTrack_ = this.player.getCurrentSubtitleTrack();
    }
  };

  // Tools


  UICaptionOverlay.prototype.getCurrentCues = function getCurrentCues(allCues, pos) {
    return (0, _underscore.filter)(allCues, function (cue) {
      return pos >= cue.start && (!cue.end || pos <= cue.end);
    });
  };

  UICaptionOverlay.prototype.updateCurrentCues = function updateCurrentCues(cues) {
    // Render with vtt.js if there are cues, clear if there are none
    if (!cues.length) {
      this.currentCues_ = [];
    } else if ((0, _underscore.difference)(cues, this.currentCues_).length) {
      this.currentCues_ = cues;
    }
  };

  UICaptionOverlay.prototype.renderCues = function renderCues() {
    if (this.currentCues_.length > 0) {
      var cue = this.currentCues_[0];
      this.vopCaptionOverlay.innerText = cue.data;
    } else {
      this.vopCaptionOverlay.innerText = '';
    }
  };

  return UICaptionOverlay;
}(_preact.Component);

exports.default = UICaptionOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_chromecast_overlay.js":
/*!*******************************************************!*\
  !*** ./src/ui/js/components/ui_chromecast_overlay.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIChromecastOverlay = function (_Component) {
  _inherits(UIChromecastOverlay, _Component);

  function UIChromecastOverlay(props) {
    _classCallCheck(this, UIChromecastOverlay);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;

    _this.onCastConnected = _this.onCastConnected.bind(_this);
    _this.onCastDisconnected = _this.onCastDisconnected.bind(_this);
    _this.player.on(oldmtn.Events.CAST_CONNECTED, _this.onCastConnected);
    _this.player.on(oldmtn.Events.CAST_DISCONNECTED, _this.onCastDisconnected);
    return _this;
  }

  UIChromecastOverlay.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-chromecast-overlay' },
      (0, _preact.h)(
        'div',
        { className: 'vop-chromecast-status' },
        (0, _preact.h)('div', { className: 'vop-chromecast-status-icon' }),
        (0, _preact.h)(
          'div',
          { className: 'vop-chromecast-status-info' },
          'Playing on'
        ),
        (0, _preact.h)(
          'div',
          { className: 'vop-chromecast-status-title' },
          'Joseph TV(2nd Gen)'
        )
      )
    );
  };

  UIChromecastOverlay.prototype.onCastConnected = function onCastConnected() {
    if (!this.vopPlayer) {
      this.vopPlayer = document.querySelector('.html5-video-player');
    }

    UITools.addClass(this.vopPlayer, 'vop-chromecast-connected');
  };

  UIChromecastOverlay.prototype.onCastDisconnected = function onCastDisconnected() {
    if (!this.vopPlayer) {
      this.vopPlayer = document.querySelector('.html5-video-player');
    }

    UITools.removeClass(this.vopPlayer, 'vop-chromecast-connected');
  };

  return UIChromecastOverlay;
}(_preact.Component);

exports.default = UIChromecastOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_chromecast_toggle_button.js":
/*!*************************************************************!*\
  !*** ./src/ui/js/components/ui_chromecast_toggle_button.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIChromecastToggleButton = function (_Component) {
  _inherits(UIChromecastToggleButton, _Component);

  function UIChromecastToggleButton(props) {
    _classCallCheck(this, UIChromecastToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UIChromecastToggleButton.prototype.render = function render() {
    var btnStyle = {};
    if (this.main.flagAdStarted && this.main.flagIsLinearAd) {
      btnStyle.display = 'none';
    } else {
      btnStyle.display = 'inline-block';
    }

    return (0, _preact.h)('button', { className: 'vop-button vop-cast-button', title: 'chromecast',
      onClick: this.onUIComponentClick.bind(this),
      onMouseMove: this.onUIComponentMouseMove.bind(this),
      style: btnStyle });
  };

  UIChromecastToggleButton.prototype.onUIComponentClick = function onUIComponentClick() {
    this.player.castVideo();
  };

  UIChromecastToggleButton.prototype.onUIComponentMouseMove = function onUIComponentMouseMove(e) {
    this.main.onControlMouseMove(e);
  };

  return UIChromecastToggleButton;
}(_preact.Component);

exports.default = UIChromecastToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_control_bar.js":
/*!************************************************!*\
  !*** ./src/ui/js/components/ui_control_bar.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_play_toggle_button = __webpack_require__(/*! ./ui_play_toggle_button */ "./src/ui/js/components/ui_play_toggle_button.js");

var _ui_play_toggle_button2 = _interopRequireDefault(_ui_play_toggle_button);

var _ui_volume_toggle_button = __webpack_require__(/*! ./ui_volume_toggle_button */ "./src/ui/js/components/ui_volume_toggle_button.js");

var _ui_volume_toggle_button2 = _interopRequireDefault(_ui_volume_toggle_button);

var _ui_volume_bar = __webpack_require__(/*! ./ui_volume_bar */ "./src/ui/js/components/ui_volume_bar.js");

var _ui_volume_bar2 = _interopRequireDefault(_ui_volume_bar);

var _ui_time_label = __webpack_require__(/*! ./ui_time_label */ "./src/ui/js/components/ui_time_label.js");

var _ui_time_label2 = _interopRequireDefault(_ui_time_label);

var _ui_pip_toggle_button = __webpack_require__(/*! ./ui_pip_toggle_button */ "./src/ui/js/components/ui_pip_toggle_button.js");

var _ui_pip_toggle_button2 = _interopRequireDefault(_ui_pip_toggle_button);

var _ui_airplay_toggle_button = __webpack_require__(/*! ./ui_airplay_toggle_button */ "./src/ui/js/components/ui_airplay_toggle_button.js");

var _ui_airplay_toggle_button2 = _interopRequireDefault(_ui_airplay_toggle_button);

var _ui_chromecast_toggle_button = __webpack_require__(/*! ./ui_chromecast_toggle_button */ "./src/ui/js/components/ui_chromecast_toggle_button.js");

var _ui_chromecast_toggle_button2 = _interopRequireDefault(_ui_chromecast_toggle_button);

var _ui_subtitles_toggle_button = __webpack_require__(/*! ./ui_subtitles_toggle_button */ "./src/ui/js/components/ui_subtitles_toggle_button.js");

var _ui_subtitles_toggle_button2 = _interopRequireDefault(_ui_subtitles_toggle_button);

var _ui_settings_toggle_button = __webpack_require__(/*! ./ui_settings_toggle_button */ "./src/ui/js/components/ui_settings_toggle_button.js");

var _ui_settings_toggle_button2 = _interopRequireDefault(_ui_settings_toggle_button);

var _ui_fullscreen_toggle_button = __webpack_require__(/*! ./ui_fullscreen_toggle_button */ "./src/ui/js/components/ui_fullscreen_toggle_button.js");

var _ui_fullscreen_toggle_button2 = _interopRequireDefault(_ui_fullscreen_toggle_button);

var _ui_progress_bar = __webpack_require__(/*! ./ui_progress_bar */ "./src/ui/js/components/ui_progress_bar.js");

var _ui_progress_bar2 = _interopRequireDefault(_ui_progress_bar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIControlBar = function (_Component) {
  _inherits(UIControlBar, _Component);

  function UIControlBar(props) {
    _classCallCheck(this, UIControlBar);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UIControlBar.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-control-bar' },
      (0, _preact.h)(_ui_play_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_volume_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_volume_bar2.default, { main: this.main }),
      (0, _preact.h)(_ui_time_label2.default, { main: this.main }),
      (0, _preact.h)('div', { className: 'vop-spacer' }),
      (0, _preact.h)(_ui_pip_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_airplay_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_chromecast_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_subtitles_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_settings_toggle_button2.default, { main: this.main }),
      (0, _preact.h)(_ui_fullscreen_toggle_button2.default, { main: this.main })
    );
  };

  return UIControlBar;
}(_preact.Component);

exports.default = UIControlBar;

/***/ }),

/***/ "./src/ui/js/components/ui_error_msg_overlay.js":
/*!******************************************************!*\
  !*** ./src/ui/js/components/ui_error_msg_overlay.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../../../core/errors */ "./src/core/errors.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

var _ui_tvnoise_canvas = __webpack_require__(/*! ./ui_tvnoise_canvas */ "./src/ui/js/components/ui_tvnoise_canvas.js");

var _ui_tvnoise_canvas2 = _interopRequireDefault(_ui_tvnoise_canvas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIErrorMsgOverlay = function (_Component) {
  _inherits(UIErrorMsgOverlay, _Component);

  function UIErrorMsgOverlay(props) {
    _classCallCheck(this, UIErrorMsgOverlay);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;

    _this.onError = _this.onError.bind(_this);
    _this.player.on(oldmtn.Events.ERROR, _this.onError);
    return _this;
  }

  UIErrorMsgOverlay.prototype.componentDidMount = function componentDidMount() {
    this.vopErrorMsgOverlay = document.querySelector('.vop-error-msg-overlay');
    this.vopTvNoiseCanvas = document.querySelector('.vop-tvnoise-canvas');
    this.vopErrorMsgText = document.querySelector('.vop-error-msg-text');

    this.tvNoiseCanvas = new _ui_tvnoise_canvas2.default({ element: this.vopTvNoiseCanvas });
  };

  UIErrorMsgOverlay.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-error-msg-overlay' },
      (0, _preact.h)('canvas', { className: 'vop-tvnoise-canvas' }),
      (0, _preact.h)('span', { className: 'vop-error-msg-text' })
    );
  };

  UIErrorMsgOverlay.prototype.onError = function onError(e) {
    if (e.type === _errors.ErrorTypes.LICENSE_ERROR) {
      this.vopErrorMsgText.innerHTML = '<strong>License Error<\/strong><br\/>Could not find license.';
      this.vopErrorMsgOverlay.style.display = 'block';

      var canvasWidth = this.vopErrorMsgOverlay.clientWidth;
      var canvasHeight = this.vopErrorMsgOverlay.clientHeight;
      this.tvNoiseCanvas.start({ width: canvasWidth, height: canvasHeight });
    }
  };

  return UIErrorMsgOverlay;
}(_preact.Component);

exports.default = UIErrorMsgOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_fcc_menu.js":
/*!*********************************************!*\
  !*** ./src/ui/js/components/ui_fcc_menu.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIFccMenu = function (_Component) {
  _inherits(UIFccMenu, _Component);

  function UIFccMenu(props) {
    _classCallCheck(this, UIFccMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuBackClick_ = _this.onMenuBackClick.bind(_this);
    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.onFccPropertyValueChange = _this.onFccPropertyValueChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);
    _this.evEmitter.on(_events2.default.FCC_PROPERTY_VALUE_CHANGE, _this.onFccPropertyValueChange);

    _this.fccData = {
      currFccPropertyName: 'background_color', // only valid when currMenu is 'fcc_property_menu'.
      isEnableFCC: true,
      fccPropertyList: [{
        // white/black(default)/red/green/blue/yellow/magenta/cyan
        name: 'background_color',
        values: ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'],
        currValue: 'black'
      }, {
        name: 'background_opacity',
        values: ['0%', '25%', '50%', '75%', '100%'],
        currValue: '100%'
      }, {
        // white/black(default)/red/green/blue/yellow/magenta/cyan
        name: 'font_color',
        values: ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'],
        currValue: 'black'
      }, {
        name: 'font_opacity',
        values: ['0%', '25%', '50%', '75%', '100%'],
        currValue: '100%'
      }, {
        // Arial(default)/Courier/Times New Roman/Helvetica/Dom/Coronet/Gothic
        name: 'font_family',
        values: ['Arial', 'Courier', 'Times New Roman', 'Helvetica', 'Dom', 'Coronet', 'Gothic'],
        currValue: 'Arial'
      }, {
        // none/dropshadow/raised(default)/depressed/uniform
        name: 'font_edge_type',
        values: ['none', 'leftDropShadow', 'rightDropShadow', 'raised', 'depressed', 'uniform'],
        currValue: 'none'
      }, {
        // white/black/red/green/blue(default)/yellow/magenta/cyan
        name: 'font_edge_color',
        values: ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'],
        currValue: 'black'
      }, {
        name: 'font_edge_opacity',
        values: ['0%', '25%', '50%', '75%', '100%'],
        currValue: '100%'
      }, {
        name: 'font_size',
        values: ['50%', '75%', '100%', '150%', '200%', '300%', '400%'],
        currValue: '100%'
      }, {
        name: 'font_bold',
        values: ['true', 'false'],
        currValue: 'false'
      }, {
        name: 'font_underline',
        values: ['true', 'false'],
        currValue: 'false'
      }, {
        name: 'font_italic',
        values: ['true', 'false'],
        currValue: 'false'
      }, {
        // white/black/red/green/blue(default)/yellow/magenta/cyan
        name: 'window_color',
        values: ['white', 'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan'],
        currValue: 'green'
      }, {
        name: 'window_color_opacity',
        values: ['0%', '25%', '50%', '75%', '100%'],
        currValue: '50%'
      }, {
        name: 'bounding_box',
        values: ['Left', 'Top', 'Right', 'Bottom'],
        currValue: 'Left'
      }, {
        name: 'horizontal_position',
        values: ['left', 'center', 'right'],
        currValue: 'left'
      }, {
        name: 'vertical_position',
        values: ['top', 'middle', 'bottom'],
        currValue: 'top'
      }]
    };
    _this.state = {
      fccData: _this.fccData
    };
    return _this;
  }

  UIFccMenu.prototype.componentDidMount = function componentDidMount() {
    this.vopFccMenu = document.querySelector('.vop-fcc-menu');
  };

  UIFccMenu.prototype.render = function render() {
    var _this2 = this;

    myPrintLog('+render, UIFccMenu: ' + this.main.settingMenuUIData.currMenu);
    var fccData = this.state.fccData;


    var menuitems = fccData.fccPropertyList.map(function (item, index) {
      return (0, _preact.h)(
        'div',
        { key: index, className: 'vop-menuitem', role: 'menuitem', 'aria-haspopup': 'true',
          'data-id': item.name, onClick: _this2.onMenuItemClick_,
          tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-label' },
          (0, _preact.h)(
            'span',
            null,
            item.name
          )
        ),
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-content' },
          (0, _preact.h)(
            'span',
            null,
            item.currValue
          )
        )
      );
    });

    return (0, _preact.h)(
      'div',
      { className: 'vop-fcc-menu', style: 'display: none;' },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-header' },
        (0, _preact.h)(
          'button',
          { className: 'vop-panel-title', onClick: this.onMenuBackClick_ },
          'Fcc'
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UIFccMenu.prototype.onMenuBackClick = function onMenuBackClick(e) {
    this.main.settingMenuUIData.currMenu = 'settings_menu';
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UIFccMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    myPrintLog('+onFccMenuItemClick, e.currentTarget.dataset.id: ' + e.currentTarget.dataset.id);

    this.main.settingMenuUIData.currMenu = 'fcc_property_menu';

    var currFccPropertyName = e.currentTarget.dataset.id;
    var fccProperty = void 0;
    for (var i = 0; i < this.fccData.fccPropertyList.length; i++) {
      fccProperty = this.fccData.fccPropertyList[i];
      if (currFccPropertyName === fccProperty.name) {
        break;
      }
    }
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu,
      fccProperty: fccProperty
    });
  };

  UIFccMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'fcc_menu') {
      return;
    }
    this.main.onFccMenuItemBlur(e);
  };

  UIFccMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'fcc_menu') {
      this.vopFccMenu.style.display = 'block';
      var v = this.vopFccMenu.querySelector('.vop-menuitem');
      if (v) {
        v.focus();
      }
    } else {
      this.vopFccMenu.style.display = 'none';
    }
  };

  UIFccMenu.prototype.onFccPropertyValueChange = function onFccPropertyValueChange(e) {
    var fccProperty = e.fccProperty;
    for (var i = 0; i < this.fccData.fccPropertyList.length; i++) {
      var tmpFccProperty = this.fccData.fccPropertyList[i];
      if (tmpFccProperty.name === fccProperty.name) {
        this.fccData.fccPropertyList[i] = fccProperty;
        this.setState({
          fccData: this.fccData
        });
        break;
      }
    }
  };

  return UIFccMenu;
}(_preact.Component);

exports.default = UIFccMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_fcc_property_menu.js":
/*!******************************************************!*\
  !*** ./src/ui/js/components/ui_fcc_property_menu.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIFccPropertyMenu = function (_Component) {
  _inherits(UIFccPropertyMenu, _Component);

  function UIFccPropertyMenu(props) {
    _classCallCheck(this, UIFccPropertyMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuBackClick_ = _this.onMenuBackClick.bind(_this);
    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    _this.fccProperty = null;
    _this.state = {
      fccProperty: _this.fccProperty
    };
    return _this;
  }

  UIFccPropertyMenu.prototype.componentDidUpdate = function componentDidUpdate() {
    var v = document.querySelector('.vop-fcc-property-menu');
    if (v) {
      var item = v.querySelector('.vop-menuitem');
      if (item) {
        item.focus();
      }
    }
  };

  UIFccPropertyMenu.prototype.render = function render() {
    var _this2 = this;

    var fccProperty = this.state.fccProperty;


    if (fccProperty) {
      var menuitems = fccProperty.values.map(function (value, index) {
        return (0, _preact.h)(
          'div',
          { key: index, className: 'vop-menuitem', role: 'menuitemradio',
            'aria-checked': fccProperty.currValue === value,
            onClick: _this2.onMenuItemClick_, 'data-id': value,
            tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
          (0, _preact.h)(
            'div',
            { className: 'vop-menuitem-label' },
            (0, _preact.h)(
              'span',
              null,
              value
            )
          )
        );
      });

      return (0, _preact.h)(
        'div',
        { className: 'vop-fcc-property-menu' },
        (0, _preact.h)(
          'div',
          { className: 'vop-panel-header' },
          (0, _preact.h)(
            'button',
            { className: 'vop-panel-title', onClick: this.onMenuBackClick_ },
            'Fcc'
          )
        ),
        (0, _preact.h)(
          'div',
          { className: 'vop-panel-menu' },
          menuitems
        )
      );
    } else {
      return (0, _preact.h)('div', null);
    }
  };

  UIFccPropertyMenu.prototype.onMenuBackClick = function onMenuBackClick(e) {
    this.main.settingMenuUIData.currMenu = 'fcc_menu';
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UIFccPropertyMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    var currValue = e.currentTarget.dataset.id;
    this.fccProperty.currValue = currValue;
    this.setState({
      fccProperty: this.fccProperty
    });

    this.evEmitter.emit(_events2.default.FCC_PROPERTY_VALUE_CHANGE, {
      fccProperty: this.fccProperty
    });
  };

  UIFccPropertyMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'fcc_property_menu') {
      return;
    }

    var prevFocus = e.target;
    var nextFocus = e.relatedTarget;

    if (nextFocus) {
      if (nextFocus.dataset.id === _id2.default.SETTINGS_BUTTON) {
        // means we click 'setting' button, do nothing here, onUICmdSettings will handle for us.
      } else {
        if (prevFocus) {
          if (-1 === prevFocus.className.indexOf('vop-menuitem')) {
            // means click another item, do nothing here, on***ItemClick will handle for us.
          } else {}
        } else {}
      }
    } else {
      this.main.settingMenuUIData.currMenu = 'none';
      this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
        menu: this.main.settingMenuUIData.currMenu
      });
    }
  };

  UIFccPropertyMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'fcc_property_menu') {
      this.fccProperty = e.fccProperty;
    } else {
      this.fccProperty = null;
    }
    this.setState({
      fccProperty: this.fccProperty
    });
  };

  return UIFccPropertyMenu;
}(_preact.Component);

exports.default = UIFccPropertyMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_fullscreen_toggle_button.js":
/*!*************************************************************!*\
  !*** ./src/ui/js/components/ui_fullscreen_toggle_button.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _preact2 = _interopRequireDefault(_preact);

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIFullscreenToggleButton = function (_Preact$Component) {
  _inherits(UIFullscreenToggleButton, _Preact$Component);

  function UIFullscreenToggleButton(props) {
    _classCallCheck(this, UIFullscreenToggleButton);

    var _this = _possibleConstructorReturn(this, _Preact$Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UIFullscreenToggleButton.prototype.componentDidMount = function componentDidMount() {
    this.vopFullscreenBtn = document.querySelector('.vop-fullscreen-button');

    this.onFullscreenChanged = this.onFullscreenChanged.bind(this);
    this.player.on(oldmtn.Events.FULLSCREEN_CHANGE, this.onFullscreenChanged);
  };

  UIFullscreenToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.FULLSCREEN_CHANGE, this.onFullscreenChanged);
  };

  UIFullscreenToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { className: 'vop-button vop-fullscreen-button icon-on', title: 'fullscreen',
      onClick: this.onUICmdFullscreen.bind(this),
      onMouseMove: this.onControlMouseMove.bind(this) });
  };

  UIFullscreenToggleButton.prototype.onUICmdFullscreen = function onUICmdFullscreen() {
    myPrintLog('+onBtnFullscreen');
    if (this.player.isFullscreen()) {
      _ui_tools2.default.leaveFullscreen();
    } else {
      var v = this.main.playerContainer;
      _ui_tools2.default.enterFullscreen(v);
    }
  };

  UIFullscreenToggleButton.prototype.onControlMouseMove = function onControlMouseMove(e) {
    this.main.onControlMouseMove(e);
  };

  UIFullscreenToggleButton.prototype.onFullscreenChanged = function onFullscreenChanged() {
    var flagIsFullscreen = this.player.isFullscreen();
    myPrintLog('fullscreen changed, ret: ' + flagIsFullscreen + ', width: ' + window.screen.width + ', height: ' + window.screen.height);

    if (flagIsFullscreen) {
      _ui_tools2.default.removeClass(this.vopFullscreenBtn, 'icon-on');
      _ui_tools2.default.addClass(this.vopFullscreenBtn, 'icon-off');
    } else {
      _ui_tools2.default.removeClass(this.vopFullscreenBtn, 'icon-off');
      _ui_tools2.default.addClass(this.vopFullscreenBtn, 'icon-on');
    }
  };

  return UIFullscreenToggleButton;
}(_preact2.default.Component);

exports.default = UIFullscreenToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_gradient_bottom.js":
/*!****************************************************!*\
  !*** ./src/ui/js/components/ui_gradient_bottom.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIGradientBottom = function (_Component) {
  _inherits(UIGradientBottom, _Component);

  function UIGradientBottom(props) {
    _classCallCheck(this, UIGradientBottom);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UIGradientBottom.prototype.render = function render() {
    return (0, _preact.h)("div", { className: "vop-gradient-bottom" });
  };

  return UIGradientBottom;
}(_preact.Component);

exports.default = UIGradientBottom;

/***/ }),

/***/ "./src/ui/js/components/ui_hugebutton_overlay.js":
/*!*******************************************************!*\
  !*** ./src/ui/js/components/ui_hugebutton_overlay.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _preact2 = _interopRequireDefault(_preact);

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIHugeButtonOverlay = function (_Preact$Component) {
  _inherits(UIHugeButtonOverlay, _Preact$Component);

  function UIHugeButtonOverlay(props) {
    _classCallCheck(this, UIHugeButtonOverlay);

    var _this = _possibleConstructorReturn(this, _Preact$Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UIHugeButtonOverlay.prototype.componentDidMount = function componentDidMount() {
    this.uiGiantButton = document.querySelector('.vop-huge-button');
    this.uiGiantBtnContainer = document.querySelector('.vop-huge-button-container');

    this.onMediaPlay = this.onMediaPlay.bind(this);
    this.onMediaPaused = this.onMediaPaused.bind(this);
    this.player.on(oldmtn.Events.MEDIA_PLAY, this.onMediaPlay);
    this.player.on(oldmtn.Events.MEDIA_PAUSED, this.onMediaPaused);
  };

  UIHugeButtonOverlay.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.MEDIA_PLAY, this.onMediaPlay);
    this.player.off(oldmtn.Events.MEDIA_PAUSED, this.onMediaPaused);
  };

  UIHugeButtonOverlay.prototype.render = function render() {
    //myPrintLog('UIHugeButtonOverlay, this.main.playerState: ' + this.main.playerState);

    var style = {};
    switch (this.main.playerState) {
      case 'idle':
      case 'opened':
      case 'ended':
        style.display = 'none';
        break;
      case 'playing':
      case 'paused':
        break;
    }

    return (0, _preact.h)(
      'div',
      { className: 'vop-huge-button-container',
        style: style,
        onAnimationEnd: this.onGiantAnimationEnd.bind(this) },
      (0, _preact.h)('div', { className: 'vop-huge-button' })
    );
  };

  UIHugeButtonOverlay.prototype.onGiantAnimationEnd = function onGiantAnimationEnd(e) {
    this.uiGiantBtnContainer.style.display = 'none';
  };

  UIHugeButtonOverlay.prototype.onMediaPlay = function onMediaPlay() {
    this.updateGiantPlayBtnUI(false);
  };

  UIHugeButtonOverlay.prototype.onMediaPaused = function onMediaPaused() {
    this.updateGiantPlayBtnUI(true);
  };

  UIHugeButtonOverlay.prototype.updateGiantPlayBtnUI = function updateGiantPlayBtnUI(paused) {
    if (this.uiGiantButton) {
      _ui_tools2.default.removeClass(this.uiGiantButton, 'vop-style-play-giant');
      _ui_tools2.default.removeClass(this.uiGiantButton, 'vop-style-pause-giant');
      if (paused) {
        _ui_tools2.default.addClass(this.uiGiantButton, 'vop-style-pause-giant');
      } else {
        _ui_tools2.default.addClass(this.uiGiantButton, 'vop-style-play-giant');
      }
      this.uiGiantBtnContainer.style.display = 'block';
    }
  };

  return UIHugeButtonOverlay;
}(_preact2.default.Component);

exports.default = UIHugeButtonOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_logo_overlay.js":
/*!*************************************************!*\
  !*** ./src/ui/js/components/ui_logo_overlay.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _preact2 = _interopRequireDefault(_preact);

__webpack_require__(/*! ../../assets/img/logo.png */ "./src/ui/assets/img/logo.png");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UILogoOverlay = function (_Preact$Component) {
  _inherits(UILogoOverlay, _Preact$Component);

  function UILogoOverlay(props) {
    _classCallCheck(this, UILogoOverlay);

    return _possibleConstructorReturn(this, _Preact$Component.call(this, props));
  }

  UILogoOverlay.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-logo-container',
        onClick: this.onLogoClick.bind(this),
        onMouseDown: this.onLogoMouseDown.bind(this) },
      (0, _preact.h)(
        'a',
        { href: 'http://localhost/1/LiteH5Player/samples/simple.html', target: '_Blank' },
        (0, _preact.h)('img', { src: './assets/img/logo.png' })
      )
    );
  };

  UILogoOverlay.prototype.onLogoClick = function onLogoClick(e) {
    e.stopPropagation();
  };

  UILogoOverlay.prototype.onLogoMouseDown = function onLogoMouseDown(e) {
    e.stopPropagation();
  };

  return UILogoOverlay;
}(_preact2.default.Component);

exports.default = UILogoOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_pip_toggle_button.js":
/*!******************************************************!*\
  !*** ./src/ui/js/components/ui_pip_toggle_button.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIPipToggleButton = function (_Component) {
  _inherits(UIPipToggleButton, _Component);

  function UIPipToggleButton(props) {
    _classCallCheck(this, UIPipToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.pipMode = false;
    return _this;
  }

  UIPipToggleButton.prototype.componentDidMount = function componentDidMount() {
    this.vopPipButton = document.querySelector('.vop-pip-button');

    this.onAdStarted = this.onAdStarted.bind(this);
    this.onAdComplete = this.onAdComplete.bind(this);
    this.player.on(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.on(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  };

  UIPipToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.off(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  };

  UIPipToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { className: 'vop-button vop-pip-button', title: 'picture in picture',
      onClick: this.onUICmdPip.bind(this) });
  };

  UIPipToggleButton.prototype.onUICmdPip = function onUICmdPip() {
    this.pipMode = !this.pipMode;
    this.player.setPipPresentation(this.pipMode);
  };

  UIPipToggleButton.prototype.onAdStarted = function onAdStarted(e) {
    this.flagAdStarted = true;
    this.flagIsLinearAd = e.linear;
    this.flagIsVpaidAd = e.vpaid;

    if (this.flagAdStarted && this.flagIsLinearAd) {
      this.vopPipButton.style.display = 'none';
    } else {
      this.vopPipButton.style.display = 'inline-block';
    }
  };

  UIPipToggleButton.prototype.onAdComplete = function onAdComplete() {
    this.vopPipButton.style.display = 'inline-block';
  };

  return UIPipToggleButton;
}(_preact.Component);

exports.default = UIPipToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_play_overlay.js":
/*!*************************************************!*\
  !*** ./src/ui/js/components/ui_play_overlay.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIPlayOverlay = function (_Component) {
  _inherits(UIPlayOverlay, _Component);

  function UIPlayOverlay(props) {
    _classCallCheck(this, UIPlayOverlay);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UIPlayOverlay.prototype.componentDidMount = function componentDidMount() {};

  UIPlayOverlay.prototype.componentWillUnmount = function componentWillUnmount() {};

  UIPlayOverlay.prototype.render = function render() {
    return (0, _preact.h)(
      "div",
      { className: "vop-play-overlay-container" },
      (0, _preact.h)("div", { className: "vop-play-overlay", onClick: this.onPlayOverlayClick.bind(this) })
    );

    // let ret = (<div></div>);
    // let retUI = (
    //   <div className="vop-play-overlay-container">
    //     <div className="vop-play-overlay" onClick={this.onPlayOverlayClick.bind(this)}>
    //     </div>
    //   </div>
    // );

    // switch(this.main.playerState) {
    //   case 'opened':
    //   if (this.main.flagAdStarted && this.main.flagIsLinearAd) {
    //   } else {
    //     ret = retUI;
    //   }
    //   break;
    //   case 'ended':
    //   ret = retUI;
    //   break;
    // }

    // return ret;
  };

  UIPlayOverlay.prototype.onPlayOverlayClick = function onPlayOverlayClick() {
    this.main.player.play();
  };

  return UIPlayOverlay;
}(_preact.Component);

exports.default = UIPlayOverlay;

/***/ }),

/***/ "./src/ui/js/components/ui_play_toggle_button.js":
/*!*******************************************************!*\
  !*** ./src/ui/js/components/ui_play_toggle_button.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIPlayToggleButton = function (_Component) {
  _inherits(UIPlayToggleButton, _Component);

  function UIPlayToggleButton(props) {
    _classCallCheck(this, UIPlayToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UIPlayToggleButton.prototype.componentDidMount = function componentDidMount() {};

  UIPlayToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {};

  UIPlayToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { className: 'vop-button vop-play-button', title: 'play',
      onClick: this.onUICmdPlay.bind(this),
      onMouseMove: this.onControlMouseMove.bind(this) });
  };

  UIPlayToggleButton.prototype.onUICmdPlay = function onUICmdPlay() {
    this.main.onUICmdPlay();
  };

  UIPlayToggleButton.prototype.onControlMouseMove = function onControlMouseMove(e) {
    this.main.onControlMouseMove(e);
  };

  return UIPlayToggleButton;
}(_preact.Component);

exports.default = UIPlayToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_popup_menu.js":
/*!***********************************************!*\
  !*** ./src/ui/js/components/ui_popup_menu.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _preact2 = _interopRequireDefault(_preact);

var _ui_subtitles_menu = __webpack_require__(/*! ./ui_subtitles_menu */ "./src/ui/js/components/ui_subtitles_menu.js");

var _ui_subtitles_menu2 = _interopRequireDefault(_ui_subtitles_menu);

var _ui_settings_menu = __webpack_require__(/*! ./ui_settings_menu */ "./src/ui/js/components/ui_settings_menu.js");

var _ui_settings_menu2 = _interopRequireDefault(_ui_settings_menu);

var _ui_quality_menu = __webpack_require__(/*! ./ui_quality_menu */ "./src/ui/js/components/ui_quality_menu.js");

var _ui_quality_menu2 = _interopRequireDefault(_ui_quality_menu);

var _ui_audio_track_menu = __webpack_require__(/*! ./ui_audio_track_menu */ "./src/ui/js/components/ui_audio_track_menu.js");

var _ui_audio_track_menu2 = _interopRequireDefault(_ui_audio_track_menu);

var _ui_fcc_menu = __webpack_require__(/*! ./ui_fcc_menu */ "./src/ui/js/components/ui_fcc_menu.js");

var _ui_fcc_menu2 = _interopRequireDefault(_ui_fcc_menu);

var _ui_fcc_property_menu = __webpack_require__(/*! ./ui_fcc_property_menu */ "./src/ui/js/components/ui_fcc_property_menu.js");

var _ui_fcc_property_menu2 = _interopRequireDefault(_ui_fcc_property_menu);

var _ui_xspeed_menu = __webpack_require__(/*! ./ui_xspeed_menu */ "./src/ui/js/components/ui_xspeed_menu.js");

var _ui_xspeed_menu2 = _interopRequireDefault(_ui_xspeed_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIPopupMenu = function (_Preact$Component) {
  _inherits(UIPopupMenu, _Preact$Component);

  function UIPopupMenu(props) {
    _classCallCheck(this, UIPopupMenu);

    var _this = _possibleConstructorReturn(this, _Preact$Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UIPopupMenu.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-popup vop-popup-menu',
        onMouseDown: this.onPopupMenuMouseDown.bind(this) },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel' },
        (0, _preact.h)(_ui_subtitles_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_settings_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_quality_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_audio_track_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_fcc_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_fcc_property_menu2.default, { main: this.main }),
        (0, _preact.h)(_ui_xspeed_menu2.default, { main: this.main })
      )
    );
  };

  UIPopupMenu.prototype.onPopupMenuMouseDown = function onPopupMenuMouseDown(e) {
    // Don't route 'click' event from panel to its parent div
    e.stopPropagation();
  };

  return UIPopupMenu;
}(_preact2.default.Component);

exports.default = UIPopupMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_progress_bar.js":
/*!*************************************************!*\
  !*** ./src/ui/js/components/ui_progress_bar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIProgressBar = function (_Component) {
  _inherits(UIProgressBar, _Component);

  function UIProgressBar(props) {
    _classCallCheck(this, UIProgressBar);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    // flags reference variable of progress bar
    _this.progressBarContext;
    _this.progressBarMoveContext = {
      movePos: 0
    };
    _this.flagThumbnailMode = false;
    return _this;
  }

  UIProgressBar.prototype.componentDidMount = function componentDidMount() {
    this.vopProgressBar = document.querySelector('.vop-progress-bar');
    this.vopLoadProgress = document.querySelector('.vop-load-progress');
    this.vopPlayProgress = document.querySelector('.vop-play-progress');
    this.vopHoverProgress = document.querySelector('.vop-hover-progress');
    this.vopScrubberContainer = document.querySelector('.vop-scrubber-container');

    this.onProgressBarMouseDown_ = this.onProgressBarMouseDown.bind(this);
    this.onProgressBarMouseMove_ = this.onProgressBarMouseMove.bind(this);
    this.onProgressBarMouseLeave_ = this.onProgressBarMouseLeave.bind(this);

    this.vopProgressBar.addEventListener('mousedown', this.onProgressBarMouseDown_);
    this.vopProgressBar.addEventListener('mousemove', this.onProgressBarMouseMove_);
    this.vopProgressBar.addEventListener('mouseleave', this.onProgressBarMouseLeave_);

    this.onMediaDurationChanged = this.onMediaDurationChanged.bind(this);
    this.onMediaTimeupdated = this.onMediaTimeupdated.bind(this);
    this.onMediaSeeked = this.onMediaSeeked.bind(this);
    this.onAdTimeUpdate = this.onAdTimeUpdate.bind(this);

    this.player.on(oldmtn.Events.MEDIA_DURATION_CHANGED, this.onMediaDurationChanged);
    this.player.on(oldmtn.Events.MEDIA_TIMEUPDATE, this.onMediaTimeupdated);
    this.player.on(oldmtn.Events.MEDIA_SEEKED, this.onMediaSeeked);
    this.player.on(oldmtn.Events.AD_TIMEUPDATE, this.onAdTimeUpdate);
  };

  UIProgressBar.prototype.componentWillUnmount = function componentWillUnmount() {
    this.vopProgressBar.removeEventListener('mousedown', this.onProgressBarMouseDown_);
    this.vopProgressBar.removeEventListener('mousemove', this.onProgressBarMouseMove_);
    this.vopProgressBar.removeEventListener('mouseleave', this.onProgressBarMouseLeave_);

    this.player.off(oldmtn.Events.MEDIA_DURATION_CHANGED, this.onMediaDurationChanged);
    this.player.off(oldmtn.Events.MEDIA_TIMEUPDATE, this.onMediaTimeupdated);
    this.player.off(oldmtn.Events.MEDIA_SEEKED, this.onMediaSeeked);
    this.player.off(oldmtn.Events.AD_TIMEUPDATE, this.onAdTimeUpdate);
  };

  UIProgressBar.prototype.render = function render() {
    var endStyle = {
      loadProgressTransform: '',
      playProgressTransform: '',
      scrubberContainerTransform: '',
      uiPosition: 0
    };

    switch (this.main.playerState) {
      case 'ended':
        var position = this.player.getPosition();
        var duration = this.player.getDuration();
        if (this.progressBarContext) {
          this.progressBarContext.movePos = position;
        }
        endStyle = this.getProgressBarUIStyle(position, duration);
        break;
    }

    return (0, _preact.h)(
      'div',
      { className: 'vop-progress-bar' },
      (0, _preact.h)(
        'div',
        { className: 'vop-progress-list' },
        (0, _preact.h)('div', { className: 'vop-load-progress' + ' ' + endStyle.loadProgressTransform }),
        (0, _preact.h)('div', { className: 'vop-hover-progress' }),
        (0, _preact.h)('div', { className: 'vop-play-progress' + ' ' + endStyle.playProgressTransform })
      ),
      (0, _preact.h)('div', { className: 'vop-scrubber-container' + ' ' + endStyle.scrubberContainerTransform })
    );
  };

  UIProgressBar.prototype.onMediaDurationChanged = function onMediaDurationChanged() {
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    this.updateProgressBarUI(position, duration);
  };

  UIProgressBar.prototype.onMediaTimeupdated = function onMediaTimeupdated() {
    //myPrintLog('+onMediaTimeupdated, position: ' + this.player.getPosition() + ', duration: ' + this.player.getDuration());

    // Sometime, the timeupdate will trigger after we mouse down on the progress bar,
    // in this situation, we won't update progress bar ui.
    if (this.progressBarContext) {
      // do nothing
    } else {
      //this.progressBarContext.movePos = this.player.getPosition();
      var position = this.player.getPosition();
      var duration = this.player.getDuration();
      this.updateProgressBarUI(position, duration);
      this.updateProgressBarHoverUI();
    }
  };

  UIProgressBar.prototype.onMediaSeeked = function onMediaSeeked() {
    myPrintLog('+onMediaSeeked, pos: ' + this.player.getPosition() + ', paused: ' + this.player.isPaused() + ', ended: ' + this.player.isEnded());

    if (this.progressBarContext) {
      if (!this.progressBarContext.pausedBeforeMousedown || this.progressBarContext.endedBeforeMousedown) {
        this.player.play();
      }
      this.progressBarContext = null;
    }
  };

  UIProgressBar.prototype.onAdTimeUpdate = function onAdTimeUpdate() {
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    //myPrintLog('ad position: ' + position + ', duration: ' + duration);
    this.updateProgressBarUI(position, duration);
  };

  UIProgressBar.prototype.onProgressBarMouseDown = function onProgressBarMouseDown(e) {
    this.captureProgressBarMouseEvents();
    e.preventDefault();
    e.stopPropagation();

    this.progressBarContext = {};
    this.progressBarContext.pausedBeforeMousedown = this.player.isPaused();
    this.progressBarContext.endedBeforeMousedown = this.player.isEnded();
    this.progressBarContext.posBeforeMousedown = this.player.getPosition();
    this.flagThumbnailMode = false;
    this.progressBarContext.timer = setTimeout(function () {
      this.doEnterThumbnailMode();
    }.bind(this), 200);

    // update progress bar ui
    this.progressBarContext.movePos = this.getProgressMovePosition(e);
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    this.updateProgressBarUI(position, duration);
    this.updateProgressBarHoverUI();
  };

  UIProgressBar.prototype.onProgressBarMouseMove = function onProgressBarMouseMove(e) {
    //myPrintLog('+onProgressBarMouseMove, clientX: ' + e.clientX + ', clientY: ' + e.clientY);
    e.stopPropagation();
    this.main.removeAutohideAction();

    // if mouse down, just return
    if (this.progressBarContext || this.main.settingMenuUIData.currMenu !== 'none') {
      return;
    }

    // update progress bar ui
    var movePos = this.getProgressMovePosition(e);
    this.progressBarMoveContext.movePos = movePos;
    this.updateProgressBarHoverUI();

    // 
    this.evEmitter.emit(_events2.default.PROGRESSBAR_MOUSEMOVE, {
      movePos: movePos
    });
    this.vopScrubberContainer.style.display = 'block';
  };

  UIProgressBar.prototype.onProgressBarMouseLeave = function onProgressBarMouseLeave(e) {
    myPrintLog('+onProgressBarMouseLeave');
    this.evEmitter.emit(_events2.default.PROGRESSBAR_MOUSELEAVE);
    this.vopScrubberContainer.style.display = 'none';
  };

  UIProgressBar.prototype.captureProgressBarMouseEvents = function captureProgressBarMouseEvents() {
    this.newProgressBarMouseMove = this.docProgressBarMouseMove.bind(this);
    this.newProgressBarMouseUp = this.docProgressBarMouseUp.bind(this);

    document.addEventListener('mousemove', this.newProgressBarMouseMove, true);
    document.addEventListener('mouseup', this.newProgressBarMouseUp, true);
    // Don't process mouse move/leave event when mouse is down, since we delegate it to document mouse move/up event.
    this.vopProgressBar.removeEventListener('mousemove', this.onProgressBarMouseMove_);
    this.vopProgressBar.removeEventListener('mouseleave', this.onProgressBarMouseLeave_);
  };

  UIProgressBar.prototype.releaseProgressBarMouseEvents = function releaseProgressBarMouseEvents() {
    document.removeEventListener('mousemove', this.newProgressBarMouseMove, true);
    document.removeEventListener('mouseup', this.newProgressBarMouseUp, true);

    this.vopProgressBar.addEventListener('mousemove', this.onProgressBarMouseMove_);
    this.vopProgressBar.addEventListener('mouseleave', this.onProgressBarMouseLeave_);
  };

  UIProgressBar.prototype.docProgressBarMouseMove = function docProgressBarMouseMove(e) {
    myPrintLog('+docProgressBarMouseMove');

    var movePos = this.getProgressMovePosition(e);
    if (this.progressBarContext.movePos === movePos) {
      return;
    }

    this.doEnterThumbnailMode();
    this.doProcessThumbnailMove();

    this.progressBarContext.movePos = movePos;
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    this.updateProgressBarUI(position, duration);
    this.updateProgressBarHoverUI();

    this.evEmitter.emit(_events2.default.PROGRESSBAR_MOUSEMOVE, {
      movePos: movePos
    });
    this.vopScrubberContainer.style.display = 'block';
  };

  UIProgressBar.prototype.docProgressBarMouseUp = function docProgressBarMouseUp(e) {
    //myPrintLog('+docProgressBarMouseUp');
    e.preventDefault();
    this.releaseProgressBarMouseEvents();

    if (this.flagThumbnailMode) {
      // thumbnail mode click event
      this.doProcessThumbnailUp();
    } else {
      // plain click event
      if (this.progressBarContext.timer) {
        // it's quick click, don't need to pause
        clearTimeout(this.progressBarContext.timer);
        this.progressBarContext.timer = null;
      }
    }

    // update ui first
    this.progressBarContext.movePos = this.getProgressMovePosition(e);
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    this.updateProgressBarUI(position, duration);
    this.updateProgressBarHoverUI();

    //
    this.evEmitter.emit(_events2.default.PROGRESSBAR_MOUSELEAVE);
    if (!_ui_tools2.default.isPtInElement({ x: e.clientX, y: e.clientY }, this.vopProgressBar)) {
      this.vopScrubberContainer.style.display = 'none';
    }

    // player seeking
    if (this.progressBarContext.posBeforeMousedown != this.progressBarContext.movePos) {
      this.player.setPosition(this.progressBarContext.movePos);
    } else {
      this.progressBarContext = null;
    }
  };

  UIProgressBar.prototype.doEnterThumbnailMode = function doEnterThumbnailMode() {
    myPrintLog('+doEnterThumbnailMode');
    if (!this.flagThumbnailMode) {
      // need to pause content first before starting a seek operation.
      if (!this.progressBarContext.pausedBeforeMousedown) {
        this.player.pause();
      }

      this.progressBarContext.timer = null;
      this.flagThumbnailMode = true;
    }
  };

  UIProgressBar.prototype.doProcessThumbnailMove = function doProcessThumbnailMove() {
    // for further action, you can add thumbnail popup here.
  };

  UIProgressBar.prototype.doProcessThumbnailUp = function doProcessThumbnailUp() {
    // for further action, you can add thumbnail ended event here.
  };

  UIProgressBar.prototype.getProgressMovePosition = function getProgressMovePosition(e) {
    // part - input
    var rect = this.vopProgressBar.getBoundingClientRect();

    // part - logic process
    var offsetX = e.clientX - rect.left;
    if (offsetX < 0) {
      offsetX = 0;
    } else if (offsetX > rect.width) {
      offsetX = rect.width;
    }

    // update time progress scrubber button
    var duration = this.player.getDuration();
    return offsetX / rect.width * duration;
  };

  UIProgressBar.prototype.getProgressBarUIStyle = function getProgressBarUIStyle(position, duration) {
    // part - logic process
    var uiPosition = 0;
    var loadProgressTransform = '';
    var playProgressTransform = '';
    var scrubberContainerTransform = '';

    var isLive = duration === Infinity ? true : false;
    if (isLive) {
      var seekable = this.player.getSeekableRange();
      var buffered = this.player.getBufferedRanges();
      //myPrintLog('seekable: ' + oldmtn.CommonUtils.TimeRangesToString(seekable) + ', buffered: ' + oldmtn.CommonUtils.TimeRangesToString(buffered));
    } else {
      var uiBufferedPos = void 0;
      if (this.progressBarContext) {
        uiPosition = this.progressBarContext.movePos;
      } else {
        uiPosition = position;
      }

      // part - output, update ui
      // update time progress bar
      uiBufferedPos = this.player.getValidBufferPosition(uiPosition);
      loadProgressTransform = 'scaleX(' + uiBufferedPos / duration + ')';
      playProgressTransform = 'scaleX(' + uiPosition / duration + ')';

      // update time progress scrubber button
      scrubberContainerTransform = 'translateX(' + (uiPosition / duration * this.vopProgressBar.clientWidth).toString() + 'px)';
    }

    var ret = {
      loadProgressTransform: loadProgressTransform,
      playProgressTransform: playProgressTransform,
      scrubberContainerTransform: scrubberContainerTransform,
      uiPosition: uiPosition
    };

    return ret;
  };

  UIProgressBar.prototype.updateProgressBarUI = function updateProgressBarUI(position, duration) {
    // part - input
    var ret = this.getProgressBarUIStyle(position, duration);

    // part - logic process
    var isLive = duration === Infinity ? true : false;
    if (isLive) {} else {
      this.vopLoadProgress.style.transform = ret.loadProgressTransform;
      this.vopPlayProgress.style.transform = ret.playProgressTransform;

      // update time progress scrubber button
      this.vopScrubberContainer.style.transform = ret.scrubberContainerTransform;
    }
  };

  UIProgressBar.prototype.updateProgressBarHoverUI = function updateProgressBarHoverUI() {
    var position = this.player.getPosition();
    var duration = this.player.getDuration();

    var movePos = 0;
    if (this.progressBarContext) {}
    //myPrintLog('test0703, this.progressBarContext.movePos: ' + this.progressBarContext.movePos);

    //myPrintLog('test0703, this.progressBarMoveContext.movePos: ' + this.progressBarMoveContext.movePos);
    if (this.progressBarContext) {
      movePos = this.progressBarContext.movePos;
    } else if (this.progressBarMoveContext) {
      movePos = this.progressBarMoveContext.movePos;
    }
    //myPrintLog('test0703, movePost: ' + movePos);
    if (movePos <= position) {
      this.vopHoverProgress.style.transform = 'scaleX(0)';
    } else {
      var rect = this.vopProgressBar.getBoundingClientRect();
      var offsetX = position / duration * rect.width;
      this.vopHoverProgress.style.left = offsetX + 'px';
      this.vopHoverProgress.style.transform = 'scaleX(' + (movePos - position) / duration + ')';
    }
  };

  return UIProgressBar;
}(_preact.Component);

exports.default = UIProgressBar;

/***/ }),

/***/ "./src/ui/js/components/ui_quality_menu.js":
/*!*************************************************!*\
  !*** ./src/ui/js/components/ui_quality_menu.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIQualityMenu = function (_Component) {
  _inherits(UIQualityMenu, _Component);

  function UIQualityMenu(props) {
    _classCallCheck(this, UIQualityMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuBackClick_ = _this.onMenuBackClick.bind(_this);
    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    _this.qualityData = { // quality settings menu
      qualityList: [{
        id: '6',
        bitrate: '1080p'
      }, {
        id: '5',
        bitrate: '720p'
      }, {
        id: '4',
        bitrate: '480p'
      }, {
        id: '3',
        bitrate: '360p'
      }, {
        id: '2',
        bitrate: '240p'
      }, {
        id: '1',
        bitrate: '144p'
      }, {
        id: '-1',
        bitrate: 'Auto'
      }],
      isQualityAuto: true,
      currQualityId: '2'
    };
    _this.state = {
      qualityData: _this.qualityData
    };
    return _this;
  }

  UIQualityMenu.prototype.componentDidMount = function componentDidMount(e) {
    this.vopQualityMenu = document.querySelector('.vop-quality-menu');
  };

  UIQualityMenu.prototype.render = function render() {
    var _this2 = this;

    console.log('UIQualityMenu, render');

    var qualityData = this.state.qualityData;


    var menuitems = qualityData.qualityList.map(function (item, index) {
      return (0, _preact.h)(
        'div',
        { key: index, className: 'vop-menuitem', role: 'menuitemradio',
          'aria-checked': qualityData.currQualityId === item.id,
          'data-id': item.id, onClick: _this2.onMenuItemClick_,
          tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-label' },
          (0, _preact.h)(
            'span',
            null,
            item.bitrate
          )
        )
      );
    });

    return (0, _preact.h)(
      'div',
      { className: 'vop-quality-menu', style: 'display:none;' },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-header' },
        (0, _preact.h)(
          'button',
          { className: 'vop-panel-title', onClick: this.onMenuBackClick_ },
          'Quality'
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UIQualityMenu.prototype.onMenuBackClick = function onMenuBackClick(e) {
    this.main.settingMenuUIData.currMenu = 'settings_menu';
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UIQualityMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    myPrintLog('+onQualityMenuItemClick, this.settingMenuUIData.currMenu: ' + this.main.settingMenuUIData.currMenu + ', text: ' + e.target.innerText);
    var nextFocus = e.currentTarget;

    this.qualityData.currQualityId = nextFocus.dataset.id;
    this.setState({
      qualityData: this.qualityData
    });
  };

  UIQualityMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'quality_menu') {
      return;
    }

    this.main.onQualityMenuItemBlur(e);
  };

  UIQualityMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'quality_menu') {
      this.vopQualityMenu.style.display = 'block';
      var v = this.vopQualityMenu.querySelector('.vop-menuitem');
      if (v) {
        v.focus();
      }
    } else {
      this.vopQualityMenu.style.display = 'none';
    }
  };

  return UIQualityMenu;
}(_preact.Component);

exports.default = UIQualityMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_settings_menu.js":
/*!**************************************************!*\
  !*** ./src/ui/js/components/ui_settings_menu.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UISettingsMenu = function (_Component) {
  _inherits(UISettingsMenu, _Component);

  function UISettingsMenu(props) {
    _classCallCheck(this, UISettingsMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    _this.SETTINGS_DATA = {
      settingsList: [{
        id: _id2.default.MENUITEM_QUALITY,
        text: 'Quality'
      }, {
        id: _id2.default.MENUITEM_AUDIO_TRACK,
        text: 'Language'
      }, {
        id: _id2.default.MENUITEM_FCC,
        text: 'Subtitle'
      }, {
        id: _id2.default.MENUITEM_XSPEED,
        text: 'XSpeed'
      }]
    };

    _this.settingsData = {};
    _this.state = {
      settingsData: _this.settingsData
    };

    //
    _this.menuStyle = {
      display: 'none'
    };
    return _this;
  }

  UISettingsMenu.prototype.componentDidMount = function componentDidMount(e) {};

  UISettingsMenu.prototype.componentDidUpdate = function componentDidUpdate(e) {
    if (!this.vopSettingsMenu) {
      this.vopSettingsMenu = document.querySelector('.vop-settings-menu');
    }
    var item = this.vopSettingsMenu.querySelector('.vop-menuitem');
    if (item) {
      item.focus();
    }
  };

  UISettingsMenu.prototype.render = function render() {
    //myPrintLog(`UISettingsMenu, render, ${this.main.settingMenuUIData.currMenu}`);
    var settingsData = this.state.settingsData;


    var menuitems = [];
    if (settingsData.settingsList) {
      menuitems = settingsData.settingsList.map(function (item, index) {
        var currValue = '';
        return (0, _preact.h)(
          'div',
          { key: index, className: 'vop-menuitem', role: 'menuitem', 'aria-haspopup': 'true',
            'data-id': item.id, onClick: this.onMenuItemClick_,
            tabIndex: '0', onBlur: this.onMenuItemBlur_ },
          (0, _preact.h)(
            'div',
            { className: 'vop-menuitem-label' },
            item.text
          ),
          (0, _preact.h)(
            'div',
            { className: 'vop-menuitem-content' },
            (0, _preact.h)(
              'span',
              { className: 'vop-menuitem-content-text' },
              currValue
            )
          )
        );
      }.bind(this));
    }

    return (0, _preact.h)(
      'div',
      { className: 'vop-settings-menu',
        style: this.menuStyle },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UISettingsMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    myPrintLog('+onMainMenuItemClick, ' + ' this.settingMenuUIData.currMenu: ' + this.main.settingMenuUIData.currMenu + ', text: ' + e.target.innerText);
    var nextFocus = e.currentTarget;

    myPrintLog('id: ' + nextFocus.dataset.id);
    var menu = void 0;
    switch (nextFocus.dataset.id) {
      case _id2.default.MENUITEM_QUALITY:
        menu = 'quality_menu';
        break;
      case _id2.default.MENUITEM_AUDIO_TRACK:
        menu = 'audio_track_menu';
        break;
      case _id2.default.MENUITEM_FCC:
        menu = 'fcc_menu';
        break;
      case _id2.default.MENUITEM_XSPEED:
        menu = 'xspeed_menu';
      default:
        break;
    }

    this.main.settingMenuUIData.currMenu = menu;
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UISettingsMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'settings_menu') {
      return;
    }
    var text = '';
    if (e.relatedTarget) {
      text = ', text: ' + e.relatedTarget.innerText;
    }

    myPrintLog('+onMainMenuItemBlur, this.settingMenuUIData.currMenu: ' + this.main.settingMenuUIData.currMenu + text);

    var prevFocus = e.target;
    var nextFocus = e.relatedTarget;

    if (nextFocus) {
      if (nextFocus.dataset.id === _id2.default.SETTINGS_BUTTON) {
        // means we click 'setting' button, do nothing here, onUICmdSettings will handle for us.
      } else {
        if (prevFocus) {
          if (-1 === prevFocus.className.indexOf('vop-menuitem')) {
            // means click another item, do nothing here, on***ItemClick will handle for us.
          } else {}
        } else {}
      }
    } else {
      this.main.settingMenuUIData.currMenu = 'none';
      this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
        menu: this.main.settingMenuUIData.currMenu
      });
    }
  };

  UISettingsMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'settings_menu') {
      this.settingsData = Object.assign({}, this.SETTINGS_DATA);

      // Filter some menu items that don't need to show.
      var tracks = this.player.getSubtitleTracks();

      if (tracks.length === 0) {
        for (var i = 0; i < this.settingsData.settingsList.length; i++) {
          var item = this.settingsData.settingsList[i];
          if (item.id === '3') {
            this.settingsData.settingsList.splice(i, 1);
            break;
          }
        }
      }

      this.menuStyle = {
        display: 'block'
      };

      // Display popup menu ui
      this.setState({
        settingsData: this.settingsData
      });
    } else {
      this.menuStyle = {
        display: 'none'
      };
      this.settingsData = {};
      this.setState({
        settingsData: this.settingsData
      });
    }
  };

  return UISettingsMenu;
}(_preact.Component);

exports.default = UISettingsMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_settings_toggle_button.js":
/*!***********************************************************!*\
  !*** ./src/ui/js/components/ui_settings_toggle_button.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UISettingsToggleButton = function (_Component) {
  _inherits(UISettingsToggleButton, _Component);

  function UISettingsToggleButton(props) {
    _classCallCheck(this, UISettingsToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;
    return _this;
  }

  UISettingsToggleButton.prototype.componentDidMount = function componentDidMount() {
    this.vopSettingsButton = document.querySelector('.vop-settings-button');
  };

  UISettingsToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { 'data-id': _id2.default.SETTINGS_BUTTON, className: 'vop-button vop-settings-button', title: 'settings',
      onClick: this.onUICmdSettings.bind(this),
      onMouseMove: this.onControlMouseMove.bind(this) });
  };

  UISettingsToggleButton.prototype.onUICmdSettings = function onUICmdSettings() {
    if (this.main.settingMenuUIData.currMenu === 'subtitles_menu') {
      this.main.settingMenuUIData.currMenu = 'settings_menu';
    } else {
      if (this.main.settingMenuUIData.currMenu !== 'none') {
        this.main.settingMenuUIData.currMenu = 'none';
      } else {
        this.main.settingMenuUIData.currMenu = 'settings_menu';
      }
    }
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UISettingsToggleButton.prototype.onControlMouseMove = function onControlMouseMove(e) {
    e.stopPropagation();
    this.main.removeAutohideAction();
  };

  return UISettingsToggleButton;
}(_preact.Component);

exports.default = UISettingsToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_subtitles_menu.js":
/*!***************************************************!*\
  !*** ./src/ui/js/components/ui_subtitles_menu.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UISubtitlesMenu = function (_Component) {
  _inherits(UISubtitlesMenu, _Component);

  function UISubtitlesMenu(props) {
    _classCallCheck(this, UISubtitlesMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onTrackAdded = _this.onTrackAdded.bind(_this);
    _this.player.on(oldmtn.Events.TRACK_ADDED, _this.onTrackAdded);
    //
    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    // this.textTracksData = {
    //   // subtitle menu
    //   tracks: [{
    //     id: '1',
    //     lang: 'English'
    //   }, {
    //     id: '2',
    //     lang: 'French'
    //   }, {
    //     id: '3',
    //     lang: 'Chinese'
    //   }, {
    //     id: '4',
    //     lang: 'Dutch'
    //   }, {
    //     id: '5',
    //     lang: 'Spanish'
    //   }, {
    //     id: '6',
    //     lang: 'Korean'
    //   }, {
    //     id: '7',
    //     lang: 'Thai'
    //   }],
    //   currTrackId: '2'
    // }
    _this.textTracksData = {
      tracks: [],
      currTrackId: ''
    };
    _this.state = {
      textTracksData: _this.textTracksData
    };
    return _this;
  }

  UISubtitlesMenu.prototype.componentDidMount = function componentDidMount(e) {
    this.vopSubtitlesMenu = document.querySelector('.vop-subtitles-menu');
  };

  UISubtitlesMenu.prototype.render = function render() {
    var _this2 = this;

    var textTracksData = this.state.textTracksData;


    var menuitems = textTracksData.tracks.map(function (item, index) {
      return (0, _preact.h)(
        'div',
        { key: index, className: 'vop-menuitem', role: 'menuitem',
          'aria-checked': textTracksData.currTrackId === item.id ? 'true' : 'false',
          'data-id': item.id, onClick: _this2.onMenuItemClick_,
          tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-label' },
          item.lang
        ),
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-content' },
          (0, _preact.h)('div', { className: 'vop-menuitem-toggle-checkbox' })
        )
      );
    });

    return (0, _preact.h)(
      'div',
      { className: 'vop-subtitles-menu', style: 'display: none;' },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UISubtitlesMenu.prototype.onMenuBackClick = function onMenuBackClick() {
    myPrintLog('+onMenuBack');
    this.main.onSubtitleMenuBack();
  };

  UISubtitlesMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    myPrintLog('+onMenuItemClick');
    e.stopPropagation();

    var id = e.currentTarget.dataset.id;
    if (this.textTracksData.currTrackId === id) {
      this.textTracksData.currTrackId = '';
    } else {
      this.textTracksData.currTrackId = id;
    }
    this.setState({
      textTracksData: this.textTracksData
    });

    // apply changes to player instance
    this.player.selectSubtitleTrack(this.textTracksData.currTrackId);
  };

  UISubtitlesMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    myPrintLog('+onMenuItemBlur');
    if (this.main.settingMenuUIData.currMenu !== 'subtitles_menu') {
      return;
    }

    if (e.relatedTarget) {
      if (e.relatedTarget.dataset.id === _id2.default.SUBTITLES_BUTTON) {
        if (this.main.settingMenuUIData.currMenu === 'settings_menu') {
          // do nothing
        }
      }
    } else {
      this.main.settingMenuUIData.currMenu = 'none';
      this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
        menu: this.main.settingMenuUIData.currMenu
      });
    }
  };

  UISubtitlesMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'subtitles_menu') {
      this.vopSubtitlesMenu.style.display = 'block';
      var v = this.vopSubtitlesMenu.querySelector('.vop-menuitem');
      if (v) {
        v.focus();
      }
    } else {
      this.vopSubtitlesMenu.style.display = 'none';
    }
  };

  UISubtitlesMenu.prototype.onTrackAdded = function onTrackAdded(e) {
    var track = e.track;
    var currTrackId = e.currTrackId;

    this.textTracksData.tracks.push(track);
    this.textTracksData.currTrackId = currTrackId;
    this.setState({
      textTracksData: this.textTracksData
    });
  };

  return UISubtitlesMenu;
}(_preact.Component);

exports.default = UISubtitlesMenu;

/***/ }),

/***/ "./src/ui/js/components/ui_subtitles_toggle_button.js":
/*!************************************************************!*\
  !*** ./src/ui/js/components/ui_subtitles_toggle_button.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UISubtitlesToggleButton = function (_Component) {
  _inherits(UISubtitlesToggleButton, _Component);

  function UISubtitlesToggleButton(props) {
    _classCallCheck(this, UISubtitlesToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onAdStarted = _this.onAdStarted.bind(_this);
    _this.onAdComplete = _this.onAdComplete.bind(_this);
    _this.player.on(oldmtn.Events.AD_STARTED, _this.onAdStarted);
    _this.player.on(oldmtn.Events.AD_COMPLETE, _this.onAdComplete);

    _this.onTrackAdded = _this.onTrackAdded.bind(_this);
    _this.player.on(oldmtn.Events.TRACK_ADDED, _this.onTrackAdded);
    return _this;
  }

  UISubtitlesToggleButton.prototype.componentDidMount = function componentDidMount() {};

  UISubtitlesToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.off(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
  };

  UISubtitlesToggleButton.prototype.render = function render() {
    return (0, _preact.h)('button', { 'data-id': _id2.default.SUBTITLES_BUTTON,
      className: 'vop-button vop-subtitles-button',
      style: 'display: none;',
      title: 'subtitles',
      onClick: this.onUICmdSubtitles.bind(this),
      onMouseMove: this.onControlMouseMove.bind(this) });
  };

  UISubtitlesToggleButton.prototype.onUICmdSubtitles = function onUICmdSubtitles() {
    if (this.main.settingMenuUIData.currMenu !== 'subtitles_menu') {
      this.main.settingMenuUIData.currMenu = 'subtitles_menu';
    } else {
      this.main.settingMenuUIData.currMenu = 'none';
    }
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UISubtitlesToggleButton.prototype.onControlMouseMove = function onControlMouseMove(e) {
    e.stopPropagation();
    this.main.removeAutohideAction();
  };

  UISubtitlesToggleButton.prototype.onAdStarted = function onAdStarted(e) {
    this.flagAdStarted = true;
    this.flagIsLinearAd = e.linear;
    this.flagIsVpaidAd = e.vpaid;

    if (this.flagAdStarted && this.flagIsLinearAd) {
      this.vopSubtitlesButton.style.display = 'none';
    } else {
      this.vopSubtitlesButton.style.display = 'inline-block';
    }
  };

  UISubtitlesToggleButton.prototype.onAdComplete = function onAdComplete() {
    this.vopSubtitlesButton.style.display = 'inline-block';
  };

  UISubtitlesToggleButton.prototype.onTrackAdded = function onTrackAdded(e) {
    if (!this.vopSubtitlesButton) {
      this.vopSubtitlesButton = document.querySelector('.vop-subtitles-button');
    }
    this.vopSubtitlesButton.style.display = 'block';
  };

  return UISubtitlesToggleButton;
}(_preact.Component);

exports.default = UISubtitlesToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_time_label.js":
/*!***********************************************!*\
  !*** ./src/ui/js/components/ui_time_label.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UITimeLabel = function (_Component) {
  _inherits(UITimeLabel, _Component);

  function UITimeLabel(props) {
    _classCallCheck(this, UITimeLabel);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    return _this;
  }

  UITimeLabel.prototype.componentDidMount = function componentDidMount() {
    this.vopTimeLabel = document.querySelector('.vop-time-text');

    this.onMediaTimeupdated = this.onMediaTimeupdated.bind(this);

    this.player.on(oldmtn.Events.MEDIA_TIMEUPDATE, this.onMediaTimeupdated);
  };

  UITimeLabel.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.MEDIA_TIMEUPDATE, this.onMediaTimeupdated);
  };

  UITimeLabel.prototype.render = function render() {
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    var timeText = '00:00/00:00';
    switch (this.main.playerState) {
      case 'idle':
      case 'opened':
      case 'playing':
      case 'paused':
      case 'ended':
        timeText = this.getTimeDisplay(position, duration);
        break;
      default:
        break;
    }

    return (0, _preact.h)(
      'div',
      { className: 'vop-time-display' },
      (0, _preact.h)(
        'span',
        { className: 'vop-time-text' },
        timeText
      )
    );
  };

  UITimeLabel.prototype.onMediaTimeupdated = function onMediaTimeupdated() {
    var position = this.player.getPosition();
    var duration = this.player.getDuration();
    this.updateTimeDisplay(position, duration);
  };

  UITimeLabel.prototype.getTimeDisplay = function getTimeDisplay(position, duration) {
    var isLive = duration === Infinity ? true : false;

    var timeText = '';
    if (isLive) {
      // update time display label
      timeText = 'Live';
    } else {
      // update time display label
      var c = oldmtn.CommonUtils.timeToString(position);
      var d = oldmtn.CommonUtils.timeToString(duration);
      timeText = c + '/' + d;
    }

    return timeText;
  };

  UITimeLabel.prototype.updateTimeDisplay = function updateTimeDisplay(position, duration) {
    var text = this.getTimeDisplay(position, duration);
    if (text === 'Live') {
      _ui_tools2.default.addClass(this.vopTimeLabel, 'vop-time-text-live');
    } else {
      _ui_tools2.default.removeClass(this.vopTimeLabel, 'vop-time-text-live');
    }
    this.vopTimeLabel.innerText = text;
  };

  return UITimeLabel;
}(_preact.Component);

exports.default = UITimeLabel;

/***/ }),

/***/ "./src/ui/js/components/ui_title_bar.js":
/*!**********************************************!*\
  !*** ./src/ui/js/components/ui_title_bar.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UITitleBar = function (_Component) {
  _inherits(UITitleBar, _Component);

  function UITitleBar(props) {
    _classCallCheck(this, UITitleBar);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    return _this;
  }

  UITitleBar.prototype.render = function render() {
    // let title = '';
    // let description = '';
    // let title = 'Sintel';
    // let description = 'A woman, Sintel, is attacked while traveling through a wintry mountainside. After defeating her attacker and taking his spear, she finds refuge in a shaman\'s hut...';
    var title = 'Big Buck Bunny';
    var description = 'Tired of being picked on by Frankie the squirrel and his band of puny forest creatures, JC the bunny finally decides to fight back.';

    return (0, _preact.h)(
      'div',
      { className: 'vop-titlebar' },
      (0, _preact.h)(
        'span',
        { className: 'vop-titlebar-title' },
        title
      ),
      (0, _preact.h)(
        'span',
        { className: 'vop-titlebar-description' },
        description
      )
    );
  };

  return UITitleBar;
}(_preact.Component);

exports.default = UITitleBar;

/***/ }),

/***/ "./src/ui/js/components/ui_tooltip.js":
/*!********************************************!*\
  !*** ./src/ui/js/components/ui_tooltip.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Functionality:
// 1. show tooltip thumbnail;
// 2. show current duration;

// Needs:
// 1. player instance;
// 2. player current position;

var UIToolTip = function (_Component) {
  _inherits(UIToolTip, _Component);

  function UIToolTip(props) {
    _classCallCheck(this, UIToolTip);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;
    return _this;
  }

  UIToolTip.prototype.componentDidMount = function componentDidMount(e) {
    this.vopTooltip = document.querySelector('.vop-tooltip');
    this.vopTooltipBg = document.querySelector('.vop-tooltip-bg');
    this.vopTooltipText = document.querySelector('.vop-tooltip-text');

    // UI Events
    this.onProgressBarMouseMove_ = this.onProgressBarMouseMove.bind(this);
    this.onProgressBarMouseLeave_ = this.onProgressBarMouseLeave.bind(this);
    this.evEmitter.on(_events2.default.PROGRESSBAR_MOUSEMOVE, this.onProgressBarMouseMove_);
    this.evEmitter.on(_events2.default.PROGRESSBAR_MOUSELEAVE, this.onProgressBarMouseLeave_);
  };

  UIToolTip.prototype.componentWillUnmount = function componentWillUnmount() {
    this.evEmitter.off(_events2.default.PROGRESSBAR_MOUSEMOVE, this.onProgressBarMouseMove_);
    this.evEmitter.off(_events2.default.PROGRESSBAR_MOUSELEAVE, this.onProgressBarMouseLeave_);
  };

  UIToolTip.prototype.render = function render() {
    //myPrintLog('UIToolTip, render');

    return (0, _preact.h)(
      'div',
      { className: 'vop-tooltip' },
      (0, _preact.h)('div', { className: 'vop-tooltip-bg' }),
      (0, _preact.h)(
        'div',
        { className: 'vop-tooltip-text-wrapper' },
        (0, _preact.h)('span', { className: 'vop-tooltip-text' })
      )
    );
  };

  UIToolTip.prototype.updateTooltipUI = function updateTooltipUI(show, currMovePos) {
    if (!show) {
      this.vopTooltip.style.display = 'none';
      return;
    }

    if (!this.vopProgressBar) {
      this.vopProgressBar = document.querySelector('.vop-progress-bar');
    }

    var thumbnail = this.player.getThumbnail(currMovePos);

    function getTooltipOffsetX(currMovePos, tooltipWidth) {
      // part - input
      // bounding client rect can return the progress bar's rect relative to current page.
      var rect = this.vopProgressBar.getBoundingClientRect();
      var leftMin = 12 + this.vopProgressBar.offsetLeft;
      var rightMax = leftMin + rect.width;

      var duration = this.player.getDuration();

      var currPosWidth = currMovePos / duration * rect.width;
      var tooltipLeft_RelativeToVideo = leftMin + currPosWidth - tooltipWidth / 2;
      var tooltipRight_RelativeToVideo = leftMin + currPosWidth + tooltipWidth / 2;

      if (tooltipLeft_RelativeToVideo < leftMin) {
        tooltipLeft_RelativeToVideo = leftMin;
      } else if (tooltipRight_RelativeToVideo > rightMax) {
        tooltipLeft_RelativeToVideo = rightMax - tooltipWidth;
      }

      //myPrintLog('tooltipLeft_RelativeToVideo: ' + tooltipLeft_RelativeToVideo);

      return tooltipLeft_RelativeToVideo;
    }

    if (thumbnail) {
      _ui_tools2.default.addClass(this.vopTooltip, 'vop-tooltip-preview');
      //myPrintLog('thumbnail info: ', thumbnail);
      var isSprite = thumbnail.data.w && thumbnail.data.h;
      if (isSprite) {
        this.vopTooltipBg.style.width = thumbnail.data.w.toString() + 'px';
        this.vopTooltipBg.style.height = thumbnail.data.h.toString() + 'px';
        this.vopTooltipBg.style.background = 'url(' + thumbnail.data.url + ')' + ' -' + thumbnail.data.x.toString() + 'px' + ' -' + thumbnail.data.y.toString() + 'px';
      } else {
        this.vopTooltipBg.style.width = '158px';
        this.vopTooltipBg.style.height = '90px';
        this.vopTooltipBg.style.background = 'url(' + thumbnail.data.url + ') no-repeat';
        this.vopTooltipBg.style.backgroundSize = '100% 100%';
      }
    } else {
      _ui_tools2.default.removeClass(this.vopTooltip, 'vop-tooltip-preview');
    }

    // update tooltip offset
    var strTime = oldmtn.CommonUtils.timeToString(currMovePos);
    this.vopTooltipText.innerText = strTime;

    // calculate metrics first
    // A very large offset to hide tooltip.
    this.vopTooltip.style.left = '10000px';
    this.vopTooltip.style.display = 'block';

    // set the correct offset of tooltip.
    var offsetX = getTooltipOffsetX.call(this, currMovePos, this.vopTooltip.clientWidth);
    this.vopTooltip.style.left = offsetX.toString() + 'px';
  };

  UIToolTip.prototype.onProgressBarMouseMove = function onProgressBarMouseMove(e) {
    this.updateTooltipUI(true, e.movePos);
  };

  UIToolTip.prototype.onProgressBarMouseLeave = function onProgressBarMouseLeave() {
    this.updateTooltipUI(false);
  };

  return UIToolTip;
}(_preact.Component);

exports.default = UIToolTip;

/***/ }),

/***/ "./src/ui/js/components/ui_tvnoise_canvas.js":
/*!***************************************************!*\
  !*** ./src/ui/js/components/ui_tvnoise_canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UITvNoiseCanvas = function () {
    function UITvNoiseCanvas(props) {
        _classCallCheck(this, UITvNoiseCanvas);

        this.props = props;

        //
        this.canvasElement = this.props.element;
        this.canvasContext;
        this.canvasWidth;
        this.canvasHeight;
        this.interferenceHeight = 50;
        this.lastFrameUpdate = 0;
        this.frameInterval = 60;
        this.useAnimationFrame = !!window.requestAnimationFrame;
        this.noiseAnimationWindowPos;
        this.frameUpdateHandlerId;

        this.renderFrame_ = this.renderFrame.bind(this);
    }

    UITvNoiseCanvas.prototype.start = function start(v) {
        this.canvasWidth = v.width;
        this.canvasHeight = v.height;

        this.canvasContext = this.canvasElement.getContext('2d');
        this.noiseAnimationWindowPos = -this.canvasHeight;
        this.lastFrameUpdate = 0;

        this.canvasElement.style.width = this.canvasWidth.toString() + 'px';
        this.canvasElement.style.height = this.canvasHeight.toString() + 'px';

        this.renderFrame_();
    };

    UITvNoiseCanvas.prototype.stop = function stop() {
        if (this.useAnimationFrame) {
            cancelAnimationFrame(this.frameUpdateHandlerId);
        } else {
            clearTimeout(this.frameUpdateHandlerId);
        }
    };

    UITvNoiseCanvas.prototype.renderFrame = function renderFrame() {
        // This code has been copied from the player controls.js and simplified

        if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {
            // It's too early to render the next frame
            this.scheduleNextRender();
            return;
        }

        var currentPixelOffset = void 0;
        // let this.canvasWidth = this.canvasWidth;
        // let this.canvasHeight = this.canvasHeight;

        // Create texture
        var noiseImage = this.canvasContext.createImageData(this.canvasWidth, this.canvasHeight);

        // Fill texture with noise
        for (var y = 0; y < this.canvasHeight; y++) {
            for (var x = 0; x < this.canvasWidth; x++) {
                currentPixelOffset = this.canvasWidth * y * 4 + x * 4;
                noiseImage.data[currentPixelOffset] = Math.random() * 255;
                if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {
                    noiseImage.data[currentPixelOffset] *= 0.85;
                }
                noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];
                noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];
                noiseImage.data[currentPixelOffset + 3] = 50;
            }
        }

        // Put texture onto canvas
        this.canvasContext.putImageData(noiseImage, 0, 0);

        this.lastFrameUpdate = new Date().getTime();
        this.noiseAnimationWindowPos += 0;
        if (this.noiseAnimationWindowPos > this.canvasHeight) {
            this.noiseAnimationWindowPos = -this.canvasHeight;
        }

        this.scheduleNextRender();
    };

    UITvNoiseCanvas.prototype.scheduleNextRender = function scheduleNextRender() {
        if (this.useAnimationFrame) {
            this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame_);
        } else {
            this.frameUpdateHandlerId = setTimeout(this.renderFrame_, this.frameInterval);
        }
    };

    return UITvNoiseCanvas;
}();

;

exports.default = UITvNoiseCanvas;

/***/ }),

/***/ "./src/ui/js/components/ui_volume_bar.js":
/*!***********************************************!*\
  !*** ./src/ui/js/components/ui_volume_bar.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _preact2 = _interopRequireDefault(_preact);

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIVolumeBar = function (_Preact$Component) {
  _inherits(UIVolumeBar, _Preact$Component);

  function UIVolumeBar(props) {
    _classCallCheck(this, UIVolumeBar);

    var _this = _possibleConstructorReturn(this, _Preact$Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;

    //
    _this.colorList_volume = ['#ccc', 'rgba(192,192,192,0.3)'];
    _this.vopVolumeSliderWidth = 52;
    _this.vopVolumeSliderHandleWidth = 10;
    return _this;
  }

  UIVolumeBar.prototype.componentDidMount = function componentDidMount() {
    this.vopVolumeSlider = document.querySelector('.vop-volume-slider');
    this.vopVolumeSliderHandle = document.querySelector('.vop-volume-slider-handle');

    this.vopVolumeButton = document.querySelector('.vop-volume-button');

    //
    this.onMediaVolumeChanged = this.onMediaVolumeChanged.bind(this);
    this.player.on(oldmtn.Events.MEDIA_VOLUME_CHANGED, this.onMediaVolumeChanged);
    this.player.on(oldmtn.Events.AD_VOLUME_CHANGED, this.onMediaVolumeChanged);
  };

  UIVolumeBar.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.MEDIA_VOLUME_CHANGED, this.onMediaVolumeChanged);
    this.player.off(oldmtn.Events.AD_VOLUME_CHANGED, this.onMediaVolumeChanged);
  };

  UIVolumeBar.prototype.render = function render() {
    var info = this.getVolumeInfo();
    var background = _ui_tools2.default.genGradientColor(info.uiVolumeList, this.colorList_volume);
    var left = info.uiVolumeHandleLeft;

    return (0, _preact.h)(
      'div',
      { className: 'vop-volume-panel', onMouseMove: this.onVolumeBarMouseMove.bind(this),
        style: { display: 'inline-block' } },
      (0, _preact.h)(
        'div',
        { className: 'vop-volume-slider', style: { background: background },
          onMouseDown: this.onVolumeSliderMouseDown.bind(this) },
        (0, _preact.h)('div', { className: 'vop-volume-slider-handle', style: { left: left } })
      )
    );
  };

  UIVolumeBar.prototype.getVolumeInfo = function getVolumeInfo() {
    var muted = this.player.isMuted();
    var volume = this.player.getVolume();

    // Process
    var uiVolumeList = void 0;
    var uiVolumeHandleLeft = void 0;

    if (volume === 0 || muted) {
      uiVolumeList = [0, 1];
      uiVolumeHandleLeft = '0px';
    } else {
      uiVolumeList = [volume, 1];

      var vLeft = volume / 1 * this.vopVolumeSliderWidth;
      if (vLeft + this.vopVolumeSliderHandleWidth > this.vopVolumeSliderWidth) {
        vLeft = this.vopVolumeSliderWidth - this.vopVolumeSliderHandleWidth;
      }

      uiVolumeHandleLeft = vLeft.toString() + 'px';
    }

    return {
      uiVolumeList: uiVolumeList,
      uiVolumeHandleLeft: uiVolumeHandleLeft
    };
  };

  UIVolumeBar.prototype.onMediaVolumeChanged = function onMediaVolumeChanged() {
    var info = this.getVolumeInfo();

    // update volume slider background
    this.vopVolumeSlider.style.background = _ui_tools2.default.genGradientColor(info.uiVolumeList, this.colorList_volume);
    // update volume slider handle
    this.vopVolumeSliderHandle.style.left = info.uiVolumeHandleLeft;
  };

  UIVolumeBar.prototype.onVolumeSliderMouseDown = function onVolumeSliderMouseDown(e) {
    myPrintLog('+onVolumeSliderMouseDown');
    this.captureVolumeSliderMouseEvents();
    e.preventDefault();
    e.stopPropagation();

    this.flagVolumeSliderMousedown = true;

    this.docVolumeSliderMousemove(e);

    this.main.onVolumeBarMouseDown(e);
  };

  UIVolumeBar.prototype.docVolumeSliderMousemove = function docVolumeSliderMousemove(e) {
    var valueVolumeMovePosition = this.getVolumeMovePosition(e);

    var muted = this.player.isMuted();
    var volume = valueVolumeMovePosition;
    if (volume === 0) {
      // do nothing
    } else {
      if (muted === true) {
        this.player.unmute();
      }

      muted = false;
    }

    this.player.setVolume(valueVolumeMovePosition);
  };

  UIVolumeBar.prototype.docVolumeSliderMouseup = function docVolumeSliderMouseup(e) {
    myPrintLog('+docVolumeSliderMouseup');
    this.releaseVolumeSliderMouseEvents();
    e.preventDefault();

    this.flagVolumeSliderMousedown = false;

    this.main.onVolumeBarMouseUp(e);
  };

  UIVolumeBar.prototype.captureVolumeSliderMouseEvents = function captureVolumeSliderMouseEvents() {
    this.newVolumeSliderMousemove = this.docVolumeSliderMousemove.bind(this);
    this.newVolumeSliderMouseup = this.docVolumeSliderMouseup.bind(this);

    document.addEventListener('mousemove', this.newVolumeSliderMousemove, true);
    document.addEventListener('mouseup', this.newVolumeSliderMouseup, true);
  };

  UIVolumeBar.prototype.releaseVolumeSliderMouseEvents = function releaseVolumeSliderMouseEvents() {
    document.removeEventListener('mousemove', this.newVolumeSliderMousemove, true);
    document.removeEventListener('mouseup', this.newVolumeSliderMouseup, true);
  };

  UIVolumeBar.prototype.getVolumeMovePosition = function getVolumeMovePosition(e) {
    // part - input
    var rect = this.vopVolumeSlider.getBoundingClientRect();

    // part - logic process
    var offsetX = e.clientX - rect.left;
    if (offsetX < 0) {
      offsetX = 0;
    } else if (offsetX + this.vopVolumeSliderHandleWidth > rect.width) {
      offsetX = rect.width;
    }

    // update time progress scrubber button
    var valueVolumeMovePosition = offsetX / rect.width * 1.0;
    return valueVolumeMovePosition;
  };

  UIVolumeBar.prototype.onVolumeBarMouseMove = function onVolumeBarMouseMove(e) {
    this.main.onControlMouseMove(e);
  };

  return UIVolumeBar;
}(_preact2.default.Component);

exports.default = UIVolumeBar;

/***/ }),

/***/ "./src/ui/js/components/ui_volume_toggle_button.js":
/*!*********************************************************!*\
  !*** ./src/ui/js/components/ui_volume_toggle_button.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_tools = __webpack_require__(/*! ../ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIVolumeToggleButton = function (_Component) {
  _inherits(UIVolumeToggleButton, _Component);

  function UIVolumeToggleButton(props) {
    _classCallCheck(this, UIVolumeToggleButton);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;

    _this.vopVolumeBtnStyle = 'icon-up';
    return _this;
  }

  UIVolumeToggleButton.prototype.componentDidMount = function componentDidMount() {
    this.vopVolumeBtn = document.querySelector('.vop-volume-button');

    //
    this.onMediaVolumeChanged = this.onMediaVolumeChanged.bind(this);
    this.player.on(oldmtn.Events.MEDIA_VOLUME_CHANGED, this.onMediaVolumeChanged);
    this.player.on(oldmtn.Events.AD_VOLUME_CHANGED, this.onMediaVolumeChanged);
  };

  UIVolumeToggleButton.prototype.componentWillUnmount = function componentWillUnmount() {
    this.player.off(oldmtn.Events.MEDIA_VOLUME_CHANGED, this.onMediaVolumeChanged);
    this.player.off(oldmtn.Events.AD_VOLUME_CHANGED, this.onMediaVolumeChanged);
  };

  UIVolumeToggleButton.prototype.render = function render() {
    this.vopVolumeBtnStyle = this.getNewVolumeBtnStyle();

    return (0, _preact.h)('button', { className: 'vop-button vop-volume-button' + ' ' + this.vopVolumeBtnStyle, title: 'mute',
      onClick: this.onUICmdVolume.bind(this),
      onMouseMove: this.onControlMouseMove.bind(this) });
  };

  UIVolumeToggleButton.prototype.getNewVolumeBtnStyle = function getNewVolumeBtnStyle() {
    var newVolumeBtnStyle = '';

    var muted = this.player.isMuted();
    var volume = this.player.getVolume();
    if (volume === 0 || muted) {
      newVolumeBtnStyle = 'icon-off';
    } else {
      if (volume >= 0.5) {
        newVolumeBtnStyle = 'icon-up';
      } else {
        newVolumeBtnStyle = 'icon-down';
      }
    }

    return newVolumeBtnStyle;
  };

  UIVolumeToggleButton.prototype.onMediaVolumeChanged = function onMediaVolumeChanged() {
    var oldVolumeBtnStyle = this.vopVolumeBtnStyle;
    this.vopVolumeBtnStyle = this.getNewVolumeBtnStyle();

    // update volume button
    _ui_tools2.default.removeClass(this.vopVolumeBtn, oldVolumeBtnStyle);
    _ui_tools2.default.addClass(this.vopVolumeBtn, this.vopVolumeBtnStyle);
  };

  UIVolumeToggleButton.prototype.onUICmdVolume = function onUICmdVolume() {
    var muted = this.player.isMuted();
    var volume = this.player.getVolume();

    if (volume === 0) {
      if (muted) {
        this.player.unmute();
        muted = false;
      }

      // If the this.player is muted, and volume is 0,
      // in this situation, we will restore volume to 0.2
      volume = 0.1;
      this.player.setVolume(volume);
    } else {
      if (muted) {
        this.player.unmute();
        muted = false;
      } else {
        this.player.mute();
        muted = true;
      }
    }
  };

  UIVolumeToggleButton.prototype.onControlMouseMove = function onControlMouseMove(e) {
    this.main.onControlMouseMove(e);
  };

  return UIVolumeToggleButton;
}(_preact.Component);

exports.default = UIVolumeToggleButton;

/***/ }),

/***/ "./src/ui/js/components/ui_xspeed_menu.js":
/*!************************************************!*\
  !*** ./src/ui/js/components/ui_xspeed_menu.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _events = __webpack_require__(/*! ../events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _id = __webpack_require__(/*! ../id */ "./src/ui/js/id.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIXSpeedMenu = function (_Component) {
  _inherits(UIXSpeedMenu, _Component);

  function UIXSpeedMenu(props) {
    _classCallCheck(this, UIXSpeedMenu);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.main = _this.props.main;
    _this.player = _this.main.player;
    _this.evEmitter = _this.main.evEmitter;

    _this.onMenuBackClick_ = _this.onMenuBackClick.bind(_this);
    _this.onMenuItemClick_ = _this.onMenuItemClick.bind(_this);
    _this.onMenuItemBlur_ = _this.onMenuItemBlur.bind(_this);

    _this.onPopupMenuChange = _this.onPopupMenuChange.bind(_this);
    _this.evEmitter.on(_events2.default.POPUPMENU_CHANGE, _this.onPopupMenuChange);

    _this.xspeedData = {
      currSpeedId: '3',
      xspeedList: [{
        id: '1',
        value: 0.25
      }, {
        id: '2',
        value: 0.5
      }, {
        id: '3',
        value: 1.0
      }, {
        id: '4',
        value: 1.5
      }, {
        id: '5',
        value: 2.0
      }]
    };
    _this.state = {
      xspeedData: _this.xspeedData
    };
    return _this;
  }

  UIXSpeedMenu.prototype.componentDidMount = function componentDidMount() {
    this.vopXSpeedMenu = document.querySelector('.vop-xspeed-menu');
  };

  UIXSpeedMenu.prototype.render = function render() {
    var _this2 = this;

    console.log('UIXSpeedMenu, render');

    var xspeedData = this.state.xspeedData;


    var menuitems = xspeedData.xspeedList.map(function (item, index) {
      return (0, _preact.h)(
        'div',
        { key: index, className: 'vop-menuitem', role: 'menuitemradio',
          'aria-checked': xspeedData.currSpeedId === item.id,
          'data-id': item.id, onClick: _this2.onMenuItemClick_,
          tabIndex: '0', onBlur: _this2.onMenuItemBlur_ },
        (0, _preact.h)(
          'div',
          { className: 'vop-menuitem-label' },
          (0, _preact.h)(
            'span',
            null,
            item.value
          )
        )
      );
    });

    return (0, _preact.h)(
      'div',
      { className: 'vop-xspeed-menu', style: 'display:none;' },
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-header' },
        (0, _preact.h)(
          'button',
          { className: 'vop-panel-title', onClick: this.onMenuBackClick_ },
          'XSpeed'
        )
      ),
      (0, _preact.h)(
        'div',
        { className: 'vop-panel-menu' },
        menuitems
      )
    );
  };

  UIXSpeedMenu.prototype.onMenuBackClick = function onMenuBackClick(e) {
    this.main.settingMenuUIData.currMenu = 'settings_menu';
    this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
      menu: this.main.settingMenuUIData.currMenu
    });
  };

  UIXSpeedMenu.prototype.onMenuItemClick = function onMenuItemClick(e) {
    myPrintLog('+onXSpeedMenuItemClick');
    var nextFocus = e.currentTarget;

    this.xspeedData.currSpeedId = nextFocus.dataset.id;
    this.setState({
      xspeedData: this.xspeedData
    });

    // Change Player X-Speed
    function getXSpeedValue(id) {
      var value = '';
      for (var i = 0; i < this.xspeedData.xspeedList.length; i++) {
        var item = this.xspeedData.xspeedList[i];
        if (item.id === id) {
          value = item.value;
          break;
        }
      }

      return value;
    }
    var value = getXSpeedValue.call(this, this.xspeedData.currSpeedId);
    this.player.setAudioPlaybackSpeed(parseFloat(value));

    // old
    //this.main.onXSpeedMenuItemClick(e);
  };

  UIXSpeedMenu.prototype.onMenuItemBlur = function onMenuItemBlur(e) {
    if (this.main.settingMenuUIData.currMenu !== 'xspeed_menu') {
      return;
    }
    this.main.onXSpeedMenuItemBlur(e);
  };

  UIXSpeedMenu.prototype.onPopupMenuChange = function onPopupMenuChange(e) {
    if (e.menu === 'xspeed_menu') {
      this.vopXSpeedMenu.style.display = 'block';
      var v = this.vopXSpeedMenu.querySelector('.vop-menuitem');
      if (v) {
        v.focus();
      }
    } else {
      this.vopXSpeedMenu.style.display = 'none';
    }
  };

  return UIXSpeedMenu;
}(_preact.Component);

exports.default = UIXSpeedMenu;

/***/ }),

/***/ "./src/ui/js/consts.js":
/*!*****************************!*\
  !*** ./src/ui/js/consts.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// Defines reference constant variable.
var CONSTS = {
  BOTTOM_BAR_HEIGHT: 41
};

exports.default = CONSTS;

/***/ }),

/***/ "./src/ui/js/events.js":
/*!*****************************!*\
  !*** ./src/ui/js/events.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

// Defines UI reference events.
var Events = {
  PROGRESSBAR_MOUSEMOVE: 'progressbar_mousemove',
  PROGRESSBAR_MOUSELEAVE: 'progressbar_mouseleave',

  POPUPMENU_CHANGE: 'popupmenu_change',
  FCC_PROPERTY_VALUE_CHANGE: 'fcc_property_value_change',

  AUTOHIDE_CHANGE: 'autohide_change'
};

exports.default = Events;

/***/ }),

/***/ "./src/ui/js/id.js":
/*!*************************!*\
  !*** ./src/ui/js/id.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;


// Defines components id here.
var ID = {
  SUBTITLES_BUTTON: 'subtitles_button',
  SETTINGS_BUTTON: 'settings_button',

  // Settings Menu Item ID
  MENUITEM_QUALITY: '1',
  MENUITEM_AUDIO_TRACK: '2',
  MENUITEM_FCC: '3',
  MENUITEM_XSPEED: '4'
};

exports.default = ID;

/***/ }),

/***/ "./src/ui/js/ui_engine.js":
/*!********************************!*\
  !*** ./src/ui/js/ui_engine.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _ui_skin_youtube = __webpack_require__(/*! ./ui_skin_youtube */ "./src/ui/js/ui_skin_youtube.js");

var _ui_skin_youtube2 = _interopRequireDefault(_ui_skin_youtube);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

window.myPrintLog = function (msg, level) {
  if (printLog) {
    printLog(msg, level);
  }
};

var UIEngine = function () {
  function UIEngine(player) {
    _classCallCheck(this, UIEngine);

    this.player = player;
    this.h5VideoPlayer_ = document.querySelector('.html5-video-player');
  }

  UIEngine.prototype.installSkin = function installSkin() {
    this.skinContainerYb_ = document.querySelector('.vop-skin-default');
    if (!this.skinContainerYb_) {
      this.skinContainerYb_ = document.createElement('div');
      this.skinContainerYb_.setAttribute('class', 'vop-skin-default');
      this.h5VideoPlayer_.appendChild(this.skinContainerYb_);
    }

    var root = void 0;
    this.uiPlayer_ = (0, _preact.render)((0, _preact.h)(_ui_skin_youtube2.default, { player: this.player, cbLog: this.cbLog }), this.skinContainerYb_, root);
  };

  UIEngine.prototype.uninstallSkin = function uninstallSkin() {
    (0, _preact.render)(null, this.skinContainerYb_, this.uiPlayer_);
  };

  return UIEngine;
}();

exports.default = UIEngine;

/***/ }),

/***/ "./src/ui/js/ui_skin_youtube.js":
/*!**************************************!*\
  !*** ./src/ui/js/ui_skin_youtube.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

var _resizeSensor = __webpack_require__(/*! resize-sensor */ "./node_modules/resize-sensor/ResizeSensor.min.js");

var _resizeSensor2 = _interopRequireDefault(_resizeSensor);

__webpack_require__(/*! ../css/ui_skin_youtube.scss */ "./src/ui/css/ui_skin_youtube.scss");

var _ui_tools = __webpack_require__(/*! ./ui_tools */ "./src/ui/js/ui_tools.js");

var _ui_tools2 = _interopRequireDefault(_ui_tools);

var _events = __webpack_require__(/*! ./events */ "./src/ui/js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../../core/errors */ "./src/core/errors.js");

var _ui_title_bar = __webpack_require__(/*! ./components/ui_title_bar */ "./src/ui/js/components/ui_title_bar.js");

var _ui_title_bar2 = _interopRequireDefault(_ui_title_bar);

var _ui_popup_menu = __webpack_require__(/*! ./components/ui_popup_menu */ "./src/ui/js/components/ui_popup_menu.js");

var _ui_popup_menu2 = _interopRequireDefault(_ui_popup_menu);

var _ui_gradient_bottom = __webpack_require__(/*! ./components/ui_gradient_bottom */ "./src/ui/js/components/ui_gradient_bottom.js");

var _ui_gradient_bottom2 = _interopRequireDefault(_ui_gradient_bottom);

var _ui_bottom_bar = __webpack_require__(/*! ./components/ui_bottom_bar */ "./src/ui/js/components/ui_bottom_bar.js");

var _ui_bottom_bar2 = _interopRequireDefault(_ui_bottom_bar);

var _ui_caption_overlay = __webpack_require__(/*! ./components/ui_caption_overlay */ "./src/ui/js/components/ui_caption_overlay.js");

var _ui_caption_overlay2 = _interopRequireDefault(_ui_caption_overlay);

var _ui_hugebutton_overlay = __webpack_require__(/*! ./components/ui_hugebutton_overlay */ "./src/ui/js/components/ui_hugebutton_overlay.js");

var _ui_hugebutton_overlay2 = _interopRequireDefault(_ui_hugebutton_overlay);

var _ui_buffering_overlay = __webpack_require__(/*! ./components/ui_buffering_overlay */ "./src/ui/js/components/ui_buffering_overlay.js");

var _ui_buffering_overlay2 = _interopRequireDefault(_ui_buffering_overlay);

var _ui_logo_overlay = __webpack_require__(/*! ./components/ui_logo_overlay */ "./src/ui/js/components/ui_logo_overlay.js");

var _ui_logo_overlay2 = _interopRequireDefault(_ui_logo_overlay);

var _ui_play_overlay = __webpack_require__(/*! ./components/ui_play_overlay */ "./src/ui/js/components/ui_play_overlay.js");

var _ui_play_overlay2 = _interopRequireDefault(_ui_play_overlay);

var _ui_error_msg_overlay = __webpack_require__(/*! ./components/ui_error_msg_overlay */ "./src/ui/js/components/ui_error_msg_overlay.js");

var _ui_error_msg_overlay2 = _interopRequireDefault(_ui_error_msg_overlay);

var _ui_chromecast_overlay = __webpack_require__(/*! ./components/ui_chromecast_overlay */ "./src/ui/js/components/ui_chromecast_overlay.js");

var _ui_chromecast_overlay2 = _interopRequireDefault(_ui_chromecast_overlay);

var _ui_tooltip = __webpack_require__(/*! ./components/ui_tooltip */ "./src/ui/js/components/ui_tooltip.js");

var _ui_tooltip2 = _interopRequireDefault(_ui_tooltip);

var _ui_ads_container = __webpack_require__(/*! ./components/ui_ads_container */ "./src/ui/js/components/ui_ads_container.js");

var _ui_ads_container2 = _interopRequireDefault(_ui_ads_container);

var _events3 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1. Render all components from React.
// 2. Just change css in 'html5-player-video' to control components visiblity.
// 3. 
var UISkinYoutube = function (_Component) {
  _inherits(UISkinYoutube, _Component);

  function UISkinYoutube(props) {
    _classCallCheck(this, UISkinYoutube);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.initVariable();
    _this.player = props.player;
    _this.evEmitter = new _events4.default();

    _this.adsContainer = new _ui_ads_container2.default({
      main: _this
    });
    return _this;
  }

  UISkinYoutube.prototype.componentWillMount = function componentWillMount() {
    myPrintLog('UISkinYoutube, +componentWillMount');
  };

  UISkinYoutube.prototype.componentDidMount = function componentDidMount() {
    myPrintLog('UISkinYoutube, +componentDidMount');

    this.initUIElements();
    this.initUIElementsStyles();
    this.initUIEventListeners();
    this.initPlayerListeners();

    this.syncPlayerStateToUI();
  };

  UISkinYoutube.prototype.componentWillUnmount = function componentWillUnmount() {
    myPrintLog('+componentWillUnmount');
    this.uninitUIEventListeners();
    this.uninitPlayerListeners();

    this.removeAutohideAction();
    // Since we want to use ads-container to show ad, if we add 'controls' attribute to video element,
    // it the video control will never shown, because ads-container is on top of it.
    //this.vopVideo.setAttribute('controls', 'true');
  };

  UISkinYoutube.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'vop-skin-youtube' },
      (0, _preact.h)(_ui_chromecast_overlay2.default, { main: this }),
      (0, _preact.h)(_ui_title_bar2.default, { main: this }),
      (0, _preact.h)(_ui_logo_overlay2.default, null),
      (0, _preact.h)(_ui_caption_overlay2.default, { main: this }),
      (0, _preact.h)(_ui_popup_menu2.default, { main: this }),
      (0, _preact.h)(_ui_tooltip2.default, { main: this }),
      (0, _preact.h)(_ui_gradient_bottom2.default, { main: this }),
      (0, _preact.h)(_ui_bottom_bar2.default, { main: this }),
      (0, _preact.h)(_ui_buffering_overlay2.default, { main: this }),
      (0, _preact.h)(_ui_hugebutton_overlay2.default, { main: this }),
      (0, _preact.h)(_ui_play_overlay2.default, { main: this }),
      (0, _preact.h)(_ui_error_msg_overlay2.default, { main: this })
    );
  };

  ///////////////////////////////////////////////////////////////////////


  UISkinYoutube.prototype.initVariable = function initVariable() {
    this.player = null;
    this.playerState = '';
    this.ratio = 0.5625;

    // UI Controls
    this.vopPlayer = null;
    this.vopBottomBar = null;

    // UI Data
    this.metaWidth;
    this.metaHeight;

    // flag
    this.timerHideControlBar;

    // menu context
    this.settingMenuUIData = {
      currMenu: 'none', // none, settings_menu, quality_menu, audio_track_menu, fcc_menu, fcc_property_menu, subtitles_menu, xspeed_menu

      // main setting menu
      // quality settings menu
      currQualityId: '2',

      // audio track settings menu
      currAudioTrackId: '1',

      // FCC settings menu
      currFccPropertyName: 'background_color', // only valid when currMenu is 'fcc_property_menu'.
      isEnableFCC: true,

      // X-Speed
      currSpeedId: '3'
    };

    // reference variable of ad
    this.flagAdStarted = false;
    this.flagIsLinearAd = false;

    //
    this.onStateChange = this.onStateChange.bind(this);

    this.onMediaLoadedMetaData = this.onMediaLoadedMetaData.bind(this);

    this.onLog = this.onLog.bind(this);

    // ad callback event
    this.onAdStarted = this.onAdStarted.bind(this);
    this.onAdComplete = this.onAdComplete.bind(this);
    this.onAdCompanions = this.onAdCompanions.bind(this);

    //
    this.onResizeSensorCb = this.onResizeSensorCb.bind(this);
  };

  // Title: init part


  UISkinYoutube.prototype.initUIElements = function initUIElements() {
    this.playerContainer = document.getElementById('player-container');
    this.vopPlayer = document.querySelector('.html5-video-player');

    this.vopBottomBar = document.querySelector('.vop-bottom-bar');

    this.vopCaptionOverlay = document.querySelector('.vop-caption-overlay');

    //
    this.vopVideo = document.querySelector('.vop-video');
    this.vopVideo.removeAttribute('controls');
  };

  UISkinYoutube.prototype.initUIElementsStyles = function initUIElementsStyles() {
    // Can add ui style config here.
    //this.vopPlayProgress.style.backgroundColor = '#FA12FF';
  };

  UISkinYoutube.prototype.initUIEventListeners = function initUIEventListeners() {
    this.onPlayerMouseEnter = this.onPlayerMouseEnter.bind(this);
    this.onPlayerMouseLeave = this.onPlayerMouseLeave.bind(this);
    this.onPlayerMouseMove = this.onPlayerMouseMove.bind(this);
    this.onPlayerMouseDown = this.onPlayerMouseDown.bind(this);
    this.onPlayerMouseUp = this.onPlayerMouseUp.bind(this);

    this.vopPlayer.addEventListener('mouseenter', this.onPlayerMouseEnter);
    this.vopPlayer.addEventListener('mouseleave', this.onPlayerMouseLeave);
    this.vopPlayer.addEventListener('mousemove', this.onPlayerMouseMove);
    this.vopPlayer.addEventListener('mousedown', this.onPlayerMouseDown);
    this.vopPlayer.addEventListener('mouseup', this.onPlayerMouseUp);

    // resize listener
    //if (window.ResizeObserver) {
    if (false) { var ro, onPlayerSize; } else {
      this.playerResizeSensor_ = new _resizeSensor2.default(this.playerContainer, this.onResizeSensorCb);
    }
  };

  UISkinYoutube.prototype.uninitUIEventListeners = function uninitUIEventListeners() {
    this.vopPlayer.removeEventListener('mouseenter', this.onPlayerMouseEnter);
    this.vopPlayer.removeEventListener('mouseleave', this.onPlayerMouseLeave);
    this.vopPlayer.removeEventListener('mousemove', this.onPlayerMouseMove);
    this.vopPlayer.removeEventListener('mousedown', this.onPlayerMouseDown);
    this.vopPlayer.removeEventListener('mouseup', this.onPlayerMouseUp);

    this.playerResizeSensor_ = null;
  };

  UISkinYoutube.prototype.initPlayerListeners = function initPlayerListeners() {
    this.player.on(oldmtn.Events.STATE_CHANGE, this.onStateChange);

    this.player.on(oldmtn.Events.MEDIA_LOADEDMETADATA, this.onMediaLoadedMetaData);

    this.player.on(oldmtn.Events.LOG, this.onLog);
    this.player.on(oldmtn.Events.ERROR, this.onError);

    // ad callback event
    this.player.on(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.on(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
    this.player.on(oldmtn.Events.AD_COMPANIONS, this.onAdCompanions);
  };

  UISkinYoutube.prototype.uninitPlayerListeners = function uninitPlayerListeners() {
    this.player.off(oldmtn.Events.STATE_CHANGE, this.onStateChange);

    this.player.off(oldmtn.Events.MEDIA_LOADEDMETADATA, this.onMediaLoadedMetaData);

    // log
    this.player.off(oldmtn.Events.LOG, this.onLog);
    this.player.off(oldmtn.Events.ERROR, this.onError);

    // ad callback event
    this.player.off(oldmtn.Events.AD_STARTED, this.onAdStarted);
    this.player.off(oldmtn.Events.AD_COMPLETE, this.onAdComplete);
    this.player.off(oldmtn.Events.AD_COMPANIONS, this.onAdCompanions);
  };

  UISkinYoutube.prototype.playerOpen = function playerOpen(mediaCfg) {
    this.player.open(mediaCfg);
  };

  UISkinYoutube.prototype.playerClose = function playerClose() {
    myPrintLog('+onBtnClose');
    this.player.close();
    this.updateUIStateMachine('closed');
  };

  UISkinYoutube.prototype.playerRequestAds = function playerRequestAds() {
    this.player.playAd();
  };

  UISkinYoutube.prototype.onBtnInit = function onBtnInit() {
    this.player.init(cfg_);
  };

  UISkinYoutube.prototype.onBtnUninit = function onBtnUninit() {
    this.player.uninit(cfg_);
  };

  ///////////////////////////////////////////////////////////////////////////
  // Title: UI reference functions


  UISkinYoutube.prototype.onResizeSensorCb = function onResizeSensorCb(e) {
    // PlayerContainer's width change, need to update its height
    // and player's metrics.
    var dstWidth = 0;
    var dstHeight = 0;
    if (this.player.isFullscreen()) {
      dstWidth = this.playerContainer.clientWidth;
      dstHeight = this.playerContainer.clientHeight;
    } else {
      if (this.playerContainer.clientWidth > 720) {
        dstWidth = 720;
      } else {
        dstWidth = this.playerContainer.clientWidth;
      }
      dstHeight = dstWidth * this.ratio;
    }

    this.playerContainer.style.height = dstHeight.toString() + 'px';

    this.vopPlayer.style.width = dstWidth.toString() + 'px';
    this.vopPlayer.style.height = dstHeight.toString() + 'px';

    if (this.isPlayerActive()) {
      //h5Player.style.marginLeft = h5Player.style.marginRight = 'auto';
      this.player.resize(dstWidth, dstHeight);

      myPrintLog('ResizeSensor, dstWidth: ' + dstWidth + ', dstHeight: ' + dstHeight);
      var position = this.player.getPosition();
      var duration = this.player.getDuration();
      //this.updateProgressBarUI(position, duration);
    }
  };

  // This function is mainly focus on:
  // 1. Record the player state, and refect it to UI


  UISkinYoutube.prototype.updateUIStateMachine = function updateUIStateMachine(state) {
    myPrintLog('updateUIStateMachine, state: ' + state);

    //
    _ui_tools2.default.removeClass(this.vopPlayer, 'vop-player-' + this.playerState);
    _ui_tools2.default.addClass(this.vopPlayer, 'vop-player-' + state);

    // Update all child components.
    this.playerState = state;

    if (this.playerState === 'opening') {
      _ui_tools2.default.addClass(this.vopPlayer, 'vop-buffering');
    } else if (this.playerState === 'opened') {
      _ui_tools2.default.removeClass(this.vopPlayer, 'vop-buffering');
    }
  };

  ///////////////////////////////////////////////////////////////////////////
  // Title: Tool function


  UISkinYoutube.prototype.updateCaptionOverlay = function updateCaptionOverlay() {
    var adDstHeight = 0;
    var controlBarHeight = 0;
    if (this.flagAdStarted && !this.flagIsLinearAd) {
      adDstHeight = this.vopAdContainer.clientHeight;
      controlBarHeight = this.vopBottomBar.clientHeight;
    } else {
      if (!_ui_tools2.default.hasClass(this.vopPlayer, 'vop-autohide')) {
        controlBarHeight = this.vopBottomBar.clientHeight;
      }
    }

    var height = adDstHeight + controlBarHeight;
    this.vopCaptionOverlay.style.bottom = height.toString() + 'px';
  };

  UISkinYoutube.prototype.addAutohideAction = function addAutohideAction() {
    _ui_tools2.default.addClass(this.vopPlayer, 'vop-autohide');
    this.evEmitter.emit(_events2.default.AUTOHIDE_CHANGE, {
      autohide: true
    });
  };

  UISkinYoutube.prototype.removeAutohideAction = function removeAutohideAction() {
    _ui_tools2.default.removeClass(this.vopPlayer, 'vop-autohide');
    if (this.timerHideControlBar) {
      clearTimeout(this.timerHideControlBar);
      this.timerHideControlBar = null;
    }
    this.evEmitter.emit(_events2.default.AUTOHIDE_CHANGE, {
      autohide: false
    });
  };

  ///////////////////////////////////////////////////////////////////


  UISkinYoutube.prototype.onPlayerMouseEnter = function onPlayerMouseEnter(e) {
    if (this.playerState !== 'playing') {
      return;
    }
    // When mouse enter any elements in 'vop-skin-youtube', it needs to remove the 'vop-autohide' attribute.
    //myPrintLog('+onPlayerMouseEnter, element: ' + e.target.className);
    this.removeAutohideAction();
  };

  UISkinYoutube.prototype.onPlayerMouseMove = function onPlayerMouseMove(e) {
    //let element_name = (e && e.target) ? e.target.className : 'null';
    //myPrintLog('+onPlayerMouseMove, element: ' + element_name);
    if (this.playerState !== 'playing') {
      return;
    }

    this.removeAutohideAction();
    this.timerHideControlBar = setTimeout(function () {
      //myPrintLog('Call onPlayerMouseLeave at timerHideControlBar callback.');
      this.onPlayerMouseLeave();
    }.bind(this), 3000);
  };

  UISkinYoutube.prototype.onPlayerMouseLeave = function onPlayerMouseLeave(e) {
    //myPrintLog('+onPlayerMouseLeave');
    if (this.playerState !== 'playing') {
      return;
    }

    var paused = this.player.isPaused();
    var fullscreen = this.player.isFullscreen();
    if (!paused && !this.progressBarContext && !this.flagVolumeSliderMousedown && !fullscreen) {
      this.addAutohideAction();
    }
  };

  UISkinYoutube.prototype.onPlayerMouseDown = function onPlayerMouseDown(e) {
    //myPrintLog('+onPlayerMouseDown');
    // If playerState is 'opened', let ui_play_overlay components handle play action.
    if (this.playerState === 'opened') {
      return;
    }

    this.flagPlayerMouseDown = true;
  };

  UISkinYoutube.prototype.onPlayerMouseUp = function onPlayerMouseUp(e) {
    //myPrintLog('+onPlayerMouseUp');
    if (this.flagPlayerMouseDown) {
      this.flagPlayerMouseDown = false;
      this.onUICmdPlay();
    }
  };

  // browser & UI callback functions


  UISkinYoutube.prototype.onUICmdPlay = function onUICmdPlay() {
    // Get current play/pause state from UI.
    var currPaused = this.player.isPaused();
    var currEnded = this.player.isEnded();

    var newPaused = void 0;
    // Compute new play/pause state and apply it to player.
    if (currEnded) {
      // call play method when video is ended will trigger 'seeking' event and the target position is 0.
      newPaused = false;
    } else {
      // execute ui cmd
      if (currPaused) {
        newPaused = false;
      } else {
        newPaused = true;
      }
    }

    if (newPaused) {
      this.player.pause();
    } else {
      this.player.play();
    }
  };

  UISkinYoutube.prototype.onVolumeBarMouseDown = function onVolumeBarMouseDown(e) {
    this.flagVolumeSliderMousedown = true;
  };

  UISkinYoutube.prototype.onVolumeBarMouseUp = function onVolumeBarMouseUp(e) {
    this.flagVolumeSliderMousedown = false;

    var pt = {
      x: e.clientX,
      y: e.clientY
    };
    if (_ui_tools2.default.isPtInElement(pt, this.vopPlayer)) {
      if (_ui_tools2.default.isPtInElement(pt, this.vopBottomBar)) {
        // do nothing
        this.removeAutohideAction();
      } else {
        this.onPlayerMouseMove();
      }
    } else {
      this.onPlayerMouseMove();
    }
  };

  UISkinYoutube.prototype.onControlMouseMove = function onControlMouseMove(e) {
    e.stopPropagation();
    this.removeAutohideAction();
  };

  UISkinYoutube.prototype.onBtnManualSchedule = function onBtnManualSchedule() {
    this.player.manualSchedule();
  };

  UISkinYoutube.prototype.onBtnInitAD = function onBtnInitAD() {
    this.player.test();
  };

  UISkinYoutube.prototype.onBtnDelAll = function onBtnDelAll() {
    this.player.dellAll();
  };

  UISkinYoutube.prototype.onBtnStop = function onBtnStop() {
    this.player.close();
    this.player = null;
  };

  ////////////////////////////////////////////////////////////////////////////////////
  // this.player event callback


  UISkinYoutube.prototype.onStateChange = function onStateChange(e) {
    var newState = e.newState;
    this.updateUIStateMachine(newState);
  };

  UISkinYoutube.prototype.onMediaLoadedMetaData = function onMediaLoadedMetaData(e) {
    // update external div's height only.
    this.metaWidth = e.width;
    this.metaHeight = e.height;

    this.ratio = this.metaHeight / this.metaWidth;

    var v = this.playerContainer;
    var dstWidth = v.clientWidth;
    var dstHeight = dstWidth * this.ratio;

    //this.playerContainer.style.width = dstWidth.toString() + 'px';
    this.playerContainer.style.height = dstHeight.toString() + 'px';
    this.vopPlayer.style.width = dstWidth.toString() + 'px';
    this.vopPlayer.style.height = dstHeight.toString() + 'px';
    this.player.resize(dstWidth, dstHeight);
  };

  UISkinYoutube.prototype.onLog = function onLog(e) {
    printLogUI(e.message);
  };

  UISkinYoutube.prototype.onError = function onError(e) {
    if (e.type === _errors.ErrorTypes.LICENSE_ERROR) {
      console.log('--ErrorTypes.LICENSE_ERROR--');
    }
  };

  UISkinYoutube.prototype.onAdStarted = function onAdStarted(e) {
    this.updateUIStateMachine('playing');

    // Hide all popup menu.
    this.settingMenuUIData.currMenu = 'none';
  };

  UISkinYoutube.prototype.onAdComplete = function onAdComplete() {};

  UISkinYoutube.prototype.onAdCompanions = function onAdCompanions(e) {
    var v = document.getElementById('idCompanionAd');
    for (var i = 0; i < e.companions.length; i++) {
      var companion = e.companions[i];
      if (v.clientWidth === companion.width && v.clientHeight === companion.height) {
        v.innerHTML = companion.content;
      }
    }
  };

  /////////////////////////////////////////////////////////////////////////
  // Title: Sub Components Callbacks


  UISkinYoutube.prototype.onQualityMenuItemBlur = function onQualityMenuItemBlur(e) {
    myPrintLog('+onQualityMenuItemBlur');
    var nextFocus = e.relatedTarget;
    if (nextFocus) {
      myPrintLog('className: ' + nextFocus.className);
      if (nextFocus.className.indexOf('vop-panel-title') !== -1 || nextFocus.className.indexOf('vop-menuitem') !== -1 || nextFocus.className.indexOf('vop-settings-button') !== -1) {
        // click on quality menu, do nothing
        // click on settings menu, do nothing, since onUICmdSettings will do it for us.
      } else {
        this.settingMenuUIData.currMenu = 'none';
        this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
          menu: this.settingMenuUIData.currMenu
        });
      }
    } else {
      this.settingMenuUIData.currMenu = 'none';
      this.evEmitter.emit(_events2.default.POPUPMENU_CHANGE, {
        menu: this.settingMenuUIData.currMenu
      });
    }
  };

  UISkinYoutube.prototype.onAudioTrackMenuItemBlur = function onAudioTrackMenuItemBlur(e) {
    this.onQualityMenuItemBlur(e);
  };

  UISkinYoutube.prototype.onFccMenuItemBlur = function onFccMenuItemBlur(e) {
    this.onQualityMenuItemBlur(e);
  };

  UISkinYoutube.prototype.onXSpeedMenuItemBlur = function onXSpeedMenuItemBlur(e) {
    this.onQualityMenuItemBlur(e);
  };

  // When data changed, needs to update UI.

  // When the skin installed, needs to update UI


  UISkinYoutube.prototype.syncPlayerStateToUI = function syncPlayerStateToUI() {
    var state = this.player.getState();
    this.updateUIStateMachine(state);
  };

  UISkinYoutube.prototype.isPlayerActive = function isPlayerActive() {
    var currState = this.player.getState();
    if (this.player && currState !== 'idle' && currState !== 'inited') {
      return true;
    }

    return false;
  };

  return UISkinYoutube;
}(_preact.Component);

exports.default = UISkinYoutube;

/***/ }),

/***/ "./src/ui/js/ui_tools.js":
/*!*******************************!*\
  !*** ./src/ui/js/ui_tools.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var UITools = {};

UITools.enterFullscreen = function (v) {
  // Try to enter fullscreen mode in the browser
  var requestFullscreen = v.requestFullscreen || v.requestFullScreen || v.webkitRequestFullscreen || v.webkitRequestFullScreen || v.mozRequestFullscreen || v.mozRequestFullScreen || v.msRequestFullscreen || v.msRequestFullScreen;

  requestFullscreen.call(v);
};

UITools.leaveFullscreen = function () {
  var cancelFullscreen = document.exitFullscreen || document.exitFullScreen || document.webkitCancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen || document.msExitFullscreen;
  if (cancelFullscreen) {
    cancelFullscreen.call(document);
  }
};

UITools.hasClass = function (elements, cName) {
  return !!elements.className.match(new RegExp('(\\s|^)' + cName + '(\\s|$)'));
};

UITools.addClass = function (elements, cName) {
  if (!UITools.hasClass(elements, cName)) {
    elements.className = (elements.className + ' ' + cName).trim();
  }
};

UITools.removeClass = function (elements, cName) {
  if (UITools.hasClass(elements, cName)) {
    elements.className = elements.className.replace(new RegExp('(\\s|^)' + cName + '(\\s|$)'), ' ').trim();
  }
};

UITools.genGradientColor = function (posList, colorList) {
  var totalRange = posList[posList.length - 1];

  var gradient = ['to right'];
  for (var i = 0; i < posList.length; ++i) {
    var range = posList[i] * 100 / totalRange;

    if (i === 0) {
      gradient.push(colorList[0] + ' 0%');
      gradient.push(colorList[0] + ' ' + range + '%');
    } else {
      var lastRange = posList[i - 1] * 100 / totalRange;
      gradient.push(colorList[i] + ' ' + lastRange + '%');
      gradient.push(colorList[i] + ' ' + range + '%');
    }
  }

  return 'linear-gradient(' + gradient.join(',') + ')';
};

UITools.isPtInElement = function (pt, element) {
  var rect = element.getBoundingClientRect();
  if (rect.left <= pt.x && pt.x <= rect.right && rect.top <= pt.y && pt.y <= rect.bottom) {
    return true;
  } else {
    return false;
  }
};

exports.default = UITools;

/***/ }),

/***/ "./src/ui_basic/css/ui_basic.scss":
/*!****************************************!*\
  !*** ./src/ui_basic/css/ui_basic.scss ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/ui_basic/js/ui_basic.js":
/*!*************************************!*\
  !*** ./src/ui_basic/js/ui_basic.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;
exports.dom_initUI = dom_initUI;

var _preact = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.esm.js");

__webpack_require__(/*! ../css/ui_basic.scss */ "./src/ui_basic/css/ui_basic.scss");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UIBasic = function (_Component) {
  _inherits(UIBasic, _Component);

  function UIBasic(props) {
    _classCallCheck(this, UIBasic);

    return _possibleConstructorReturn(this, _Component.call(this, props));
  }

  UIBasic.prototype.componentWillMount = function componentWillMount() {};

  UIBasic.prototype.componentDidMount = function componentDidMount() {};

  UIBasic.prototype.render = function render() {
    return (0, _preact.h)(
      'div',
      { className: 'html5-video-player' },
      (0, _preact.h)(
        'div',
        { className: 'vop-video-container' },
        (0, _preact.h)('video', { className: 'vop-video', playsInline: 'true', 'webkit-playsinline': 'true' })
      ),
      (0, _preact.h)('div', { className: 'vop-ads-container' })
    );
  };

  return UIBasic;
}(_preact.Component);

exports.default = UIBasic;


function createMediaElement() {
  var mediaElement = document.createElement('video');

  mediaElement.className = 'vop-video';
  mediaElement.setAttribute('webkit-playsinline', '');
  mediaElement.setAttribute('playsinline', '');

  return mediaElement;
}

function createVideoContainer() {
  var container = document.createElement('div');
  container.setAttribute('class', 'vop-video-container');

  var mediaElement = createMediaElement();
  container.appendChild(mediaElement);
  return container;
}

function createAdsContainer() {
  var container = document.createElement('div');
  container.setAttribute('class', 'vop-ads-container');
  return container;
}

function dom_initUI(container) {
  var html5VideoPlayer = document.createElement('div');
  html5VideoPlayer.setAttribute('class', 'html5-video-player');

  // create video container
  var vopVideoContainer = createVideoContainer();

  // create ads container
  var vopAdsContainer = createAdsContainer();

  html5VideoPlayer.appendChild(vopVideoContainer);
  html5VideoPlayer.appendChild(vopAdsContainer);

  //
  container.appendChild(html5VideoPlayer);
}

/***/ }),

/***/ "./src/utils/Error.js":
/*!****************************!*\
  !*** ./src/utils/Error.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * @class
 * @ignore
 */
var Error = function Error(code, message, data) {
  _classCallCheck(this, Error);

  this.code = code || null;
  this.message = message || null;
  this.data = data || null;
};

exports.default = Error;

/***/ }),

/***/ "./src/utils/VTTParser.js":
/*!********************************!*\
  !*** ./src/utils/VTTParser.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
var WEBVTT = 'WEBVTT';

function VTTParser() {
  var context = this.context;
  var log = (0, _Debug2.default)(context).getInstance().log;

  var instance = void 0,
      regExNewLine = void 0,
      regExToken = void 0,
      regExWhiteSpace = void 0,
      regExWhiteSpaceWordBoundary = void 0;

  function setup() {
    regExNewLine = /(?:\r\n|\r|\n)/gm;
    regExToken = /-->/;
    regExWhiteSpace = /(^[\s]+|[\s]+$)/g;
    regExWhiteSpaceWordBoundary = /\s\b/g;
  }

  function parse(data) {
    var captionArray = [];
    var len = void 0,
        lastStartTime = void 0;

    if (!data) {
      return captionArray;
    }

    data = data.split(regExNewLine);
    len = data.length;
    lastStartTime = -1;

    for (var i = 0; i < len; i++) {
      var item = data[i];

      if (item.length > 0 && item !== WEBVTT) {
        if (item.match(regExToken)) {
          var attributes = parseItemAttributes(item);
          var cuePoints = attributes.cuePoints;
          var styles = attributes.styles;
          var text = getSublines(data, i + 1);
          var startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));
          var endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));

          if (!isNaN(startTime) && !isNaN(endTime) && startTime >= lastStartTime && endTime > startTime) {
            if (text !== '') {
              lastStartTime = startTime;
              //TODO Make VO external so other parsers can use.
              captionArray.push({
                start: startTime,
                end: endTime,
                data: text,
                styles: styles
              });
            } else {
              log('Skipping cue due to empty/malformed cue text');
            }
          } else {
            log('Skipping cue due to incorrect cue timing');
          }
        }
      }
    }

    return captionArray;
  }

  function convertCuePointTimes(time) {
    var timeArray = time.split(':');
    var len = timeArray.length - 1;

    time = parseInt(timeArray[len - 1], 10) * 60 + parseFloat(timeArray[len]);

    if (len === 2) {
      time += parseInt(timeArray[0], 10) * 3600;
    }

    return time;
  }

  function parseItemAttributes(data) {
    var vttCuePoints = data.split(regExToken);
    var arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);
    arr.shift(); //remove first array index it is empty...
    vttCuePoints[1] = arr[0];
    arr.shift();
    return {
      cuePoints: vttCuePoints,
      styles: getCaptionStyles(arr)
    };
  }

  function getCaptionStyles(arr) {
    var styleObject = {};
    arr.forEach(function (element) {
      if (element.split(/:/).length > 1) {
        var val = element.split(/:/)[1];
        if (val && val.search(/%/) != -1) {
          val = parseInt(val.replace(/%/, ''), 10);
        }
        if (element.match(/align/) || element.match(/A/)) {
          styleObject.align = val;
        }
        if (element.match(/line/) || element.match(/L/)) {
          styleObject.line = val;
        }
        if (element.match(/position/) || element.match(/P/)) {
          styleObject.position = val;
        }
        if (element.match(/size/) || element.match(/S/)) {
          styleObject.size = val;
        }
      }
    });

    return styleObject;
  }

  /*
   * VTT can have multiple lines to display per cuepoint.
   */
  function getSublines(data, idx) {
    var i = idx;

    var subline = '';
    var lineData = '';
    var lineCount = void 0;

    while (data[i] !== '' && i < data.length) {
      i++;
    }

    lineCount = i - idx;
    if (lineCount > 1) {
      for (var j = 0; j < lineCount; j++) {
        lineData = data[idx + j];
        if (!lineData.match(regExToken)) {
          subline += lineData;
          if (j !== lineCount - 1) {
            subline += '\n';
          }
        } else {
          // caption text should not have '-->' in it
          subline = '';
          break;
        }
      }
    } else {
      lineData = data[idx];
      if (!lineData.match(regExToken)) subline = lineData;
    }
    return subline;
  }

  instance = {
    parse: parse
  };

  setup();
  return instance;
}
VTTParser.__h5player_factory_name = 'VTTParser';
exports.default = _FactoryMaker2.default.getSingletonFactory(VTTParser);

/***/ }),

/***/ "./src/utils/ajax.js":
/*!***************************!*\
  !*** ./src/utils/ajax.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ajax = ajax;
// Define xhr_loader internal structure FYI.

// XHR ReadyState
// 0 UNSENT ()  open().
// 1 OPENED  () open().
// 2 HEADERS_RECEIVED () send(), .
// 3 LOADING () ; responseText.
// 4 DONE () .

var XHR_READYSTATE_UNSENT = 0;
var XHR_READYSTATE_OPENED = 1;
var XHR_READYSTATE_HEADERS_RECEIVED = 2;
var XHR_READYSTATE_LOADING = 3;
var XHR_READYSTATE_DONE = 4;

// HTTP Error Code
// 200 OK

var xhr = null;

function printlog(log) {
  console.log(log);
}

function _readyStateChangeHandler(options) {
  return function (e) {
    var xhr = e.currentTarget || options.xhr;
    if (xhr.readyState === XHR_READYSTATE_DONE) {
      if (xhr.status === 200) {
        options.oncomplete(xhr);
      }
    }
  };
}

function _requestError(options) {
  return function (e) {
    var xhr = e.currentTarget || options.xhr;
    options.onerror(xhr);
  };
}

function ajax(url, completeCallback, errorCallback) {
  printlog('begin load time: ' + new Date().getTime() / 1000);

  // save input parameters
  var options = {
    xhr: null,
    url: url,
    oncomplete: completeCallback,
    onerror: errorCallback
  };

  printlog('ajax: ' + options.url);

  // init reference variables
  xhr = options.xhr = new XMLHttpRequest();

  printlog('--before open--, readyState: ' + xhr.readyState);
  xhr.open('GET', options.url);

  xhr.onreadystatechange = _readyStateChangeHandler(options);
  xhr.onerror = _requestError(options);

  printlog('--before send--, readyState: ' + xhr.readyState);
  xhr.send();

  return xhr;
};

/***/ }),

/***/ "./src/utils/common_utils.js":
/*!***********************************!*\
  !*** ./src/utils/common_utils.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var CommonUtils = {};

/**
 * return IE,IE6,IE7,IE8,IE9,Chrome,Firefox,Opera,WebKit,Safari,Others
 */
CommonUtils.getBrowserInfo = function () {
  var sys = {};
  var ua = navigator.userAgent.toLowerCase();
  var s;
  if (s = ua.match(/edge\/([\d.]+)/)) {
    sys.edge = s[1];
  } else if (s = ua.match(/rv:([\d.]+)\) like gecko/)) {
    sys.ie = s[1];
  } else if (s = ua.match(/msie ([\d.]+)/)) {
    sys.ie = s[1];
  } else if (s = ua.match(/firefox\/([\d.]+)/)) {
    sys.firefox = s[1];
  } else if (s = ua.match(/chrome\/([\d.]+)/)) {
    sys.chrome = s[1];
  } else if (s = ua.match(/opera.([\d.]+)/)) {
    sys.opera = s[1];
  } else if (s = ua.match(/version\/([\d.]+).*safari/)) {
    sys.safari = s[1];
  }

  if (sys.edge) {
    return {
      browser: 'Edge',
      version: sys.edge
    };
  }
  if (sys.ie) {
    return {
      browser: 'IE',
      version: sys.ie
    };
  }
  if (sys.firefox) {
    return {
      browser: 'Firefox',
      version: sys.firefox
    };
  }
  if (sys.chrome) {
    return {
      browser: 'Chrome',
      version: sys.chrome
    };
  }
  if (sys.opera) {
    return {
      browser: 'Opera',
      version: sys.opera
    };
  }
  if (sys.safari) {
    return {
      browser: 'Safari',
      version: sys.safari
    };
  }

  return {
    browser: '',
    version: '0'
  };
};

CommonUtils.isSafari = function () {
  if (CommonUtils.getBrowserInfo().browser === 'Safari') {
    return true;
  } else {
    return false;
  }
};

CommonUtils.isFirefox = function () {
  if (CommonUtils.getBrowserInfo().browser === 'Firefox') {
    return true;
  } else {
    return false;
  }
};

CommonUtils.isChrome = function () {
  if (CommonUtils.getBrowserInfo().browser === 'Chrome') {
    return true;
  } else {
    return false;
  }
};

CommonUtils.isChromecast = function () {
  if (window.cast && window.cast.__platform__) {
    return true;
  } else {
    return false;
  }
};

CommonUtils.isEdge = function () {
  var userAgent = navigator.userAgent;
  var isEdge = userAgent.indexOf('Edge') > -1;
  return isEdge;
};

CommonUtils.isIE = function () {
  if (!!window.ActiveXObject || 'ActiveXObject' in window) {
    return true;
  } else {
    return false;
  }
};

CommonUtils.getOSVersion = function () {
  var os, osVersion;

  // system
  var nAgt = navigator.userAgent;
  var nVer = navigator.appVersion;

  os = 'unknown';
  osVersion = 'unknown';
  var clientStrings = [{
    s: 'Windows 10',
    r: /(Windows 10.0|Windows NT 10.0)/
  }, {
    s: 'Windows 8.1',
    r: /(Windows 8.1|Windows NT 6.3)/
  }, {
    s: 'Windows 8',
    r: /(Windows 8|Windows NT 6.2)/
  }, {
    s: 'Windows 7',
    r: /(Windows 7|Windows NT 6.1)/
  }, {
    s: 'Windows Vista',
    r: /Windows NT 6.0/
  }, {
    s: 'Windows Server 2003',
    r: /Windows NT 5.2/
  }, {
    s: 'Windows XP',
    r: /(Windows NT 5.1|Windows XP)/
  }, {
    s: 'Windows 2000',
    r: /(Windows NT 5.0|Windows 2000)/
  }, {
    s: 'Windows ME',
    r: /(Win 9x 4.90|Windows ME)/
  }, {
    s: 'Windows 98',
    r: /(Windows 98|Win98)/
  }, {
    s: 'Windows 95',
    r: /(Windows 95|Win95|Windows_95)/
  }, {
    s: 'Windows NT 4.0',
    r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
  }, {
    s: 'Windows CE',
    r: /Windows CE/
  }, {
    s: 'Windows 3.11',
    r: /Win16/
  }, {
    s: 'Android',
    r: /Android/
  }, {
    s: 'Open BSD',
    r: /OpenBSD/
  }, {
    s: 'Sun OS',
    r: /SunOS/
  }, {
    s: 'Linux',
    r: /(Linux|X11)/
  }, {
    s: 'iOS',
    r: /(iPhone|iPad|iPod)/
  }, {
    s: 'Mac OS X',
    r: /Mac OS X/
  }, {
    s: 'Mac OS',
    r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
  }, {
    s: 'QNX',
    r: /QNX/
  }, {
    s: 'UNIX',
    r: /UNIX/
  }, {
    s: 'BeOS',
    r: /BeOS/
  }, {
    s: 'OS/2',
    r: /OS\/2/
  }, {
    s: 'Search Bot',
    r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
  }];
  for (var id in clientStrings) {
    var cs = clientStrings[id];
    if (cs.r.test(nAgt)) {
      os = cs.s;
      break;
    }
  }

  if (/Windows/.test(os)) {
    osVersion = /Windows (.*)/.exec(os)[1];
    os = 'Windows';
  }

  switch (os) {
    case 'Mac OS X':
      osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
      break;
    case 'Android':
      osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
      break;
    case 'iOS':
      osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
      osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
      break;
  }

  console.log('nAgt: ' + nAgt);
  console.log('nVer: ' + nVer);
  console.log('os: ' + os);
  console.log('osVersion: ' + osVersion);

  var pattern = 'Linux';
  var ua = 'Mozilla/5.0 (X11; Linux armv7l) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.17 Safari/537.36 CrKey/1.28.100555';
  var arrOSV = RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua);
  var osv = arrOSV[0];
  var patternLen = pattern.length;
  console.log('pattern length: ' + patternLen);
  osv.indexOf(pattern);

  var out = osv.slice(patternLen + 1);
  console.log('out: ' + out);

  var a = 2;
  var b = a;
};

CommonUtils.isMobilePlatform = function () {
  return navigator.userAgent.match(/(iPod|iPhone|iPad)/) || navigator.userAgent.toLowerCase().indexOf('android') > -1;
};

/////////////////////////////////////////////////////////////
CommonUtils.init = function () {
  // Add startsWith prototype method to String object
  if (!String.prototype.startsWith) {
    // Add prototype methods for Number object
    if (!Number.isInteger) {
      Number.isInteger = function (num) {
        return (num ^ 0) === num;
      };
    }

    // Add prototype methods for String object
    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
      };
    }
  }
};

//////////////////////////////////////////////
CommonUtils.getFormatTime = function () {
  var message = '';
  var d = null;

  d = new Date();
  message += '[' + ('0' + (d.getMonth() + 1)).slice(-2) + '-' + ('0' + d.getDate()).slice(-2) + ' ' + ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2) + ':' + ('0' + d.getSeconds()).slice(-2) + '.' + ('0' + d.getMilliseconds()).slice(-3) + ']';

  return message;
};

CommonUtils.timeToString = function (value) {
  function formatTimeUnit(time) {
    return time < 10 ? '0' + time.toString() : time.toString();
  }

  value = Math.max(value, 0);
  var h = Math.floor(value / 3600);
  var m = Math.floor(value % 3600 / 60);
  var s = Math.floor(value % 3600 % 60);
  return (h === 0 ? '' : formatTimeUnit(h) + ':') + formatTimeUnit(m) + ':' + formatTimeUnit(s);
};

CommonUtils.TimeRangesToString = function (r) {
  var log = '',
      len = r.length;
  for (var i = 0; i < len; i++) {
    var beg = r.start(i);
    var end = r.end(i);

    //console.log('start: ' + beg + ', end: ' + end);
    log += '[' + r.start(i) + ',' + r.end(i) + ']';
  }
  return log;
};

//
CommonUtils.test1 = function (aa) {
  CommonUtils.init();

  var s1 = 'aaabbcder';
  var ret = s1.startsWith('aaa', 0);
  var ret2 = s1.startsWith('abc', 0);
  console.log('startsWith ret: ' + ret);
  console.log('startsWith ret2: ' + ret2);

  var b1 = Number.isInteger(123);
  var b2 = Number.isInteger(123.123);
  var b3 = Number.isInteger(undefined);
  console.log('b1: ' + b1);
  console.log('b2: ' + b2);
  console.log('b3: ' + b3);
};

exports.default = CommonUtils;

/***/ }),

/***/ "./src/utils/fetch_loader.js":
/*!***********************************!*\
  !*** ./src/utils/fetch_loader.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ../core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

var _Debug = __webpack_require__(/*! ../core/Debug */ "./src/core/Debug.js");

var _Debug2 = _interopRequireDefault(_Debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Reference
 * 1. https://segmentfault.com/a/1190000007019545
 * 2. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 * 3. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
 */

// class FetchLoaderContext {
//   constructor() {
//     this.url = null;
//     this.cbSuccess = null;
//   }
// }

function FetchLoader() {
  var context_ = this.context;
  var debug_ = (0, _Debug2.default)(context_).getInstance();

  var request_ = null;

  function load(request) {
    request_ = request;

    //
    var fetchRequest = void 0;

    var initParams = {
      method: 'GET',
      mode: 'cors',
      credentials: 'same-origin'
    };

    var headersObj = {};
    initParams.headers = new Headers(headersObj);
    fetchRequest = new Request(request_.url, initParams);

    var totalBytes = 0;
    var fetchPromise = fetch(fetchRequest, initParams);
    // process fetchPromise
    fetchPromise.then(function (response) {
      if (response.ok) {
        var pump = function pump(reader) {
          return reader.read().then(function (result) {
            // if we're done reading the stream, return
            if (result.done) {
              debug_.log('download ' + fetchRequest.url + ' complete, totalBytes: ' + totalBytes);
              request_.cbSuccess(totalBytes);
              return;
            }

            // retrieve the multi-byte chunk of data
            var chunk = result.value;
            totalBytes += chunk.byteLength;

            debug_.log('fetch download chunk: ' + chunk.byteLength);
            request_.cbProgress(chunk.byteLength);

            return pump(reader);
          });
        };

        // start reading the response stream
        return pump(response.body.getReader());
      } else {
        //callbacks.onError({ text: 'fetch, bad network response' }, context);
      }
    }).catch(function () {
      //callbacks.onError({ text: error.message }, context);
    });
  }

  var instance_ = {
    load: load
  };

  return instance_;
}

FetchLoader.__h5player_factory_name = 'FetchLoader';
exports.default = _FactoryMaker2.default.getClassFactory(FetchLoader);

/***/ }),

/***/ "./src/utils/string_utils.js":
/*!***********************************!*\
  !*** ./src/utils/string_utils.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StringUtils = {

  // ArrayBufferArrayBuffer
  ab2str: function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
  },
  // ArrayBuffer
  str2ab: function str2ab(str) {
    var buf = new ArrayBuffer(str.length * 2); // 2
    var bufView = new Uint16Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return buf;
  },
  ab2str_v1: function ab2str_v1(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
  },
  // ArrayBuffer
  str2ab_v1: function str2ab_v1(str) {
    var buf = new ArrayBuffer(str.length); // 1
    var bufView = new Uint8Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return buf;
  },
  u8arrToB64: function u8arrToB64(u8arr) {
    return btoa(String.fromCharCode.apply(null, u8arr)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=*$/, '');
  },
  b64ToU8arr: function b64ToU8arr(encoded) {
    return new Uint8Array(atob(encoded).split('').map(function (c) {
      return c.charCodeAt(0);
    }));
  }
};

module.exports = StringUtils;

/***/ }),

/***/ "./src/utils/timeRanges.js":
/*!*********************************!*\
  !*** ./src/utils/timeRanges.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      //let beg = r.start(i);
      //let end = r.end(i);
      //console.log('start: ' + beg + ', end: ' + end);
      log += '[' + r.start(i) + ',' + r.end(i) + ']';
    }
    return log;
  }
};

module.exports = TimeRanges;

/***/ }),

/***/ "./src/utils/xhr_loader.js":
/*!*********************************!*\
  !*** ./src/utils/xhr_loader.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// Define xhr_loader internal structure FYI.

// class XHRLoaderRequest {
//   constructor() {
//     this.url = null;
//     this.rangeStart = null;
//     this.rangeEnd = null;
//     this.cbSuccess = null;
//   }
// }

// class XHRLoaderConfig {
//   constructor() {
//     this.remainingAttempts = 0;
//     this.retryInterval = 4000;
//   }
// }

// class XHRLoaderCallback {
//   constructor() {

//   }
// }

function XHRLoader() {
  var request_ = null;
  var config_ = null;
  var callbacks_ = null;

  var xhr_ = null;
  var needFailureReport_ = false;

  function load(request, config, callbacks) {
    printlog('begin load time: ' + new Date().getTime() / 1000);
    // save input parameters
    request_ = request;
    config_ = config || {
      remainingAttempts: 0,
      retryInterval: 4000
    };
    callbacks_ = callbacks;

    printlog(request_.url + ', remainingAttempts_: ' + config_.remainingAttempts);

    // init reference variables
    needFailureReport_ = true;
    xhr_ = new XMLHttpRequest();

    printlog('--before open--, readyState: ' + xhr_.readyState);
    xhr_.open('GET', request_.url);
    if (request_.rangeEnd) {
      xhr_.setRequestHeader('Range', 'bytes=' + request_.rangeStart + '-' + (request_.rangeEnd - 1));
    }

    xhr_.onloadstart = function () {
      printlog('--onloadstart--');
    };

    var onload = function onload() {
      //printlog(`--onload--, status:${xhr_.status}, length: ${xhr_.response.byteLength}, readyState:${xhr_.readyState}`);
      printlog('--onload--, status:' + xhr_.status + ', readyState:' + xhr_.readyState);

      if (xhr_.status >= 200 && xhr_.status <= 299) {
        callbacks_.onSuccess(xhr_.response);
        needFailureReport_ = false;
      }
    };

    var onloadend = function onloadend() {
      printlog('--onloadend--, remainingAttempts_: ' + config_.remainingAttempts + ', readystate: ' + xhr_.readyState);
      printlog('--------------------------------------------------------------');

      if (needFailureReport_) {
        if (config_.remainingAttempts > 0) {
          config_.remainingAttempts--;

          // BD, test retry counts
          // if (config_.remainingAttempts === 0) {
          //   request_.url = 'http://localhost/1/tmp/test.txt';
          // }
          // // ED

          printlog('begin load timeout: ' + new Date().getTime() / 1000);

          //setTimeout(retryFunc, config_.retryInterval);
          setTimeout(load.bind(this, request_), config_.retryInterval);
        }
      }
    };

    xhr_.onprogress = function (ev) {
      printlog('--onprogress--, loaded:' + ev.loaded + ', total:' + ev.total + ', readyState:' + xhr_.readyState);
    };

    xhr_.ontimeout = function () {
      printlog('--ontimeout--, readystate: ' + xhr_.readyState);
    };

    xhr_.onabort = function () {
      printlog('--onabort--, readystate: ' + xhr_.readyState);
    };

    xhr_.onerror = function () {
      printlog('--onerror--, readystate: ' + xhr_.readyState);
    };

    xhr_.onreadystatechange = function () {
      printlog('--onreadystatechange--, readystate: ' + xhr_.readyState);
    };

    xhr_.onload = onload.bind(this);
    xhr_.onloadend = onloadend.bind(this);

    xhr_.responseType = request.responseType || 'arraybuffer';
    printlog('--before send--, readyState: ' + xhr_.readyState);
    xhr_.send();
  }

  function printlog(log) {
    console.log(log);
  }

  var instance = {
    load: load
  };

  return instance;
}

exports.default = XHRLoader;

/***/ }),

/***/ "./src/videoplayer.js":
/*!****************************!*\
  !*** ./src/videoplayer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FactoryMaker = __webpack_require__(/*! ./core/FactoryMaker */ "./src/core/FactoryMaker.js");

var _FactoryMaker2 = _interopRequireDefault(_FactoryMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VideoPlayer() {
  var context_ = this.context;

  function setup() {}

  function setSrc(url) {
    // mediaElement.pause();
    // mediaElement.src='';
    context_.media.src = url;

    //let media_ = context_.media;
    //console.log(`timeupdate, main buffered: ${TimeRanges.toString(media_.buffered)}, position: ${media_.currentTime}, duration: ${media_.duration}`);
  }

  var instance_ = {
    setSrc: setSrc
  };

  setup();

  return instance_;
}

VideoPlayer.__h5player_factory_name = 'VideoPlayer';
exports.default = _FactoryMaker2.default.getSingletonFactory(VideoPlayer);

/***/ }),

/***/ "./third_party/hlsjs/src/config.js":
/*!*****************************************!*\
  !*** ./third_party/hlsjs/src/config.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.hlsDefaultConfig = undefined;

var _abrController = __webpack_require__(/*! ./controller/abr-controller */ "./third_party/hlsjs/src/controller/abr-controller.js");

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = __webpack_require__(/*! ./controller/buffer-controller */ "./third_party/hlsjs/src/controller/buffer-controller.js");

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = __webpack_require__(/*! ./controller/cap-level-controller */ "./third_party/hlsjs/src/controller/cap-level-controller.js");

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = __webpack_require__(/*! ./controller/fps-controller */ "./third_party/hlsjs/src/controller/fps-controller.js");

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = __webpack_require__(/*! ./utils/xhr-loader */ "./third_party/hlsjs/src/utils/xhr-loader.js");

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = __webpack_require__(/*! ./controller/audio-track-controller */ "./third_party/hlsjs/src/controller/audio-track-controller.js");

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = __webpack_require__(/*! ./controller/audio-stream-controller */ "./third_party/hlsjs/src/controller/audio-stream-controller.js");

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = __webpack_require__(/*! ./utils/cues */ "./third_party/hlsjs/src/utils/cues.js");

var Cues = _interopRequireWildcard(_cues);

var _timelineController = __webpack_require__(/*! ./controller/timeline-controller */ "./third_party/hlsjs/src/controller/timeline-controller.js");

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./third_party/hlsjs/src/controller/subtitle-track-controller.js");

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./third_party/hlsjs/src/controller/subtitle-stream-controller.js");

var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);

var _emeController = __webpack_require__(/*! ./controller/eme-controller */ "./third_party/hlsjs/src/controller/eme-controller.js");

var _emeController2 = _interopRequireDefault(_emeController);

var _mediakeysHelper = __webpack_require__(/*! ./helper/mediakeys-helper */ "./third_party/hlsjs/src/helper/mediakeys-helper.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import FetchLoader from './utils/fetch-loader';

var hlsDefaultConfig = exports.hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller

  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: _xhrLoader2.default,
  // loader: FetchLoader,
  fLoader: undefined, // used by fragment-loader
  pLoader: undefined, // used by playlist-loader
  xhrSetup: undefined, // used by xhr-loader
  licenseXhrSetup: undefined, // used by eme-controller
  // fetchSetup: undefined,
  abrController: _abrController2.default,
  bufferController: _bufferController2.default,
  capLevelController: _capLevelController2.default,
  fpsController: _fpsController2.default,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0, // used by hls
  emeEnabled: false, // used by eme-controller
  widevineLicenseUrl: undefined, // used by eme-controller
  requestMediaKeySystemAccessFunc: _mediakeysHelper.requestMediaKeySystemAccess // used by eme-controller
};

//if (__USE_SUBTITLES__) {
/**
 * HLS config
 */

if (true) {
  hlsDefaultConfig.subtitleStreamController = _subtitleStreamController2.default;
  hlsDefaultConfig.subtitleTrackController = _subtitleTrackController2.default;
  hlsDefaultConfig.timelineController = _timelineController2.default;
  hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
  hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
  hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller
}

//if (__USE_ALT_AUDIO__) {
if (true) {
  hlsDefaultConfig.audioStreamController = _audioStreamController2.default;
  hlsDefaultConfig.audioTrackController = _audioTrackController2.default;
}

//if (__USE_EME_DRM__)
if (true) hlsDefaultConfig.emeController = _emeController2.default;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/abr-controller.js":
/*!************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/abr-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = __webpack_require__(/*! ../helper/buffer-helper */ "./third_party/hlsjs/src/helper/buffer-helper.js");

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _ewmaBandwidthEstimator = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./third_party/hlsjs/src/utils/ewma-bandwidth-estimator.js");

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  AbrController.prototype.destroy = function destroy() {
    this.clearTimer();
    _eventHandler2.default.prototype.destroy.call(this);
  };

  AbrController.prototype.onFragLoading = function onFragLoading(data) {
    var frag = data.frag;
    if (frag.type === 'main') {
      if (!this.timer) this.timer = setInterval(this.onCheck, 100);

      // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
      // so we need to wait for stream manifest / playlist type to instantiate it.
      if (!this._bwEstimator) {
        var hls = this.hls,
            level = data.frag.level,
            isLive = hls.levels[level].details.live,
            config = hls.config,
            ewmaFast = void 0,
            ewmaSlow = void 0;

        if (isLive) {
          ewmaFast = config.abrEwmaFastLive;
          ewmaSlow = config.abrEwmaSlowLive;
        } else {
          ewmaFast = config.abrEwmaFastVoD;
          ewmaSlow = config.abrEwmaSlowVoD;
        }
        this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
      }
      this.fragCurrent = frag;
    }
  };

  AbrController.prototype._abandonRulesCheck = function _abandonRulesCheck() {
    /*
      monitor fragment retrieval time...
      we compute expected time of arrival of the complete fragment.
      we compare it to expected time of buffer starvation
    */
    var hls = this.hls,
        v = hls.media,
        frag = this.fragCurrent,
        loader = frag.loader,
        minAutoLevel = hls.minAutoLevel;

    // if loader has been destroyed or loading has been aborted, stop timer and return
    if (!loader || loader.stats && loader.stats.aborted) {
      _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
      this.clearTimer();
      // reset forced auto level value so that next level will be selected
      this._nextAutoLevel = -1;
      return;
    }
    var stats = loader.stats;
    /* only monitor frag retrieval time if
    (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
    if (v && stats && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
      var requestDelay = performance.now() - stats.trequest,
          playbackRate = Math.abs(v.playbackRate);
      // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
      if (requestDelay > 500 * frag.duration / playbackRate) {
        var levels = hls.levels,
            loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
            // byte/s; at least 1 byte/s to avoid division by zero
        // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
        level = levels[frag.level],
            levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
            expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
            pos = v.currentTime,
            fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
            bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
        // consider emergency switch down only if we have less than 2 frag buffered AND
        // time to finish loading current fragment is bigger than buffer starvation delay
        // ie if we risk buffer starvation if bw does not increase quickly
        if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
          var fragLevelNextLoadedDelay = void 0,
              nextLoadLevel = void 0;
          // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
          // we start from current level - 1 and we step down , until we find a matching level
          for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
            // compute time to load next fragment at lower level
            // 0.8 : consider only 80% of current bw to be conservative
            // 8 = bits per byte (bps/Bps)
            var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
            fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
            if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
              // we found a lower level that be rebuffering free with current estimated bw !
              break;
            }
          }
          // only emergency switch down if it takes less time to load new fragment at lowest level instead
          // of finishing loading current one ...
          if (fragLevelNextLoadedDelay < fragLoadedDelay) {
            _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
            // force next load level in auto mode
            hls.nextLoadLevel = nextLoadLevel;
            // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
            this._bwEstimator.sample(requestDelay, stats.loaded);
            // abort fragment loading
            loader.abort();
            // stop abandon rules timer
            this.clearTimer();
            hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
          }
        }
      }
    }
  };

  AbrController.prototype.onFragLoaded = function onFragLoaded(data) {
    var frag = data.frag;
    if (frag.type === 'main' && !isNaN(frag.sn)) {
      // stop monitoring bw once frag loaded
      this.clearTimer();
      // store level id after successful fragment load
      this.lastLoadedFragLevel = frag.level;
      // reset forced auto level value so that next level will be selected
      this._nextAutoLevel = -1;

      // compute level average bitrate
      if (this.hls.config.abrMaxWithRealBitrate) {
        var level = this.hls.levels[frag.level];
        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
        level.loaded = { bytes: loadedBytes, duration: loadedDuration };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      // if fragment has been loaded to perform a bitrate test,
      if (data.frag.bitrateTest) {
        var stats = data.stats;
        stats.tparsed = stats.tbuffered = stats.tload;
        this.onFragBuffered(data);
      }
    }
  };

  AbrController.prototype.onFragBuffered = function onFragBuffered(data) {
    var stats = data.stats,
        frag = data.frag;
    // only update stats on first frag buffering
    // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
    // and leading to wrong bw estimation
    // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
    if (stats.aborted !== true && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
      // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
      // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
      // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
      var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
      _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
      this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
      stats.bwEstimate = this._bwEstimator.getEstimate();
      // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
      if (frag.bitrateTest) this.bitrateTestDelay = fragLoadingProcessingMs / 1000;else this.bitrateTestDelay = 0;
    }
  };

  AbrController.prototype.onError = function onError(data) {
    // stop timer in case of frag loading error
    switch (data.details) {
      case _errors.ErrorDetails.FRAG_LOAD_ERROR:
      case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        this.clearTimer();
        break;
      default:
        break;
    }
  };

  AbrController.prototype.clearTimer = function clearTimer() {
    clearInterval(this.timer);
    this.timer = null;
  };

  // return next auto level


  AbrController.prototype._findBestLevel = function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
      var levelInfo = levels[i],
          levelDetails = levelInfo.details,
          avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
          live = levelDetails ? levelDetails.live : false,
          adjustedbw = void 0;
      // follow algorithm captured from stagefright :
      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
      // Pick the highest bandwidth stream below or equal to estimated bandwidth.
      // consider only 80% of the available bandwidth, but if we are switching up,
      // be even more conservative (70%) to avoid overestimating and immediately
      // switching back.
      if (i <= currentLevel) adjustedbw = bwFactor * currentBw;else adjustedbw = bwUpFactor * currentBw;

      var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
          fetchDuration = bitrate * avgDuration / adjustedbw;

      _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
      // if adjusted bw is greater than level bitrate AND
      if (adjustedbw > bitrate && (
      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
      !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
        // as we are looping from highest to lowest, this will return the best achievable quality level
        return i;
      }
    }
    // not enough time budget even with quality level 0 ... rebuffering might happen
    return -1;
  };

  _createClass(AbrController, [{
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) return forcedAutoLevel;

      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/audio-stream-controller.js":
/*!*********************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/audio-stream-controller.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./third_party/hlsjs/src/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../helper/buffer-helper */ "./third_party/hlsjs/src/helper/buffer-helper.js");

var _bufferHelper2 = _interopRequireDefault(_bufferHelper);

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./third_party/hlsjs/src/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _levelHelper = __webpack_require__(/*! ../helper/level-helper */ "./third_party/hlsjs/src/helper/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./third_party/hlsjs/src/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./third_party/hlsjs/src/utils/discontinuities.js");

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./third_party/hlsjs/src/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _fragmentTracker = __webpack_require__(/*! ../helper/fragment-tracker */ "./third_party/hlsjs/src/helper/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./third_party/hlsjs/src/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var AudioStreamController = function (_TaskLoop) {
  _inherits(AudioStreamController, _TaskLoop);

  function AudioStreamController(hls, fragmentTracker) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, _TaskLoop.call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_RESET, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = State.STOPPED;
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  AudioStreamController.prototype.onHandlerDestroying = function onHandlerDestroying() {
    this.stopLoad();
  };

  AudioStreamController.prototype.onHandlerDestroyed = function onHandlerDestroyed() {
    this.state = State.STOPPED;
    this.fragmentTracker = null;
  };

  // Signal that video PTS was found


  AudioStreamController.prototype.onInitPtsFound = function onInitPtsFound(data) {
    var demuxerId = data.id,
        cc = data.frag.cc,
        initPTS = data.initPTS;
    if (demuxerId === 'main') {
      // Always update the new INIT PTS
      // Can change due level switch
      this.initPTS[cc] = initPTS;
      this.videoTrackCC = cc;
      _logger.logger.log('InitPTS for cc: ' + cc + ' found from video track: ' + initPTS);

      // If we are waiting we need to demux/remux the waiting frag
      // With the new initPTS
      if (this.state === State.WAITING_INIT_PTS) this.tick();
    }
  };

  AudioStreamController.prototype.startLoad = function startLoad(startPosition) {
    if (this.tracks) {
      var lastCurrentTime = this.lastCurrentTime;
      this.stopLoad();
      this.setInterval(100);
      this.fragLoadError = 0;
      if (lastCurrentTime > 0 && startPosition === -1) {
        _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
        this.state = State.IDLE;
      } else {
        this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
        this.state = State.STARTING;
      }
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
      this.tick();
    } else {
      this.startPosition = startPosition;
      this.state = State.STOPPED;
    }
  };

  AudioStreamController.prototype.stopLoad = function stopLoad() {
    var frag = this.fragCurrent;
    if (frag) {
      if (frag.loader) frag.loader.abort();

      this.fragmentTracker.removeFragment(frag);
      this.fragCurrent = null;
    }
    this.fragPrevious = null;
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = null;
    }
    this.state = State.STOPPED;
  };

  AudioStreamController.prototype.doTick = function doTick() {
    var pos = void 0,
        track = void 0,
        trackDetails = void 0,
        hls = this.hls,
        config = hls.config;
    // logger.log('audioStream:' + this.state);
    switch (this.state) {
      case State.ERROR:
      // don't do anything in error state to avoid breaking further ...
      case State.PAUSED:
      // don't do anything in paused state either ...
      case State.BUFFER_FLUSHING:
        break;
      case State.STARTING:
        this.state = State.WAITING_TRACK;
        this.loadedmetadata = false;
        break;
      case State.IDLE:
        var tracks = this.tracks;
        // audio tracks not received => exit loop
        if (!tracks) break;

        // if video not attached AND
        // start fragment already requested OR start frag prefetch disable
        // exit loop
        // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
        if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) break;

        // determine next candidate fragment to be loaded, based on current position and
        //  end of buffer position
        // if we have not yet loaded any fragment, start loading from start position
        if (this.loadedmetadata) {
          pos = this.media.currentTime;
        } else {
          pos = this.nextLoadPosition;
          if (pos === undefined) break;
        }
        var media = this.mediaBuffer ? this.mediaBuffer : this.media,
            videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
            bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
            mainBufferInfo = _bufferHelper2.default.bufferInfo(videoBuffer, pos, config.maxBufferHole),
            bufferLen = bufferInfo.len,
            bufferEnd = bufferInfo.end,
            fragPrevious = this.fragPrevious,

        // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
        // whichever is smaller.
        // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
        maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength),
            maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len),
            audioSwitch = this.audioSwitch,
            trackId = this.trackId;

        // if buffer length is less than maxBufLen try to load a new fragment
        if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
          trackDetails = tracks[trackId].details;
          // if track info not retrieved yet, switch state and wait for track retrieval
          if (typeof trackDetails === 'undefined') {
            this.state = State.WAITING_TRACK;
            break;
          }

          // check if we need to finalize media stream
          // we just got done loading the final fragment and there is no other buffered range after ...
          // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
          // so we should not switch to ENDED in that case, to be able to buffer them
          if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN && !bufferInfo.nextStart) {
            // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
            // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
            // between different renditions. using half frag duration should help cope with these cases.
            if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
              // Finalize the media stream
              this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
              this.state = State.ENDED;
              break;
            }
          }

          // find fragment index, contiguous with end of buffer position
          var fragments = trackDetails.fragments,
              fragLen = fragments.length,
              start = fragments[0].start,
              end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
              frag = void 0;

          // When switching audio track, reload audio as close as possible to currentTime
          if (audioSwitch) {
            if (trackDetails.live && !trackDetails.PTSKnown) {
              _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
              bufferEnd = 0;
            } else {
              bufferEnd = pos;
              // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
              if (trackDetails.PTSKnown && pos < start) {
                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                if (bufferInfo.end > start || bufferInfo.nextStart) {
                  _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                  this.media.currentTime = start + 0.05;
                } else {
                  return;
                }
              }
            }
          }
          if (trackDetails.initSegment && !trackDetails.initSegment.data) {
            frag = trackDetails.initSegment;
          } // eslint-disable-line brace-style
          // if bufferEnd before start of playlist, load first fragment
          else if (bufferEnd <= start) {
              frag = fragments[0];
              if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                // Ensure we find a fragment which matches the continuity of the video track
                frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
              }
              if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                // let's force seek to start
                var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                this.media.currentTime = nextBuffered + 0.05;
                return;
              }
            } else {
              var foundFrag = void 0;
              var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
              var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
              var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                // offset should be within fragment boundary - config.maxFragLookUpTolerance
                // this is to cope with situations like
                // bufferEnd = 9.991
                // frag[] : [0,10]
                // frag[1] : [10,20]
                // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                //              frag start               frag start+duration
                //                  |-----------------------------|
                //              <--->                         <--->
                //  ...--------><-----------------------------><---------....
                // previous frag         matching fragment         next frag
                //  return -1             return 0                 return 1
                // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) return 1;
                // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) return -1;

                return 0;
              };

              if (bufferEnd < end) {
                if (bufferEnd > end - maxFragLookUpTolerance) maxFragLookUpTolerance = 0;

                // Prefer the next fragment if it's within tolerance
                if (fragNext && !fragmentWithinToleranceTest(fragNext)) foundFrag = fragNext;else foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
              } else {
                // reach end of playlist
                foundFrag = fragments[fragLen - 1];
              }
              if (foundFrag) {
                frag = foundFrag;
                start = foundFrag.start;
                // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                  if (frag.sn < trackDetails.endSN) {
                    frag = fragments[frag.sn + 1 - trackDetails.startSN];
                    _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                  } else {
                    frag = null;
                  }
                }
              }
            }
          if (frag) {
            // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
            if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
              _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
              this.state = State.KEY_LOADING;
              hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
            } else {
              _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
              // only load if fragment is not loaded or if in audio switch
              // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
              if (audioSwitch || this.fragmentTracker.getState(frag) === _fragmentTracker.FragmentState.NOT_LOADED) {
                this.fragCurrent = frag;
                this.startFragRequested = true;
                if (!isNaN(frag.sn)) this.nextLoadPosition = frag.start + frag.duration;

                hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                this.state = State.FRAG_LOADING;
              }
            }
          }
        }
        break;
      case State.WAITING_TRACK:
        track = this.tracks[this.trackId];
        // check if playlist is already loaded
        if (track && track.details) this.state = State.IDLE;

        break;
      case State.FRAG_LOADING_WAITING_RETRY:
        var now = performance.now();
        var retryDate = this.retryDate;
        media = this.media;
        var isSeeking = media && media.seeking;
        // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
        if (!retryDate || now >= retryDate || isSeeking) {
          _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
          this.state = State.IDLE;
        }
        break;
      case State.WAITING_INIT_PTS:
        var videoTrackCC = this.videoTrackCC;
        if (this.initPTS[videoTrackCC] === undefined) break;

        // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
        var waitingFrag = this.waitingFragment;
        if (waitingFrag) {
          var waitingFragCC = waitingFrag.frag.cc;
          if (videoTrackCC !== waitingFragCC) {
            track = this.tracks[this.trackId];
            if (track.details && track.details.live) {
              _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
              this.waitingFragment = null;
              this.state = State.IDLE;
            }
          } else {
            this.state = State.FRAG_LOADING;
            this.onFragLoaded(this.waitingFragment);
            this.waitingFragment = null;
          }
        } else {
          this.state = State.IDLE;
        }

        break;
      case State.STOPPED:
      case State.FRAG_LOADING:
      case State.PARSING:
      case State.PARSED:
      case State.ENDED:
        break;
      default:
        break;
    }
  };

  AudioStreamController.prototype.onMediaAttached = function onMediaAttached(data) {
    var media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener('seeking', this.onvseeking);
    media.addEventListener('ended', this.onvended);
    var config = this.config;
    if (this.tracks && config.autoStartLoad) this.startLoad(config.startPosition);
  };

  AudioStreamController.prototype.onMediaDetaching = function onMediaDetaching() {
    var media = this.media;
    if (media && media.ended) {
      _logger.logger.log('MSE detaching and video ended, reset startPosition');
      this.startPosition = this.lastCurrentTime = 0;
    }

    // remove video listeners
    if (media) {
      media.removeEventListener('seeking', this.onvseeking);
      media.removeEventListener('ended', this.onvended);
      this.onvseeking = this.onvseeked = this.onvended = null;
    }
    this.media = this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
    this.stopLoad();
  };

  AudioStreamController.prototype.onMediaSeeking = function onMediaSeeking() {
    if (this.state === State.ENDED) {
      // switch to IDLE state to check for potential new fragment
      this.state = State.IDLE;
    }
    if (this.media) this.lastCurrentTime = this.media.currentTime;

    // tick to speed up processing
    this.tick();
  };

  AudioStreamController.prototype.onMediaEnded = function onMediaEnded() {
    // reset startPosition and lastCurrentTime to restart playback @ stream beginning
    this.startPosition = this.lastCurrentTime = 0;
  };

  AudioStreamController.prototype.onAudioTracksUpdated = function onAudioTracksUpdated(data) {
    _logger.logger.log('audio tracks updated');
    this.tracks = data.audioTracks;
  };

  AudioStreamController.prototype.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
    // if any URL found on new audio track, it is an alternate audio track
    var altAudio = !!data.url;
    this.trackId = data.id;

    this.fragCurrent = null;
    this.state = State.PAUSED;
    this.waitingFragment = null;
    // destroy useless demuxer when switching audio to main
    if (!altAudio) {
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
    } else {
      // switching to audio track, start timer if not already started
      this.setInterval(100);
    }

    // should we switch tracks ?
    if (altAudio) {
      this.audioSwitch = true;
      // main audio track are handled by stream-controller, just do something if switching to alt audio track
      this.state = State.IDLE;
    }
    this.tick();
  };

  AudioStreamController.prototype.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
    var newDetails = data.details,
        trackId = data.id,
        track = this.tracks[trackId],
        duration = newDetails.totalduration,
        sliding = 0;

    _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

    if (newDetails.live) {
      var curDetails = track.details;
      if (curDetails && newDetails.fragments.length > 0) {
        // we already have details for that level, merge them
        LevelHelper.mergeDetails(curDetails, newDetails);
        sliding = newDetails.fragments[0].start;
        // TODO
        // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
        if (newDetails.PTSKnown) _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));else _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
      } else {
        newDetails.PTSKnown = false;
        _logger.logger.log('live audio playlist - first load, unknown sliding');
      }
    } else {
      newDetails.PTSKnown = false;
    }
    track.details = newDetails;

    // compute start position
    if (!this.startFragRequested) {
      // compute start position if set to -1. use it straight away if value is defined
      if (this.startPosition === -1) {
        // first, check if start time offset has been set in playlist, if yes, use this value
        var startTimeOffset = newDetails.startTimeOffset;
        if (!isNaN(startTimeOffset)) {
          _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
          this.startPosition = startTimeOffset;
        } else {
          this.startPosition = 0;
        }
      }
      this.nextLoadPosition = this.startPosition;
    }
    // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
    if (this.state === State.WAITING_TRACK) this.state = State.IDLE;

    // trigger handler right now
    this.tick();
  };

  AudioStreamController.prototype.onKeyLoaded = function onKeyLoaded() {
    if (this.state === State.KEY_LOADING) {
      this.state = State.IDLE;
      this.tick();
    }
  };

  AudioStreamController.prototype.onFragLoaded = function onFragLoaded(data) {
    var fragCurrent = this.fragCurrent,
        fragLoaded = data.frag;
    if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
      var track = this.tracks[this.trackId],
          details = track.details,
          duration = details.totalduration,
          trackId = fragCurrent.level,
          sn = fragCurrent.sn,
          cc = fragCurrent.cc,
          audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
          stats = this.stats = data.stats;
      if (sn === 'initSegment') {
        this.state = State.IDLE;

        stats.tparsed = stats.tbuffered = performance.now();
        details.initSegment.data = data.payload;
        this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
        this.tick();
      } else {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.appended = false;
        if (!this.demuxer) this.demuxer = new _demuxer2.default(this.hls, 'audio');

        // Check if we have video initPTS
        // If not we need to wait for it
        var initPTS = this.initPTS[cc];
        var initSegmentData = details.initSegment ? details.initSegment.data : [];
        if (details.initSegment || initPTS !== undefined) {
          this.pendingBuffering = true;
          _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
          var accurateTimeOffset = false; // details.PTSKnown || !details.live;
          this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
        } else {
          _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          this.waitingFragment = data;
          this.state = State.WAITING_INIT_PTS;
        }
      }
    }
    this.fragLoadError = 0;
  };

  AudioStreamController.prototype.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
      var tracks = data.tracks,
          track = void 0;

      // delete any video track found on audio demuxer
      if (tracks.video) delete tracks.video;

      // include levelCodec in audio and video tracks
      track = tracks.audio;
      if (track) {
        track.levelCodec = track.codec;
        track.id = data.id;
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
        var initSegment = track.initSegment;
        if (initSegment) {
          var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
          if (this.audioSwitch) {
            this.pendingData = [appendObj];
          } else {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  };

  AudioStreamController.prototype.onFragParsingData = function onFragParsingData(data) {
    var _this2 = this;

    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
      var trackId = this.trackId,
          track = this.tracks[trackId],
          hls = this.hls;

      if (isNaN(data.endPTS)) {
        data.endPTS = data.startPTS + fragCurrent.duration;
        data.endDTS = data.startDTS + fragCurrent.duration;
      }

      fragCurrent.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);

      _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
      LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

      var audioSwitch = this.audioSwitch,
          media = this.media,
          appendOnBufferFlush = false;
      // Only flush audio from old audio tracks when PTS is known on new audio track
      if (audioSwitch && media) {
        if (media.readyState) {
          var currentTime = media.currentTime;
          _logger.logger.log('switching audio track : currentTime:' + currentTime);
          if (currentTime >= data.startPTS) {
            _logger.logger.log('switching audio track : flushing all audio');
            this.state = State.BUFFER_FLUSHING;
            hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            appendOnBufferFlush = true;
            // Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        } else {
          // Lets announce that the initial audio track switch flush occur
          this.audioSwitch = false;
          hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        }
      }

      var pendingData = this.pendingData;

      if (!pendingData) {
        console.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
        return;
      }

      if (!this.audioSwitch) {
        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer && buffer.length) pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
        });
        if (!appendOnBufferFlush && pendingData.length) {
          pendingData.forEach(function (appendObj) {
            // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
            // in that case it is useless to append following segments
            if (_this2.state === State.PARSING) {
              // arm pending Buffering flag before appending a segment
              _this2.pendingBuffering = true;
              _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          });
          this.pendingData = [];
          this.appended = true;
        }
      }
      // trigger handler right now
      this.tick();
    }
  };

  AudioStreamController.prototype.onFragParsed = function onFragParsed(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
      this.stats.tparsed = performance.now();
      this.state = State.PARSED;
      this._checkAppendedParsed();
    }
  };

  AudioStreamController.prototype.onBufferReset = function onBufferReset() {
    // reset reference to sourcebuffers
    this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
  };

  AudioStreamController.prototype.onBufferCreated = function onBufferCreated(data) {
    var audioTrack = data.tracks.audio;
    if (audioTrack) {
      this.mediaBuffer = audioTrack.buffer;
      this.loadedmetadata = true;
    }
    if (data.tracks.video) this.videoBuffer = data.tracks.video.buffer;
  };

  AudioStreamController.prototype.onBufferAppended = function onBufferAppended(data) {
    if (data.parent === 'audio') {
      var state = this.state;
      if (state === State.PARSING || state === State.PARSED) {
        // check if all buffers have been appended
        this.pendingBuffering = data.pending > 0;
        this._checkAppendedParsed();
      }
    }
  };

  AudioStreamController.prototype._checkAppendedParsed = function _checkAppendedParsed() {
    // trigger handler right now
    if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
      var frag = this.fragCurrent,
          stats = this.stats,
          hls = this.hls;
      if (frag) {
        this.fragPrevious = frag;
        stats.tbuffered = performance.now();
        hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
        if (this.audioSwitch && this.appended) {
          this.audioSwitch = false;
          hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
        }
        this.state = State.IDLE;
      }
      this.tick();
    }
  };

  AudioStreamController.prototype.onError = function onError(data) {
    var frag = data.frag;
    // don't handle frag error not related to audio fragment
    if (frag && frag.type !== 'audio') return;

    switch (data.details) {
      case _errors.ErrorDetails.FRAG_LOAD_ERROR:
      case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        if (!data.fatal) {
          var loadError = this.fragLoadError;
          if (loadError) loadError++;else loadError = 1;

          var config = this.config;
          if (loadError <= config.fragLoadingMaxRetry) {
            this.fragLoadError = loadError;
            // exponential backoff capped to config.fragLoadingMaxRetryTimeout
            var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
            _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
            this.retryDate = performance.now() + delay;
            // retry loading state
            this.state = State.FRAG_LOADING_WAITING_RETRY;
          } else {
            _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
            // switch error to fatal
            data.fatal = true;
            this.state = State.ERROR;
          }
        }
        break;
      case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
      case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
      case _errors.ErrorDetails.KEY_LOAD_ERROR:
      case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
        if (this.state !== State.ERROR) {
          // if fatal error, stop processing, otherwise move to IDLE to retry loading
          this.state = data.fatal ? State.ERROR : State.IDLE;
          _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
        }
        break;
      case _errors.ErrorDetails.BUFFER_FULL_ERROR:
        // if in appending state
        if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {
          var media = this.mediaBuffer,
              currentTime = this.media.currentTime,
              mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);
          // reduce max buf len if current position is buffered
          if (mediaBuffered) {
            var _config = this.config;
            if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
              // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
              _config.maxMaxBufferLength /= 2;
              _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
            }
            this.state = State.IDLE;
          } else {
            // current position is not buffered, but browser is still complaining about buffer full error
            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
            // in that case flush the whole audio buffer to recover
            _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
            this.fragCurrent = null;
            // flush everything
            this.state = State.BUFFER_FLUSHING;
            this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
          }
        }
        break;
      default:
        break;
    }
  };

  AudioStreamController.prototype.onBufferFlushed = function onBufferFlushed() {
    var _this3 = this;

    var pendingData = this.pendingData;
    if (pendingData && pendingData.length) {
      _logger.logger.log('appending pending audio data on Buffer Flushed');
      pendingData.forEach(function (appendObj) {
        _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
      });
      this.appended = true;
      this.pendingData = [];
      this.state = State.PARSED;
    } else {
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
      this.tick();
    }
  };

  _createClass(AudioStreamController, [{
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_taskLoop2.default);

exports.default = AudioStreamController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/audio-track-controller.js":
/*!********************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/audio-track-controller.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var AudioTrackController = function (_EventHandler) {
  _inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.AUDIO_TRACK_LOADED, _events2.default.ERROR));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  AudioTrackController.prototype.destroy = function destroy() {
    this.cleanTimer();
    _eventHandler2.default.prototype.destroy.call(this);
  };

  AudioTrackController.prototype.cleanTimer = function cleanTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  };

  AudioTrackController.prototype.tick = function tick() {
    this.ticks++;
    if (this.ticks === 1) {
      this.doTick();
      if (this.ticks > 1) setTimeout(this.tick, 1);

      this.ticks = 0;
    }
  };

  AudioTrackController.prototype.doTick = function doTick() {
    this.updateTrack(this.trackId);
  };

  AudioTrackController.prototype.onError = function onError(data) {
    if (data.fatal && data.type === _errors.ErrorTypes.NETWORK_ERROR) this.cleanTimer();
  };

  AudioTrackController.prototype.onManifestLoading = function onManifestLoading() {
    // reset audio tracks on manifest loading
    this.tracks = [];
    this.trackId = -1;
  };

  AudioTrackController.prototype.onManifestParsed = function onManifestParsed(data) {
    var _this2 = this;

    var tracks = data.audioTracks || [];
    var defaultFound = false;
    this.tracks = tracks;
    this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    // loop through available audio tracks and autoselect default if needed
    var id = 0;
    tracks.forEach(function (track) {
      if (track.default && !defaultFound) {
        _this2.audioTrack = id;
        defaultFound = true;
        return;
      }
      id++;
    });
    if (defaultFound === false && tracks.length) {
      _logger.logger.log('no default audio track defined, use first audio track as default');
      this.audioTrack = 0;
    }
  };

  AudioTrackController.prototype.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
    if (data.id < this.tracks.length) {
      _logger.logger.log('audioTrack ' + data.id + ' loaded');
      this.tracks[data.id].details = data.details;
      // check if current playlist is a live playlist
      if (data.details.live && !this.timer) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
      }
      if (!data.details.live && this.timer) {
        // playlist is not live and timer is armed : stopping it
        this.cleanTimer();
      }
    }
  };

  /** get alternate audio tracks list from playlist **/


  AudioTrackController.prototype.setAudioTrackInternal = function setAudioTrackInternal(newId) {
    // check if level idx is valid
    if (newId >= 0 && newId < this.tracks.length) {
      // stopping live reloading timer if any
      this.cleanTimer();
      this.trackId = newId;
      _logger.logger.log('switching to audioTrack ' + newId);
      var audioTrack = this.tracks[newId],
          hls = this.hls,
          type = audioTrack.type,
          url = audioTrack.url,
          eventObj = { id: newId, type: type, url: url };
      hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
      // check if we need to load playlist for this audio Track
      var details = audioTrack.details;
      if (url && (details === undefined || details.live === true)) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
        hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
      }
    }
  };

  AudioTrackController.prototype.updateTrack = function updateTrack(newId) {
    // check if level idx is valid
    if (newId >= 0 && newId < this.tracks.length) {
      // stopping live reloading timer if any
      this.cleanTimer();
      this.trackId = newId;
      _logger.logger.log('updating audioTrack ' + newId);
      var audioTrack = this.tracks[newId],
          url = audioTrack.url;
      // check if we need to load playlist for this audio Track
      var details = audioTrack.details;
      if (url && (details === undefined || details.live === true)) {
        // track not retrieved yet, or live playlist we need to (re)load it
        _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
        this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
      }
    }
  };

  _createClass(AudioTrackController, [{
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) this.setAudioTrackInternal(audioTrackId);
    }
  }]);

  return AudioTrackController;
}(_eventHandler2.default);

exports.default = AudioTrackController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/buffer-controller.js":
/*!***************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/buffer-controller.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../helper/mediasource-helper */ "./third_party/hlsjs/src/helper/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  BufferController.prototype.destroy = function destroy() {
    _eventHandler2.default.prototype.destroy.call(this);
  };

  BufferController.prototype.onLevelPtsUpdated = function onLevelPtsUpdated(data) {
    var type = data.type;
    var audioTrack = this.tracks.audio;

    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
    // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
    // event if SB is in updating state.
    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

    if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
      // Chrome audio mp3 track
      var audioBuffer = this.sourceBuffer.audio;
      var delta = Math.abs(audioBuffer.timestampOffset - data.start);

      // adjust timestamp offset if time delta is greater than 100ms
      if (delta > 0.1) {
        var updating = audioBuffer.updating;

        try {
          audioBuffer.abort();
        } catch (err) {
          updating = true;
          _logger.logger.warn('can not abort audio buffer: ' + err);
        }

        if (!updating) {
          _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
          audioBuffer.timestampOffset = data.start;
        } else {
          this.audioTimestampOffset = data.start;
        }
      }
    }
  };

  BufferController.prototype.onManifestParsed = function onManifestParsed(data) {
    var audioExpected = data.audio,
        videoExpected = data.video || data.levels.length && data.altAudio,
        sourceBufferNb = 0;
    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
    // sourcebuffers will be created all at once when the expected nb of tracks will be reached
    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
    // it will contain the expected nb of source buffers, no need to compute it
    if (data.altAudio && (audioExpected || videoExpected)) {
      sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
      _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
    }
    this.sourceBufferNb = sourceBufferNb;
  };

  BufferController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    var media = this.media = data.media;
    if (media) {
      // setup the media source
      var ms = this.mediaSource = new MediaSource();
      // Media Source listeners
      this.onmso = this.onMediaSourceOpen.bind(this);
      this.onmse = this.onMediaSourceEnded.bind(this);
      this.onmsc = this.onMediaSourceClose.bind(this);
      ms.addEventListener('sourceopen', this.onmso);
      ms.addEventListener('sourceended', this.onmse);
      ms.addEventListener('sourceclose', this.onmsc);
      // link video and media Source
      media.src = URL.createObjectURL(ms);
      // cache the locally generated object url
      this._objectUrl = media.src;
    }
  };

  BufferController.prototype.onMediaDetaching = function onMediaDetaching() {
    _logger.logger.log('media source detaching');
    var ms = this.mediaSource;
    if (ms) {
      if (ms.readyState === 'open') {
        try {
          // endOfStream could trigger exception if any sourcebuffer is in updating state
          // we don't really care about checking sourcebuffer state here,
          // as we are anyway detaching the MediaSource
          // let's just avoid this exception to propagate
          ms.endOfStream();
        } catch (err) {
          _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
        }
      }
      ms.removeEventListener('sourceopen', this.onmso);
      ms.removeEventListener('sourceended', this.onmse);
      ms.removeEventListener('sourceclose', this.onmsc);

      // Detach properly the MediaSource from the HTMLMediaElement as
      // suggested in https://github.com/w3c/media-source/issues/53.
      if (this.media) {
        URL.revokeObjectURL(this._objectUrl);

        // clean up video tag src only if it's our own url. some external libraries might
        // hijack the video tag and change its 'src' without destroying the Hls instance first
        if (this.media.src === this._objectUrl) {
          this.media.removeAttribute('src');
          this.media.load();
        } else {
          _logger.logger.warn('media.src was changed by a third party - skip cleanup');
        }
      }

      this.mediaSource = null;
      this.media = null;
      this._objectUrl = null;
      this.pendingTracks = {};
      this.tracks = {};
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
    this.onmso = this.onmse = this.onmsc = null;
    this.hls.trigger(_events2.default.MEDIA_DETACHED);
  };

  BufferController.prototype.onMediaSourceOpen = function onMediaSourceOpen() {
    _logger.logger.log('media source opened');
    this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
    var mediaSource = this.mediaSource;
    if (mediaSource) {
      // once received, don't listen anymore to sourceopen event
      mediaSource.removeEventListener('sourceopen', this.onmso);
    }
    this.checkPendingTracks();
  };

  BufferController.prototype.checkPendingTracks = function checkPendingTracks() {
    // if any buffer codecs pending, check if we have enough to create sourceBuffers
    var pendingTracks = this.pendingTracks,
        pendingTracksNb = Object.keys(pendingTracks).length;
    // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
    if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
      // ok, let's create them now !
      this.createSourceBuffers(pendingTracks);
      this.pendingTracks = {};
      // append any pending segments now !
      this.doAppending();
    }
  };

  BufferController.prototype.onMediaSourceClose = function onMediaSourceClose() {
    _logger.logger.log('media source closed');
  };

  BufferController.prototype.onMediaSourceEnded = function onMediaSourceEnded() {
    _logger.logger.log('media source ended');
  };

  BufferController.prototype.onSBUpdateEnd = function onSBUpdateEnd() {
    // update timestampOffset
    if (this.audioTimestampOffset) {
      var audioBuffer = this.sourceBuffer.audio;
      _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
      audioBuffer.timestampOffset = this.audioTimestampOffset;
      delete this.audioTimestampOffset;
    }

    if (this._needsFlush) this.doFlush();

    if (this._needsEos) this.checkEos();

    this.appending = false;
    var parent = this.parent;
    // count nb of pending segments waiting for appending on this sourcebuffer
    var pending = this.segments.reduce(function (counter, segment) {
      return segment.parent === parent ? counter + 1 : counter;
    }, 0);

    // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
    var timeRanges = {};
    var sourceBuffer = this.sourceBuffer;
    for (var streamType in sourceBuffer) {
      timeRanges[streamType] = sourceBuffer[streamType].buffered;
    }this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
    // don't append in flushing mode
    if (!this._needsFlush) this.doAppending();

    this.updateMediaElementDuration();
  };

  BufferController.prototype.onSBUpdateError = function onSBUpdateError(event) {
    _logger.logger.error('sourceBuffer error:', event);
    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
    // this error might not always be fatal (it is fatal if decode error is set, in that case
    // it will be followed by a mediaElement error ...)
    this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
  };

  BufferController.prototype.onBufferReset = function onBufferReset() {
    var sourceBuffer = this.sourceBuffer;
    for (var type in sourceBuffer) {
      var sb = sourceBuffer[type];
      try {
        this.mediaSource.removeSourceBuffer(sb);
        sb.removeEventListener('updateend', this.onsbue);
        sb.removeEventListener('error', this.onsbe);
      } catch (err) {}
    }
    this.sourceBuffer = {};
    this.flushRange = [];
    this.segments = [];
    this.appended = 0;
  };

  BufferController.prototype.onBufferCodecs = function onBufferCodecs(tracks) {
    // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
    // if sourcebuffers already created, do nothing ...
    if (Object.keys(this.sourceBuffer).length === 0) {
      for (var trackName in tracks) {
        this.pendingTracks[trackName] = tracks[trackName];
      }var mediaSource = this.mediaSource;
      if (mediaSource && mediaSource.readyState === 'open') {
        // try to create sourcebuffers if mediasource opened
        this.checkPendingTracks();
      }
    }
  };

  BufferController.prototype.createSourceBuffers = function createSourceBuffers(tracks) {
    var sourceBuffer = this.sourceBuffer,
        mediaSource = this.mediaSource;

    for (var trackName in tracks) {
      if (!sourceBuffer[trackName]) {
        var track = tracks[trackName];
        // use levelCodec as first priority
        var codec = track.levelCodec || track.codec;
        var mimeType = track.container + ';codecs=' + codec;
        _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
        try {
          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
          sb.addEventListener('updateend', this.onsbue);
          sb.addEventListener('error', this.onsbe);
          this.tracks[trackName] = { codec: codec, container: track.container };
          track.buffer = sb;
        } catch (err) {
          _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
        }
      }
    }
    this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
  };

  BufferController.prototype.onBufferAppending = function onBufferAppending(data) {
    if (!this._needsFlush) {
      if (!this.segments) this.segments = [data];else this.segments.push(data);

      this.doAppending();
    }
  };

  BufferController.prototype.onBufferAppendFail = function onBufferAppendFail(data) {
    _logger.logger.error('sourceBuffer error:', data.event);
    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
    // this error might not always be fatal (it is fatal if decode error is set, in that case
    // it will be followed by a mediaElement error ...)
    this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
  };

  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()


  BufferController.prototype.onBufferEos = function onBufferEos(data) {
    var sb = this.sourceBuffer;
    var dataType = data.type;
    for (var type in sb) {
      if (!dataType || type === dataType) {
        if (!sb[type].ended) {
          sb[type].ended = true;
          _logger.logger.log(type + ' sourceBuffer now EOS');
        }
      }
    }
    this.checkEos();
  };

  // if all source buffers are marked as ended, signal endOfStream() to MediaSource.


  BufferController.prototype.checkEos = function checkEos() {
    var sb = this.sourceBuffer,
        mediaSource = this.mediaSource;
    if (!mediaSource || mediaSource.readyState !== 'open') {
      this._needsEos = false;
      return;
    }
    for (var type in sb) {
      var sbobj = sb[type];
      if (!sbobj.ended) return;

      if (sbobj.updating) {
        this._needsEos = true;
        return;
      }
    }
    _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
    // Notify the media element that it now has all of the media data
    try {
      mediaSource.endOfStream();
    } catch (e) {
      _logger.logger.warn('exception while calling mediaSource.endOfStream()');
    }
    this._needsEos = false;
  };

  BufferController.prototype.onBufferFlushing = function onBufferFlushing(data) {
    this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
    // attempt flush immediately
    this.flushBufferCounter = 0;
    this.doFlush();
  };

  BufferController.prototype.onLevelUpdated = function onLevelUpdated(_ref) {
    var details = _ref.details;

    if (details.fragments.length > 0) {
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this._live = details.live;
      this.updateMediaElementDuration();
    }
  };

  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */


  BufferController.prototype.updateMediaElementDuration = function updateMediaElementDuration() {
    var config = this.hls.config;

    var duration = void 0;

    if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') return;

    for (var type in this.sourceBuffer) {
      if (this.sourceBuffer[type].updating === true) {
        // can't set duration whilst a buffer is updating
        return;
      }
    }

    duration = this.media.duration;
    // initialise to the value that the media source is reporting
    if (this._msDuration === null) this._msDuration = this.mediaSource.duration;

    if (this._live === true && config.liveDurationInfinity === true) {
      // Override duration to Infinity
      _logger.logger.log('Media Source duration is set to Infinity');
      this._msDuration = this.mediaSource.duration = Infinity;
    } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || duration === Infinity || isNaN(duration)) {
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update Media Source duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      _logger.logger.log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
      this._msDuration = this.mediaSource.duration = this._levelDuration;
    }
  };

  BufferController.prototype.doFlush = function doFlush() {
    // loop through all buffer ranges to flush
    while (this.flushRange.length) {
      var range = this.flushRange[0];
      // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
      if (this.flushBuffer(range.start, range.end, range.type)) {
        // range flushed, remove from flush array
        this.flushRange.shift();
        this.flushBufferCounter = 0;
      } else {
        this._needsFlush = true;
        // avoid looping, wait for SB update end to retrigger a flush
        return;
      }
    }
    if (this.flushRange.length === 0) {
      // everything flushed
      this._needsFlush = false;

      // let's recompute this.appended, which is used to avoid flush looping
      var appended = 0;
      var sourceBuffer = this.sourceBuffer;
      try {
        for (var type in sourceBuffer) {
          appended += sourceBuffer[type].buffered.length;
        }
      } catch (error) {
        // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
        // this is harmess at this stage, catch this to avoid reporting an internal exception
        _logger.logger.error('error while accessing sourceBuffer.buffered');
      }
      this.appended = appended;
      this.hls.trigger(_events2.default.BUFFER_FLUSHED);
    }
  };

  BufferController.prototype.doAppending = function doAppending() {
    var hls = this.hls,
        sourceBuffer = this.sourceBuffer,
        segments = this.segments;
    if (Object.keys(sourceBuffer).length) {
      if (this.media.error) {
        this.segments = [];
        _logger.logger.error('trying to append although a media error occured, flush segment and abort');
        return;
      }
      if (this.appending) {
        // logger.log(`sb appending in progress`);
        return;
      }
      if (segments && segments.length) {
        var segment = segments.shift();
        try {
          var type = segment.type,
              sb = sourceBuffer[type];
          if (sb) {
            if (!sb.updating) {
              // reset sourceBuffer ended flag before appending segment
              sb.ended = false;
              // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
              this.parent = segment.parent;
              sb.appendBuffer(segment.data);
              this.appendError = 0;
              this.appended++;
              this.appending = true;
            } else {
              segments.unshift(segment);
            }
          } else {
            // in case we don't have any source buffer matching with this segment type,
            // it means that Mediasource fails to create sourcebuffer
            // discard this segment, and trigger update end
            this.onSBUpdateEnd();
          }
        } catch (err) {
          // in case any error occured while appending, put back segment in segments table
          _logger.logger.error('error while trying to append buffer:' + err.message);
          segments.unshift(segment);
          var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
          if (err.code !== 22) {
            if (this.appendError) this.appendError++;else this.appendError = 1;

            event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
            /* with UHD content, we could get loop of quota exceeded error until
              browser is able to evict some data from sourcebuffer. retrying help recovering this
            */
            if (this.appendError > hls.config.appendErrorMaxRetry) {
              _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
              segments = [];
              event.fatal = true;
              hls.trigger(_events2.default.ERROR, event);
            } else {
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
            }
          } else {
            // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
            // let's stop appending any segments, and report BUFFER_FULL_ERROR error
            this.segments = [];
            event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
            event.fatal = false;
            hls.trigger(_events2.default.ERROR, event);
          }
        }
      }
    }
  };

  /*
    flush specified buffered range,
    return true once range has been flushed.
    as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
  */


  BufferController.prototype.flushBuffer = function flushBuffer(startOffset, endOffset, typeIn) {
    var sb = void 0,
        i = void 0,
        bufStart = void 0,
        bufEnd = void 0,
        flushStart = void 0,
        flushEnd = void 0,
        sourceBuffer = this.sourceBuffer;
    if (Object.keys(sourceBuffer).length) {
      _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
      // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
      if (this.flushBufferCounter < this.appended) {
        for (var type in sourceBuffer) {
          // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
          // if no, let's flush all sourcebuffers
          if (typeIn && type !== typeIn) continue;

          sb = sourceBuffer[type];
          // we are going to flush buffer, mark source buffer as 'not ended'
          sb.ended = false;
          if (!sb.updating) {
            try {
              for (i = 0; i < sb.buffered.length; i++) {
                bufStart = sb.buffered.start(i);
                bufEnd = sb.buffered.end(i);
                // workaround firefox not able to properly flush multiple buffered range.
                if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                  flushStart = startOffset;
                  flushEnd = endOffset;
                } else {
                  flushStart = Math.max(bufStart, startOffset);
                  flushEnd = Math.min(bufEnd, endOffset);
                }
                /* sometimes sourcebuffer.remove() does not flush
                   the exact expected time range.
                   to avoid rounding issues/infinite loop,
                   only flush buffer range of length greater than 500ms.
                */
                if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                  this.flushBufferCounter++;
                  _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                  sb.remove(flushStart, flushEnd);
                  return false;
                }
              }
            } catch (e) {
              _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
            }
          } else {
            // logger.log('abort ' + type + ' append in progress');
            // this will abort any appending in progress
            // sb.abort();
            _logger.logger.warn('cannot flush, sb updating in progress');
            return false;
          }
        }
      } else {
        _logger.logger.warn('abort flushing too many retries');
      }
      _logger.logger.log('buffer flushed');
    }
    // everything flushed !
    return true;
  };

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/cap-level-controller.js":
/*!******************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/cap-level-controller.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    return _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
  }

  CapLevelController.prototype.destroy = function destroy() {
    if (this.hls.config.capLevelToPlayerSize) {
      this.media = this.restrictedLevels = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) this.timer = clearInterval(this.timer);
    }
  };

  CapLevelController.prototype.onFpsDropLevelCapping = function onFpsDropLevelCapping(data) {
    // Don't add a restricted level more than once
    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) this.restrictedLevels.push(data.droppedLevel);
  };

  CapLevelController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
  };

  CapLevelController.prototype.onManifestParsed = function onManifestParsed(data) {
    var hls = this.hls;
    this.restrictedLevels = [];
    // Only fire getMaxLevel or detectPlayerSize if video is expected in the manifest
    if (hls.config.capLevelToPlayerSize && (data.video || data.levels.length && data.altAudio)) {
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.levels = data.levels;
      hls.firstLevel = this.getMaxLevel(data.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  };

  CapLevelController.prototype.detectPlayerSize = function detectPlayerSize() {
    if (this.media) {
      var levelsLength = this.levels ? this.levels.length : 0;
      if (levelsLength) {
        var hls = this.hls;
        hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
        if (hls.autoLevelCapping > this.autoLevelCapping) {
          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
          // usually happen when the user go to the fullscreen mode.
          hls.streamController.nextLevelSwitch();
        }
        this.autoLevelCapping = hls.autoLevelCapping;
      }
    }
  };

  /*
  * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
  */


  CapLevelController.prototype.getMaxLevel = function getMaxLevel(capLevelIndex) {
    var _this2 = this;

    if (!this.levels) return -1;

    var validLevels = this.levels.filter(function (level, index) {
      return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
    });

    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
  };

  CapLevelController.isLevelAllowed = function isLevelAllowed(level) {
    var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    return restrictedLevels.indexOf(level) === -1;
  };

  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
    if (!levels || levels && !levels.length) return -1;

    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
    // to determine whether we've chosen the greatest bandwidth for the media's dimensions
    var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
      if (!nextLevel) return true;

      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
    };

    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
    // the max level
    var maxLevelIndex = levels.length - 1;

    for (var i = 0; i < levels.length; i += 1) {
      var level = levels[i];
      if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
        maxLevelIndex = i;
        break;
      }
    }

    return maxLevelIndex;
  };

  _createClass(CapLevelController, [{
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/eme-controller.js":
/*!************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/eme-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * DRM support for Hls.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var MAX_LICENSE_REQUEST_FAILURES = 3;

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
  WIDEVINE: 'com.widevine.alpha',
  PLAYREADY: 'com.microsoft.playready'
};

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    videoCapabilities: [
      // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
    ]
  };

  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: 'video/mp4; codecs="' + codec + '"'
    });
  });

  return [baseConfig];
};

/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs) {
  switch (keySystem) {
    case KeySystems.WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
    default:
      throw Error('Unknown key-system: ' + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */

var EMEController = function (_EventHandler) {
  _inherits(EMEController, _EventHandler);

  /**
     * @constructs
     * @param {Hls} hls Our Hls.js instance
     */
  function EMEController(hls) {
    _classCallCheck(this, EMEController);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MANIFEST_PARSED));

    _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
    _this._licenseXhrSetup = hls.config.licenseXhrSetup;
    _this._emeEnabled = hls.config.emeEnabled;

    _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;

    _this._mediaKeysList = [];
    _this._media = null;

    _this._hasSetMediaKeys = false;
    _this._isMediaEncrypted = false;

    _this._requestLicenseFailureCount = 0;
    return _this;
  }

  /**
     *
     * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
     * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
     */


  EMEController.prototype.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
    var url = void 0;
    switch (keySystem) {
      case KeySystems.WIDEVINE:
        url = this._widevineLicenseUrl;
        break;
      default:
        url = null;
        break;
    }

    if (!url) {
      _logger.logger.error('No license server URL configured for key-system "' + keySystem + '"');
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
        fatal: true
      });
    }

    return url;
  };

  /**
     * Requests access object and adds it to our list upon success
     * @private
     * @param {string} keySystem System ID (see `KeySystems`)
     * @param {Array<string>} audioCodecs List of required audio codecs to support
     * @param {Array<string>} videoCodecs List of required video codecs to support
     */


  EMEController.prototype._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
    var _this2 = this;

    // TODO: add other DRM "options"

    var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);

    if (!mediaKeySystemConfigs) {
      _logger.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
      return;
    }

    _logger.logger.log('Requesting encrypted media key-system access');

    // expecting interface like window.navigator.requestMediaKeySystemAccess
    this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs).then(function (mediaKeySystemAccess) {
      _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
    }).catch(function (err) {
      _logger.logger.error('Failed to obtain key-system "' + keySystem + '" access:', err);
    });
  };

  /**
     * Handles obtaining access to a key-system
     *
     * @param {string} keySystem
     * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
     */
  EMEController.prototype._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
    var _this3 = this;

    _logger.logger.log('Access for key-system "' + keySystem + '" obtained');

    var mediaKeysListItem = {
      mediaKeys: null,
      mediaKeysSession: null,
      mediaKeysSessionInitialized: false,
      mediaKeySystemAccess: mediaKeySystemAccess,
      mediaKeySystemDomain: keySystem
    };

    this._mediaKeysList.push(mediaKeysListItem);

    mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {
      mediaKeysListItem.mediaKeys = mediaKeys;

      _logger.logger.log('Media-keys created for key-system "' + keySystem + '"');

      _this3._onMediaKeysCreated();
    }).catch(function (err) {
      _logger.logger.error('Failed to create media-keys:', err);
    });
  };

  /**
     * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
     * for all existing keys where no session exists yet.
     */


  EMEController.prototype._onMediaKeysCreated = function _onMediaKeysCreated() {
    var _this4 = this;

    // check for all key-list items if a session exists, otherwise, create one
    this._mediaKeysList.forEach(function (mediaKeysListItem) {
      if (!mediaKeysListItem.mediaKeysSession) {
        mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
        _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
      }
    });
  };

  /**
     *
     * @param {*} keySession
     */


  EMEController.prototype._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {
    var _this5 = this;

    _logger.logger.log('New key-system session ' + keySession.sessionId);

    keySession.addEventListener('message', function (event) {
      _this5._onKeySessionMessage(keySession, event.message);
    }, false);
  };

  EMEController.prototype._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {
    _logger.logger.log('Got EME message event, creating license request');

    this._requestLicense(message, function (data) {
      _logger.logger.log('Received license data, updating key-session');
      keySession.update(data);
    });
  };

  EMEController.prototype._onMediaEncrypted = function _onMediaEncrypted(initDataType, initData) {
    _logger.logger.log('Media is encrypted using "' + initDataType + '" init data type');

    this._isMediaEncrypted = true;
    this._mediaEncryptionInitDataType = initDataType;
    this._mediaEncryptionInitData = initData;

    this._attemptSetMediaKeys();
    this._generateRequestWithPreferredKeySession();
  };

  EMEController.prototype._attemptSetMediaKeys = function _attemptSetMediaKeys() {
    if (!this._hasSetMediaKeys) {
      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem || !keysListItem.mediaKeys) {
        _logger.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_KEYS,
          fatal: true
        });
        return;
      }

      _logger.logger.log('Setting keys for encrypted media');

      this._media.setMediaKeys(keysListItem.mediaKeys);
      this._hasSetMediaKeys = true;
    }
  };

  EMEController.prototype._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession() {
    var _this6 = this;

    // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
    var keysListItem = this._mediaKeysList[0];
    if (!keysListItem) {
      _logger.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
        fatal: true
      });
      return;
    }

    if (keysListItem.mediaKeysSessionInitialized) {
      _logger.logger.warn('Key-Session already initialized but requested again');
      return;
    }

    var keySession = keysListItem.mediaKeysSession;
    if (!keySession) {
      _logger.logger.error('Fatal: Media is encrypted but no key-session existing');
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
        fatal: true
      });
    }

    var initDataType = this._mediaEncryptionInitDataType;
    var initData = this._mediaEncryptionInitData;

    _logger.logger.log('Generating key-session request for "' + initDataType + '" init data type');

    keysListItem.mediaKeysSessionInitialized = true;

    keySession.generateRequest(initDataType, initData).then(function () {
      _logger.logger.debug('Key-session generation succeeded');
    }).catch(function (err) {
      _logger.logger.error('Error generating key-session request:', err);
      _this6.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
        fatal: false
      });
    });
  };

  /**
     * @param {string} url License server URL
     * @param {ArrayBuffer} keyMessage Message data issued by key-system
     * @param {function} callback Called when XHR has succeeded
     * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
     */


  EMEController.prototype._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {
    var xhr = new XMLHttpRequest();
    var licenseXhrSetup = this._licenseXhrSetup;

    try {
      if (licenseXhrSetup) {
        try {
          licenseXhrSetup(xhr, url);
        } catch (e) {
          // let's try to open before running setup
          xhr.open('POST', url, true);
          licenseXhrSetup(xhr, url);
        }
      }
      // if licenseXhrSetup did not yet call open, let's do it now
      if (!xhr.readyState) xhr.open('POST', url, true);
    } catch (e) {
      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
      _logger.logger.error('Error setting up key-system license XHR', e);
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
        fatal: true
      });
      return;
    }

    xhr.responseType = 'arraybuffer';
    xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
    return xhr;
  };

  /**
     * @param {XMLHttpRequest} xhr
     * @param {string} url License server URL
     * @param {ArrayBuffer} keyMessage Message data issued by key-system
     * @param {function} callback Called when XHR has succeeded
     *
     */


  EMEController.prototype._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
    switch (xhr.readyState) {
      case 4:
        if (xhr.status === 200) {
          this._requestLicenseFailureCount = 0;
          _logger.logger.log('License request succeeded');
          callback(xhr.response);
        } else {
          _logger.logger.error('License Request XHR failed (' + url + '). Status: ' + xhr.status + ' (' + xhr.statusText + ')');

          this._requestLicenseFailureCount++;
          if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
            var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
            _logger.logger.warn('Retrying license request, ' + attemptsLeft + ' attempts left');
            this._requestLicense(keyMessage, callback);
            return;
          }

          this.hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
            details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
            fatal: true
          });
        }
        break;
    }
  };

  /**
     * @param {object} keysListItem
     * @param {ArrayBuffer} keyMessage
     * @returns {ArrayBuffer} Challenge data posted to license server
     */


  EMEController.prototype._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
    var challenge = void 0;

    if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
      _logger.logger.error('PlayReady is not supported (yet)');

      // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
      /*
        if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
            // For PlayReady CDMs, we need to dig the Challenge out of the XML.
            var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
            if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
            } else {
                throw 'Cannot find <Challenge> in key message';
            }
            var headerNames = keyMessageXml.getElementsByTagName('name');
            var headerValues = keyMessageXml.getElementsByTagName('value');
            if (headerNames.length !== headerValues.length) {
                throw 'Mismatched header <name>/<value> pair in key message';
            }
            for (var i = 0; i < headerNames.length; i++) {
                xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
            }
        }
        */
    } else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
      // For Widevine CDMs, the challenge is the keyMessage.
      challenge = keyMessage;
    } else {
      _logger.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
    }

    return challenge;
  };

  EMEController.prototype._requestLicense = function _requestLicense(keyMessage, callback) {
    _logger.logger.log('Requesting content license for key-system');

    var keysListItem = this._mediaKeysList[0];
    if (!keysListItem) {
      _logger.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
        details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
        fatal: true
      });
      return;
    }

    var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
    var xhr = this._createLicenseXhr(url, keyMessage, callback);

    _logger.logger.log('Sending license request to URL: ' + url);

    xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
  };

  EMEController.prototype.onMediaAttached = function onMediaAttached(data) {
    var _this7 = this;

    if (!this._emeEnabled) return;

    var media = data.media;

    // keep reference of media
    this._media = media;

    // FIXME: also handle detaching media !

    media.addEventListener('encrypted', function (e) {
      _this7._onMediaEncrypted(e.initDataType, e.initData);
    });
  };

  EMEController.prototype.onManifestParsed = function onManifestParsed(data) {
    if (!this._emeEnabled) return;

    var audioCodecs = data.levels.map(function (level) {
      return level.audioCodec;
    });
    var videoCodecs = data.levels.map(function (level) {
      return level.videoCodec;
    });

    this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
  };

  _createClass(EMEController, [{
    key: 'requestMediaKeySystemAccess',
    get: function get() {
      if (!this._requestMediaKeySystemAccess) throw new Error('No requestMediaKeySystemAccess function configured');

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}(_eventHandler2.default);

exports.default = EMEController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/fps-controller.js":
/*!************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/fps-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  FPSController.prototype.destroy = function destroy() {
    if (this.timer) clearInterval(this.timer);

    this.isVideoPlaybackQualityAvailable = false;
  };

  FPSController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    var config = this.hls.config;
    if (config.capLevelOnFPSDrop) {
      var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
      if (typeof video.getVideoPlaybackQuality === 'function') this.isVideoPlaybackQualityAvailable = true;

      clearInterval(this.timer);
      this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
    }
  };

  FPSController.prototype.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
    var currentTime = performance.now();
    if (decodedFrames) {
      if (this.lastTime) {
        var currentPeriod = currentTime - this.lastTime,
            currentDropped = droppedFrames - this.lastDroppedFrames,
            currentDecoded = decodedFrames - this.lastDecodedFrames,
            droppedFPS = 1000 * currentDropped / currentPeriod,
            hls = this.hls;
        hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
        if (droppedFPS > 0) {
          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
            var currentLevel = hls.currentLevel;
            _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
              currentLevel = currentLevel - 1;
              hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
              hls.autoLevelCapping = currentLevel;
              hls.streamController.nextLevelSwitch();
            }
          }
        }
      }
      this.lastTime = currentTime;
      this.lastDroppedFrames = droppedFrames;
      this.lastDecodedFrames = decodedFrames;
    }
  };

  FPSController.prototype.checkFPSInterval = function checkFPSInterval() {
    var video = this.video;
    if (video) {
      if (this.isVideoPlaybackQualityAvailable) {
        var videoPlaybackQuality = video.getVideoPlaybackQuality();
        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
      } else {
        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
      }
    }
  };

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/subtitle-stream-controller.js":
/*!************************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/subtitle-stream-controller.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./third_party/hlsjs/src/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./third_party/hlsjs/src/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING'
};

var SubtitleStreamController = function (_TaskLoop) {
  _inherits(SubtitleStreamController, _TaskLoop);

  function SubtitleStreamController(hls) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, _TaskLoop.call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.ERROR, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.state = State.STOPPED;
    _this.currentTrackId = -1;
    _this.decrypter = new _decrypter2.default(hls.observer, hls.config);
    return _this;
  }

  SubtitleStreamController.prototype.onHandlerDestroyed = function onHandlerDestroyed() {
    this.state = State.STOPPED;
  };

  // Remove all queued items and create a new, empty queue for each track.


  SubtitleStreamController.prototype.clearVttFragQueues = function clearVttFragQueues() {
    var _this2 = this;

    this.vttFragQueues = {};
    this.tracks.forEach(function (track) {
      _this2.vttFragQueues[track.id] = [];
    });
  };

  // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.


  SubtitleStreamController.prototype.nextFrag = function nextFrag() {
    if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
      var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
      this.fragCurrent = frag;
      this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
      this.state = State.FRAG_LOADING;
    }
  };

  // When fragment has finished processing, add sn to list of completed if successful.


  SubtitleStreamController.prototype.onSubtitleFragProcessed = function onSubtitleFragProcessed(data) {
    if (data.success) this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);

    this.currentlyProcessing = null;
    this.state = State.IDLE;
    this.nextFrag();
  };

  SubtitleStreamController.prototype.onMediaAttached = function onMediaAttached() {
    this.state = State.IDLE;
  };

  // If something goes wrong, procede to next frag, if we were processing one.


  SubtitleStreamController.prototype.onError = function onError(data) {
    var frag = data.frag;
    // don't handle frag error not related to subtitle fragment
    if (frag && frag.type !== 'subtitle') return;

    if (this.currentlyProcessing) {
      this.currentlyProcessing = null;
      this.nextFrag();
    }
  };

  SubtitleStreamController.prototype.doTick = function doTick() {
    var _this3 = this;

    switch (this.state) {
      case State.IDLE:
        var tracks = this.tracks;
        var trackId = this.currentTrackId;

        var processedFragSNs = this.vttFragSNsProcessed[trackId],
            fragQueue = this.vttFragQueues[trackId],
            currentFragSN = this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

        var alreadyProcessed = function alreadyProcessed(frag) {
          return processedFragSNs.indexOf(frag.sn) > -1;
        };

        var alreadyInQueue = function alreadyInQueue(frag) {
          return fragQueue.some(function (fragInQueue) {
            return fragInQueue.sn === frag.sn;
          });
        };

        // exit if tracks don't exist
        if (!tracks) break;

        var trackDetails;

        if (trackId < tracks.length) trackDetails = tracks[trackId].details;

        if (typeof trackDetails === 'undefined') break;

        // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
        trackDetails.fragments.forEach(function (frag) {
          if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
            // Load key if subtitles are encrypted
            if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
              _logger.logger.log('Loading key for ' + frag.sn);
              _this3.state = State.KEY_LOADING;
              _this3.hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
            } else {
              // Frags don't know their subtitle track ID, so let's just add that...
              frag.trackId = trackId;
              fragQueue.push(frag);
              _this3.nextFrag();
            }
          }
        });
    }
  };

  // Got all new subtitle tracks.


  SubtitleStreamController.prototype.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(data) {
    var _this4 = this;

    _logger.logger.log('subtitle tracks updated');
    this.tracks = data.subtitleTracks;
    this.clearVttFragQueues();
    this.vttFragSNsProcessed = {};
    this.tracks.forEach(function (track) {
      _this4.vttFragSNsProcessed[track.id] = [];
    });
  };

  SubtitleStreamController.prototype.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(data) {
    this.currentTrackId = data.id;
    if (this.currentTrackId === -1) return;

    // Check if track was already loaded and if so make sure we finish
    // downloading its frags, if not all have been downloaded yet
    var currentTrack = this.tracks[this.currentTrackId];
    var details = currentTrack.details;
    if (details !== undefined) this.tick();
  };

  // Got a new set of subtitle fragments.


  SubtitleStreamController.prototype.onSubtitleTrackLoaded = function onSubtitleTrackLoaded() {
    this.tick();
  };

  SubtitleStreamController.prototype.onKeyLoaded = function onKeyLoaded() {
    if (this.state === State.KEY_LOADING) {
      this.state = State.IDLE;
      this.tick();
    }
  };

  SubtitleStreamController.prototype.onFragLoaded = function onFragLoaded(data) {
    var fragCurrent = this.fragCurrent,
        decryptData = data.frag.decryptdata;
    var fragLoaded = data.frag,
        hls = this.hls;
    if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
      // check to see if the payload needs to be decrypted
      if (data.payload.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.method === 'AES-128') {
        var startTime = void 0;
        try {
          startTime = performance.now();
        } catch (error) {
          startTime = Date.now();
        }
        // decrypt the subtitles
        this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
          var endTime = void 0;
          try {
            endTime = performance.now();
          } catch (error) {
            endTime = Date.now();
          }
          hls.trigger(_events2.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
        });
      }
    }
  };

  return SubtitleStreamController;
}(_taskLoop2.default);

exports.default = SubtitleStreamController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/subtitle-track-controller.js":
/*!***********************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/subtitle-track-controller.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * subtitle track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    if (textTrackList[i].kind === 'subtitles') tracks.push(textTrackList[i]);
  }
  return tracks;
}

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;

    /**
     * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
     */
    _this.subtitleDisplay = false;
    return _this;
  }

  SubtitleTrackController.prototype._onTextTracksChanged = function _onTextTracksChanged() {
    // Media is undefined when switching streams via loadSource()
    if (!this.media) return;

    var trackId = -1;
    var tracks = filterSubtitleTracks(this.media.textTracks);
    for (var id = 0; id < tracks.length; id++) {
      if (tracks[id].mode === 'hidden') {
        // Do not break in case there is a following track with showing.
        trackId = id;
      } else if (tracks[id].mode === 'showing') {
        trackId = id;
        break;
      }
    }

    // Setting current subtitleTrack will invoke code.
    this.subtitleTrack = trackId;
  };

  SubtitleTrackController.prototype.destroy = function destroy() {
    _eventHandler2.default.prototype.destroy.call(this);
  };

  // Listen for subtitle track change, then extract the current track ID.


  SubtitleTrackController.prototype.onMediaAttached = function onMediaAttached(data) {
    var _this2 = this;

    this.media = data.media;
    if (!this.media) return;

    if (this.queuedDefaultTrack !== undefined) {
      this.subtitleTrack = this.queuedDefaultTrack;
      delete this.queuedDefaultTrack;
    }

    this.trackChangeListener = this._onTextTracksChanged.bind(this);

    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
    if (this.useTextTrackPolling) {
      this.subtitlePollingInterval = setInterval(function () {
        _this2.trackChangeListener();
      }, 500);
    } else {
      this.media.textTracks.addEventListener('change', this.trackChangeListener);
    }
  };

  SubtitleTrackController.prototype.onMediaDetaching = function onMediaDetaching() {
    if (!this.media) return;

    if (this.useTextTrackPolling) clearInterval(this.subtitlePollingInterval);else this.media.textTracks.removeEventListener('change', this.trackChangeListener);

    this.media = undefined;
  };

  // Reset subtitle tracks on manifest loading


  SubtitleTrackController.prototype.onManifestLoading = function onManifestLoading() {
    this.tracks = [];
    this.trackId = -1;
  };

  // Fired whenever a new manifest is loaded.


  SubtitleTrackController.prototype.onManifestLoaded = function onManifestLoaded(data) {
    var _this3 = this;

    var tracks = data.subtitles || [];
    this.tracks = tracks;
    this.trackId = -1;
    this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

    // loop through available subtitle tracks and autoselect default if needed
    // TODO: improve selection logic to handle forced, etc
    tracks.forEach(function (track) {
      if (track.default) {
        // setting this.subtitleTrack will trigger internal logic
        // if media has not been attached yet, it will fail
        // we keep a reference to the default track id
        // and we'll set subtitleTrack when onMediaAttached is triggered
        if (_this3.media) _this3.subtitleTrack = track.id;else _this3.queuedDefaultTrack = track.id;
      }
    });
  };

  // Trigger subtitle track playlist reload.


  SubtitleTrackController.prototype.onTick = function onTick() {
    var trackId = this.trackId;
    var subtitleTrack = this.tracks[trackId];
    if (!subtitleTrack) return;

    var details = subtitleTrack.details;
    // check if we need to load playlist for this subtitle Track
    if (details === undefined || details.live === true) {
      // track not retrieved yet, or live playlist we need to (re)load it
      _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
      this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
    }
  };

  SubtitleTrackController.prototype.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
    var _this4 = this;

    if (data.id < this.tracks.length) {
      _logger.logger.log('subtitle track ' + data.id + ' loaded');
      this.tracks[data.id].details = data.details;
      // check if current playlist is a live playlist
      if (data.details.live && !this.timer) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        this.timer = setInterval(function () {
          _this4.onTick();
        }, 1000 * data.details.targetduration, this);
      }
      if (!data.details.live && this.timer) {
        // playlist is not live and timer is armed : stopping it
        clearInterval(this.timer);
        this.timer = null;
      }
    }
  };

  /** get alternate subtitle tracks list from playlist **/


  SubtitleTrackController.prototype.setSubtitleTrackInternal = function setSubtitleTrackInternal(newId) {
    // check if level idx is valid
    if (newId < -1 || newId >= this.tracks.length) return;

    // stopping live reloading timer if any
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }

    var textTracks = filterSubtitleTracks(this.media.textTracks);

    // hide currently enabled subtitle track
    if (this.trackId !== -1) textTracks[this.trackId].mode = 'disabled';

    this.trackId = newId;
    _logger.logger.log('switching to subtitle track ' + newId);
    this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });

    if (newId === -1) return;

    var subtitleTrack = this.tracks[newId];
    if (newId < textTracks.length) textTracks[newId].mode = this.subtitleDisplay ? 'showing' : 'hidden';

    // check if we need to load playlist for this subtitle Track
    var details = subtitleTrack.details;
    if (details === undefined || details.live === true) {
      // track not retrieved yet, or live playlist we need to (re)load it
      _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
      this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
    }
  };

  _createClass(SubtitleTrackController, [{
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

exports.default = SubtitleTrackController;

/***/ }),

/***/ "./third_party/hlsjs/src/controller/timeline-controller.js":
/*!*****************************************************************!*\
  !*** ./third_party/hlsjs/src/controller/timeline-controller.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = __webpack_require__(/*! ../utils/cea-608-parser */ "./third_party/hlsjs/src/utils/cea-608-parser.js");

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _outputFilter = __webpack_require__(/*! ../utils/output-filter */ "./third_party/hlsjs/src/utils/output-filter.js");

var _outputFilter2 = _interopRequireDefault(_outputFilter);

var _webvttParser = __webpack_require__(/*! ../utils/webvtt-parser */ "./third_party/hlsjs/src/utils/webvtt-parser.js");

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./third_party/hlsjs/src/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.FRAG_DECRYPTED, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];
    _this.captionsTracks = {};

    _this.captionsProperties = {
      textTrack1: {
        label: _this.config.captionsTextTrack1Label,
        languageCode: _this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: _this.config.captionsTextTrack2Label,
        languageCode: _this.config.captionsTextTrack2LanguageCode
      }
    };

    if (_this.config.enableCEA708Captions) {
      var channel1 = new _outputFilter2.default(_this, 'textTrack1');
      var channel2 = new _outputFilter2.default(_this, 'textTrack2');

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  TimelineController.prototype.addCues = function addCues(trackName, startTime, endTime, screen) {
    // skip cues which overlap more than 50% with previously parsed time ranges
    var ranges = this.cueRanges;
    var merged = false;
    for (var i = ranges.length; i--;) {
      var cueRange = ranges[i];
      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
      if (overlap >= 0) {
        cueRange[0] = Math.min(cueRange[0], startTime);
        cueRange[1] = Math.max(cueRange[1], endTime);
        merged = true;
        if (overlap / (endTime - startTime) > 0.5) return;
      }
    }
    if (!merged) ranges.push([startTime, endTime]);

    this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
  };

  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.


  TimelineController.prototype.onInitPtsFound = function onInitPtsFound(data) {
    var _this2 = this;

    if (typeof this.initPTS === 'undefined') this.initPTS = data.initPTS;

    // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
    // Parse any unparsed fragments upon receiving the initial PTS.
    if (this.unparsedVttFrags.length) {
      this.unparsedVttFrags.forEach(function (frag) {
        _this2.onFragLoaded(frag);
      });
      this.unparsedVttFrags = [];
    }
  };

  TimelineController.prototype.getExistingTrack = function getExistingTrack(trackName) {
    var media = this.media;

    if (media) {
      for (var i = 0; i < media.textTracks.length; i++) {
        var textTrack = media.textTracks[i];
        if (textTrack[trackName]) return textTrack;
      }
    }
    return null;
  };

  TimelineController.prototype.createCaptionsTrack = function createCaptionsTrack(trackName) {
    var _captionsProperties$t = this.captionsProperties[trackName],
        label = _captionsProperties$t.label,
        languageCode = _captionsProperties$t.languageCode;

    var captionsTracks = this.captionsTracks;
    if (!captionsTracks[trackName]) {
      // Enable reuse of existing text track.
      var existingTrack = this.getExistingTrack(trackName);
      if (!existingTrack) {
        var textTrack = this.createTextTrack('captions', label, languageCode);
        if (textTrack) {
          // Set a special property on the track so we know it's managed by Hls.js
          textTrack[trackName] = true;
          captionsTracks[trackName] = textTrack;
        }
      } else {
        captionsTracks[trackName] = existingTrack;
        (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
        (0, _texttrackUtils.sendAddTrackEvent)(captionsTracks[trackName], this.media);
      }
    }
  };

  TimelineController.prototype.createTextTrack = function createTextTrack(kind, label, lang) {
    var media = this.media;
    if (media) return media.addTextTrack(kind, label, lang);
  };

  TimelineController.prototype.destroy = function destroy() {
    _eventHandler2.default.prototype.destroy.call(this);
  };

  TimelineController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    this.media = data.media;
    this._cleanTracks();
  };

  TimelineController.prototype.onMediaDetaching = function onMediaDetaching() {
    var captionsTracks = this.captionsTracks;

    Object.keys(captionsTracks).forEach(function (trackName) {
      (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
      delete captionsTracks[trackName];
    });
  };

  TimelineController.prototype.onManifestLoading = function onManifestLoading() {
    this.lastSn = -1; // Detect discontiguity in fragment parsing
    this.prevCC = -1;
    this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests
    this._cleanTracks();
  };

  TimelineController.prototype._cleanTracks = function _cleanTracks() {
    // clear outdated subtitles
    var media = this.media;
    if (media) {
      var textTracks = media.textTracks;
      if (textTracks) {
        for (var i = 0; i < textTracks.length; i++) {
          (0, _texttrackUtils.clearCurrentCues)(textTracks[i]);
        }
      }
    }
  };

  TimelineController.prototype.onManifestLoaded = function onManifestLoaded(data) {
    var _this3 = this;

    this.textTracks = [];
    this.unparsedVttFrags = this.unparsedVttFrags || [];
    this.initPTS = undefined;
    this.cueRanges = [];

    if (this.config.enableWebVTT) {
      this.tracks = data.subtitles || [];
      var inUseTracks = this.media ? this.media.textTracks : [];

      this.tracks.forEach(function (track, index) {
        var textTrack = void 0;
        if (index < inUseTracks.length) {
          var inUseTrack = inUseTracks[index];
          // Reuse tracks with the same label, but do not reuse 608/708 tracks
          if (reuseVttTextTrack(inUseTrack, track)) textTrack = inUseTrack;
        }
        if (!textTrack) textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);

        if (track.default) textTrack.mode = _this3.hls.subtitleDisplay ? 'showing' : 'hidden';else textTrack.mode = 'disabled';

        _this3.textTracks.push(textTrack);
      });
    }
  };

  TimelineController.prototype.onLevelSwitching = function onLevelSwitching() {
    this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
  };

  TimelineController.prototype.onFragLoaded = function onFragLoaded(data) {
    var frag = data.frag,
        payload = data.payload;
    if (frag.type === 'main') {
      var sn = frag.sn;
      // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
      if (sn !== this.lastSn + 1) {
        var cea608Parser = this.cea608Parser;
        if (cea608Parser) cea608Parser.reset();
      }
      this.lastSn = sn;
    } // eslint-disable-line brace-style
    // If fragment is subtitle type, parse as WebVTT.
    else if (frag.type === 'subtitle') {
        if (payload.byteLength) {
          // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
          if (typeof this.initPTS === 'undefined') {
            this.unparsedVttFrags.push(data);
            return;
          }

          var decryptData = frag.decryptdata;
          // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
          if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') this._parseVTTs(frag, payload);
        } else {
          // In case there is no payload, finish unsuccessfully.
          this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
        }
      }
  };

  TimelineController.prototype._parseVTTs = function _parseVTTs(frag, payload) {
    var vttCCs = this.vttCCs;
    if (!vttCCs[frag.cc]) {
      vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
      this.prevCC = frag.cc;
    }
    var textTracks = this.textTracks,
        hls = this.hls;

    // Parse the WebVTT file contents.
    _webvttParser2.default.parse(payload, this.initPTS, vttCCs, frag.cc, function (cues) {
      var currentTrack = textTracks[frag.trackId];
      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
      // and trying to access getCueById method of cues will throw an exception
      if (currentTrack.mode === 'disabled') {
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
        return;
      }
      // Add cues and trigger event with success true.
      cues.forEach(function (cue) {
        // Sometimes there are cue overlaps on segmented vtts so the same
        // cue can appear more than once in different vtt files.
        // This avoid showing duplicated cues with same timecode and text.
        if (!currentTrack.cues.getCueById(cue.id)) {
          try {
            currentTrack.addCue(cue);
          } catch (err) {
            var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
            textTrackCue.id = cue.id;
            currentTrack.addCue(textTrackCue);
          }
        }
      });
      hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
    }, function (e) {
      // Something went wrong while parsing. Trigger event with success false.
      _logger.logger.log('Failed to parse VTT cue: ' + e);
      hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
    });
  };

  TimelineController.prototype.onFragDecrypted = function onFragDecrypted(data) {
    var decryptedData = data.payload,
        frag = data.frag;

    if (frag.type === 'subtitle') {
      if (typeof this.initPTS === 'undefined') {
        this.unparsedVttFrags.push(data);
        return;
      }

      this._parseVTTs(frag, decryptedData);
    }
  };

  TimelineController.prototype.onFragParsingUserdata = function onFragParsingUserdata(data) {
    // push all of the CEA-708 messages into the interpreter
    // immediately. It will create the proper timestamps based on our PTS value
    if (this.enabled && this.config.enableCEA708Captions) {
      for (var i = 0; i < data.samples.length; i++) {
        var ccdatas = this.extractCea608Data(data.samples[i].bytes);
        this.cea608Parser.addData(data.samples[i].pts, ccdatas);
      }
    }
  };

  TimelineController.prototype.extractCea608Data = function extractCea608Data(byteArray) {
    var count = byteArray[0] & 31;
    var position = 2;
    var tmpByte = void 0,
        ccbyte1 = void 0,
        ccbyte2 = void 0,
        ccValid = void 0,
        ccType = void 0;
    var actualCCBytes = [];

    for (var j = 0; j < count; j++) {
      tmpByte = byteArray[position++];
      ccbyte1 = 0x7F & byteArray[position++];
      ccbyte2 = 0x7F & byteArray[position++];
      ccValid = (4 & tmpByte) !== 0;
      ccType = 3 & tmpByte;

      if (ccbyte1 === 0 && ccbyte2 === 0) continue;

      if (ccValid) {
        if (ccType === 0) {
          // || ccType === 1
          actualCCBytes.push(ccbyte1);
          actualCCBytes.push(ccbyte2);
        }
      }
    }
    return actualCCBytes;
  };

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;

/***/ }),

/***/ "./third_party/hlsjs/src/crypt/aes-crypto.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/crypt/aes-crypto.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  AESCrypto.prototype.decrypt = function decrypt(data, key) {
    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
  };

  return AESCrypto;
}();

exports.default = AESCrypto;

/***/ }),

/***/ "./third_party/hlsjs/src/crypt/aes-decryptor.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/crypt/aes-decryptor.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.removePadding = removePadding;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PKCS7
function removePadding(buffer) {
  var outputBytes = buffer.byteLength;
  var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
  if (paddingBytes) return buffer.slice(0, outputBytes - paddingBytes);else return buffer;
}

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  AESDecryptor.prototype.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
    var view = new DataView(arrayBuffer);
    var newArray = new Uint32Array(4);
    for (var i = 0; i < 4; i++) {
      newArray[i] = view.getUint32(i * 4);
    }return newArray;
  };

  AESDecryptor.prototype.initTable = function initTable() {
    var sBox = this.sBox;
    var invSBox = this.invSBox;
    var subMix = this.subMix;
    var subMix0 = subMix[0];
    var subMix1 = subMix[1];
    var subMix2 = subMix[2];
    var subMix3 = subMix[3];
    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var d = new Uint32Array(256);
    var x = 0;
    var xi = 0;
    var i = 0;
    for (i = 0; i < 256; i++) {
      if (i < 128) d[i] = i << 1;else d[i] = i << 1 ^ 0x11b;
    }

    for (i = 0; i < 256; i++) {
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
      sBox[x] = sx;
      invSBox[sx] = x;

      // Compute multiplication
      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4];

      // Compute sub/invSub bytes, mix columns tables
      var t = d[sx] * 0x101 ^ sx * 0x1010100;
      subMix0[x] = t << 24 | t >>> 8;
      subMix1[x] = t << 16 | t >>> 16;
      subMix2[x] = t << 8 | t >>> 24;
      subMix3[x] = t;

      // Compute inv sub bytes, inv mix columns tables
      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
      invSubMix0[sx] = t << 24 | t >>> 8;
      invSubMix1[sx] = t << 16 | t >>> 16;
      invSubMix2[sx] = t << 8 | t >>> 24;
      invSubMix3[sx] = t;

      // Compute next counter
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  };

  AESDecryptor.prototype.expandKey = function expandKey(keyBuffer) {
    // convert keyBuffer to Uint32Array
    var key = this.uint8ArrayToUint32Array_(keyBuffer);
    var sameKey = true;
    var offset = 0;

    while (offset < key.length && sameKey) {
      sameKey = key[offset] === this.key[offset];
      offset++;
    }

    if (sameKey) return;

    this.key = key;
    var keySize = this.keySize = key.length;

    if (keySize !== 4 && keySize !== 6 && keySize !== 8) throw new Error('Invalid aes key size=' + keySize);

    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
    var ksRow = void 0;
    var invKsRow = void 0;

    var keySchedule = this.keySchedule = new Uint32Array(ksRows);
    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
    var sbox = this.sBox;
    var rcon = this.rcon;

    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var prev = void 0;
    var t = void 0;

    for (ksRow = 0; ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        prev = keySchedule[ksRow] = key[ksRow];
        continue;
      }
      t = prev;

      if (ksRow % keySize === 0) {
        // Rot word
        t = t << 8 | t >>> 24;

        // Sub word
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

        // Mix Rcon
        t ^= rcon[ksRow / keySize | 0] << 24;
      } else if (keySize > 6 && ksRow % keySize === 4) {
        // Sub word
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
      }

      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
    }

    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
      ksRow = ksRows - invKsRow;
      if (invKsRow & 3) t = keySchedule[ksRow];else t = keySchedule[ksRow - 4];

      if (invKsRow < 4 || ksRow <= 4) invKeySchedule[invKsRow] = t;else invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];

      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
    }
  };

  // Adding this as a method greatly improves performance.


  AESDecryptor.prototype.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
  };

  AESDecryptor.prototype.decrypt = function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
    var nRounds = this.keySize + 6;
    var invKeySchedule = this.invKeySchedule;
    var invSBOX = this.invSBox;

    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var initVector = this.uint8ArrayToUint32Array_(aesIV);
    var initVector0 = initVector[0];
    var initVector1 = initVector[1];
    var initVector2 = initVector[2];
    var initVector3 = initVector[3];

    var inputInt32 = new Int32Array(inputArrayBuffer);
    var outputInt32 = new Int32Array(inputInt32.length);

    var t0 = void 0,
        t1 = void 0,
        t2 = void 0,
        t3 = void 0;
    var s0 = void 0,
        s1 = void 0,
        s2 = void 0,
        s3 = void 0;
    var inputWords0 = void 0,
        inputWords1 = void 0,
        inputWords2 = void 0,
        inputWords3 = void 0;

    var ksRow = void 0,
        i = void 0;
    var swapWord = this.networkToHostOrderSwap;

    while (offset < inputInt32.length) {
      inputWords0 = swapWord(inputInt32[offset]);
      inputWords1 = swapWord(inputInt32[offset + 1]);
      inputWords2 = swapWord(inputInt32[offset + 2]);
      inputWords3 = swapWord(inputInt32[offset + 3]);

      s0 = inputWords0 ^ invKeySchedule[0];
      s1 = inputWords3 ^ invKeySchedule[1];
      s2 = inputWords2 ^ invKeySchedule[2];
      s3 = inputWords1 ^ invKeySchedule[3];

      ksRow = 4;

      // Iterate through the rounds of decryption
      for (i = 1; i < nRounds; i++) {
        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        // Update state
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;

        ksRow = ksRow + 4;
      }

      // Shift rows, sub bytes, add round key
      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
      ksRow = ksRow + 3;

      // Write
      outputInt32[offset] = swapWord(t0 ^ initVector0);
      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

      // reset initVector to last 4 unsigned int
      initVector0 = inputWords0;
      initVector1 = inputWords1;
      initVector2 = inputWords2;
      initVector3 = inputWords3;

      offset = offset + 4;
    }

    return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
  };

  AESDecryptor.prototype.destroy = function destroy() {
    this.key = undefined;
    this.keySize = undefined;
    this.ksRows = undefined;

    this.sBox = undefined;
    this.invSBox = undefined;
    this.subMix = undefined;
    this.invSubMix = undefined;
    this.keySchedule = undefined;
    this.invKeySchedule = undefined;

    this.rcon = undefined;
  };

  return AESDecryptor;
}();

exports.default = AESDecryptor;

/***/ }),

/***/ "./third_party/hlsjs/src/crypt/decrypter.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/crypt/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _aesCrypto = __webpack_require__(/*! ./aes-crypto */ "./third_party/hlsjs/src/crypt/aes-crypto.js");

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = __webpack_require__(/*! ./fast-aes-key */ "./third_party/hlsjs/src/crypt/fast-aes-key.js");

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = __webpack_require__(/*! ./aes-decryptor */ "./third_party/hlsjs/src/crypt/aes-decryptor.js");

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* globals self: false */

var Decrypter = function () {
  function Decrypter(observer, config) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;

    _classCallCheck(this, Decrypter);

    this.logEnabled = true;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding;
    // built in decryptor expects PKCS7 padding
    if (removePKCS7Padding) {
      try {
        var browserCrypto = crypto || self.crypto;
        this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
      } catch (e) {}
    }
    this.disableWebCrypto = !this.subtle;
  }

  Decrypter.prototype.isSync = function isSync() {
    return this.disableWebCrypto && this.config.enableSoftwareAES;
  };

  Decrypter.prototype.decrypt = function decrypt(data, key, iv, callback) {
    var _this = this;

    if (this.disableWebCrypto && this.config.enableSoftwareAES) {
      if (this.logEnabled) {
        _logger.logger.log('JS AES decrypt');
        this.logEnabled = false;
      }
      var decryptor = this.decryptor;
      if (!decryptor) this.decryptor = decryptor = new _aesDecryptor2.default();

      decryptor.expandKey(key);
      callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
    } else {
      if (this.logEnabled) {
        _logger.logger.log('WebCrypto AES decrypt');
        this.logEnabled = false;
      }
      var subtle = this.subtle;
      if (this.key !== key) {
        this.key = key;
        this.fastAesKey = new _fastAesKey2.default(subtle, key);
      }

      this.fastAesKey.expandKey().then(function (aesKey) {
        // decrypt using web crypto
        var crypto = new _aesCrypto2.default(subtle, iv);
        crypto.decrypt(data, aesKey).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        }).then(function (result) {
          callback(result);
        });
      }).catch(function (err) {
        _this.onWebCryptoError(err, data, key, iv, callback);
      });
    }
  };

  Decrypter.prototype.onWebCryptoError = function onWebCryptoError(err, data, key, iv, callback) {
    if (this.config.enableSoftwareAES) {
      _logger.logger.log('WebCrypto Error, disable WebCrypto API');
      this.disableWebCrypto = true;
      this.logEnabled = true;
      this.decrypt(data, key, iv, callback);
    } else {
      _logger.logger.error('decrypting error : ' + err.message);
      this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
    }
  };

  Decrypter.prototype.destroy = function destroy() {
    var decryptor = this.decryptor;
    if (decryptor) {
      decryptor.destroy();
      this.decryptor = undefined;
    }
  };

  return Decrypter;
}();

exports.default = Decrypter;

/***/ }),

/***/ "./third_party/hlsjs/src/crypt/fast-aes-key.js":
/*!*****************************************************!*\
  !*** ./third_party/hlsjs/src/crypt/fast-aes-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  FastAESKey.prototype.expandKey = function expandKey() {
    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
  };

  return FastAESKey;
}();

exports.default = FastAESKey;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/aacdemuxer.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/demux/aacdemuxer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _adts = __webpack_require__(/*! ./adts */ "./third_party/hlsjs/src/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _id = __webpack_require__(/*! ../demux/id3 */ "./third_party/hlsjs/src/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * AAC demuxer
                                                                                                                                                           */


var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  AACDemuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
  };

  AACDemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  AACDemuxer.probe = function probe(data) {
    if (!data) return false;

    // Check for the ADTS sync word
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    var id3Data = _id2.default.getID3Data(data, 0) || [];
    var offset = id3Data.length;

    for (var length = data.length; offset < length; offset++) {
      if (ADTS.probe(data, offset)) {
        _logger.logger.log('ADTS sync word found !');
        return true;
      }
    }
    return false;
  };

  // feed incoming data to the front of the parsing pipeline


  AACDemuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var track = this._audioTrack;
    var id3Data = _id2.default.getID3Data(data, 0) || [];
    var timestamp = _id2.default.getTimeStamp(id3Data);
    var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
    var frameIndex = 0;
    var stamp = pts;
    var length = data.length;
    var offset = id3Data.length;

    var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

    while (offset < length - 1) {
      if (ADTS.isHeader(data, offset) && offset + 5 < length) {
        ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
        var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          _logger.logger.log('Unable to parse AAC frame');
          break;
        }
      } else if (_id2.default.isHeader(data, offset)) {
        id3Data = _id2.default.getID3Data(data, offset);
        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
        offset += id3Data.length;
      } else {
        // nothing found, keep looking
        offset++;
      }
    }

    this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
  };

  AACDemuxer.prototype.destroy = function destroy() {};

  return AACDemuxer;
}();

exports.default = AACDemuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/adts.js":
/*!*********************************************!*\
  !*** ./third_party/hlsjs/src/demux/adts.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getAudioConfig = getAudioConfig;
exports.isHeaderPattern = isHeaderPattern;
exports.getHeaderLength = getHeaderLength;
exports.getFullFrameLength = getFullFrameLength;
exports.isHeader = isHeader;
exports.probe = probe;
exports.initTrackConfig = initTrackConfig;
exports.getFrameDuration = getFrameDuration;
exports.parseFrameHeader = parseFrameHeader;
exports.appendFrame = appendFrame;

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

/**
 *  ADTS parser helper
 */
function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType = void 0,
      // :int
  adtsSampleingIndex = void 0,
      // :int
  adtsExtensionSampleingIndex = void 0,
      // :int
  adtsChanelConfig = void 0,
      // :int
  config = void 0,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) return true;

  return false;
}

function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) frameLength = getFullFrameLength(data, offset);

    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) return true;
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength = void 0,
      frameLength = void 0,
      stamp = void 0;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}

/***/ }),

/***/ "./third_party/hlsjs/src/demux/demuxer-inline.js":
/*!*******************************************************!*\
  !*** ./third_party/hlsjs/src/demux/demuxer-inline.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./third_party/hlsjs/src/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = __webpack_require__(/*! ../demux/aacdemuxer */ "./third_party/hlsjs/src/demux/aacdemuxer.js");

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./third_party/hlsjs/src/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = __webpack_require__(/*! ../demux/tsdemuxer */ "./third_party/hlsjs/src/demux/tsdemuxer.js");

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = __webpack_require__(/*! ../demux/mp3demuxer */ "./third_party/hlsjs/src/demux/mp3demuxer.js");

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = __webpack_require__(/*! ../remux/mp4-remuxer */ "./third_party/hlsjs/src/remux/mp4-remuxer.js");

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./third_party/hlsjs/src/remux/passthrough-remuxer.js");

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*  inline demuxer.
                                                                                                                                                           *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                           */

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  DemuxerInline.prototype.destroy = function destroy() {
    var demuxer = this.demuxer;
    if (demuxer) demuxer.destroy();
  };

  DemuxerInline.prototype.push = function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
    if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
      var decrypter = this.decrypter;
      if (decrypter == null) decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);

      var localthis = this;
      // performance.now() not available on WebWorker, at least on Safari Desktop
      var startTime = void 0;
      try {
        startTime = performance.now();
      } catch (error) {
        startTime = Date.now();
      }
      decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
        var endTime = void 0;
        try {
          endTime = performance.now();
        } catch (error) {
          endTime = Date.now();
        }
        localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
        localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      });
    } else {
      this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
    }
  };

  DemuxerInline.prototype.pushDecrypted = function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
    var demuxer = this.demuxer;
    if (!demuxer ||
    // in case of continuity change, or track switch
    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
    // so let's check that current demuxer is still valid
    (discontinuity || trackSwitch) && !this.probe(data)) {
      var observer = this.observer;
      var typeSupported = this.typeSupported;
      var config = this.config;
      // probing order is TS/AAC/MP3/MP4
      var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }];

      // probe for content type
      for (var i = 0, len = muxConfig.length; i < len; i++) {
        var mux = muxConfig[i];
        var probe = mux.demux.probe;
        if (probe(data)) {
          var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
          demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
          this.probe = probe;
          break;
        }
      }
      if (!demuxer) {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
        return;
      }
      this.demuxer = demuxer;
    }
    var remuxer = this.remuxer;

    if (discontinuity || trackSwitch) {
      demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
      remuxer.resetInitSegment();
    }
    if (discontinuity) {
      demuxer.resetTimeStamp(defaultInitPTS);
      remuxer.resetTimeStamp(defaultInitPTS);
    }
    if (typeof demuxer.setDecryptData === 'function') demuxer.setDecryptData(decryptdata);

    demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
  };

  return DemuxerInline;
}();

exports.default = DemuxerInline;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/demuxer-worker.js":
/*!*******************************************************!*\
  !*** ./third_party/hlsjs/src/demux/demuxer-worker.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./third_party/hlsjs/src/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _events3 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events4.default();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    // console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);
        try {
          (0, _logger.enableLogs)(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/demuxer.js":
/*!************************************************!*\
  !*** ./third_party/hlsjs/src/demux/demuxer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./third_party/hlsjs/src/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _demuxerWorker = __webpack_require__(/*! ../demux/demuxer-worker */ "./third_party/hlsjs/src/demux/demuxer-worker.js");

var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

var _events3 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var _events4 = _interopRequireDefault(_events3);

var _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ "./node_modules/webworkify-webpack/index.js");

var _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);

var _mediasourceHelper = __webpack_require__(/*! ../helper/mediasource-helper */ "./third_party/hlsjs/src/helper/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var Demuxer = function () {
  function Demuxer(hls, id) {
    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    // observer setup
    var observer = this.observer = new _events4.default();
    var config = hls.config;
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };

    var forwardMessage = function (ev, data) {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      hls.trigger(ev, data);
    }.bind(this);

    // forward events to main thread
    observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSED, forwardMessage);
    observer.on(_events2.default.ERROR, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        // new
        var _work = __webpack_require__(/*! webworkify */ "./node_modules/webworkify/index.js");
        w = this.w = _work(_demuxerWorker2.default);
        // old
        //w = this.w = work(require.resolve('../demux/demuxer-worker.js'));

        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  Demuxer.prototype.destroy = function destroy() {
    var w = this.w;
    if (w) {
      w.removeEventListener('message', this.onwmsg);
      w.terminate();
      this.w = null;
    } else {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
        this.demuxer = null;
      }
    }
    var observer = this.observer;
    if (observer) {
      observer.removeAllListeners();
      this.observer = null;
    }
  };

  Demuxer.prototype.push = function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
    var w = this.w;
    var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
    var decryptdata = frag.decryptdata;
    var lastFrag = this.frag;
    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
    var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
    var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
    var contiguous = !trackSwitch && nextSN;
    if (discontinuity) _logger.logger.log(this.id + ':discontinuity detected');

    if (trackSwitch) _logger.logger.log(this.id + ':switch detected');

    this.frag = frag;
    if (w) {
      // post fragment payload as transferable objects for ArrayBuffer (no copy)
      w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
    } else {
      var demuxer = this.demuxer;
      if (demuxer) demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
    }
  };

  Demuxer.prototype.onWorkerMessage = function onWorkerMessage(ev) {
    var data = ev.data,
        hls = this.hls;
    switch (data.event) {
      case 'init':
        // revoke the Object URL that was used to create demuxer worker, so as not to leak it
        URL.revokeObjectURL(this.w.objectURL);
        break;
      // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
      case _events2.default.FRAG_PARSING_DATA:
        data.data.data1 = new Uint8Array(data.data1);
        if (data.data2) data.data.data2 = new Uint8Array(data.data2);

      /* falls through */
      default:
        data.data = data.data || {};
        data.data.frag = this.frag;
        data.data.id = this.id;
        hls.trigger(data.event, data.data);
        break;
    }
  };

  return Demuxer;
}();

exports.default = Demuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/exp-golomb.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/demux/exp-golomb.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                          */

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  ExpGolomb.prototype.loadWord = function loadWord() {
    var data = this.data,
        bytesAvailable = this.bytesAvailable,
        position = data.byteLength - bytesAvailable,
        workingBytes = new Uint8Array(4),
        availableBytes = Math.min(4, bytesAvailable);
    if (availableBytes === 0) throw new Error('no bytes available');

    workingBytes.set(data.subarray(position, position + availableBytes));
    this.word = new DataView(workingBytes.buffer).getUint32(0);
    // track the amount of this.data that has been processed
    this.bitsAvailable = availableBytes * 8;
    this.bytesAvailable -= availableBytes;
  };

  // (count:int):void


  ExpGolomb.prototype.skipBits = function skipBits(count) {
    var skipBytes = void 0; // :int
    if (this.bitsAvailable > count) {
      this.word <<= count;
      this.bitsAvailable -= count;
    } else {
      count -= this.bitsAvailable;
      skipBytes = count >> 3;
      count -= skipBytes >> 3;
      this.bytesAvailable -= skipBytes;
      this.loadWord();
      this.word <<= count;
      this.bitsAvailable -= count;
    }
  };

  // (size:int):uint


  ExpGolomb.prototype.readBits = function readBits(size) {
    var bits = Math.min(this.bitsAvailable, size),
        // :uint
    valu = this.word >>> 32 - bits; // :uint
    if (size > 32) _logger.logger.error('Cannot read more than 32 bits at a time');

    this.bitsAvailable -= bits;
    if (this.bitsAvailable > 0) this.word <<= bits;else if (this.bytesAvailable > 0) this.loadWord();

    bits = size - bits;
    if (bits > 0 && this.bitsAvailable) return valu << bits | this.readBits(bits);else return valu;
  };

  // ():uint


  ExpGolomb.prototype.skipLZ = function skipLZ() {
    var leadingZeroCount = void 0; // :uint
    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
        // the first bit of working word is 1
        this.word <<= leadingZeroCount;
        this.bitsAvailable -= leadingZeroCount;
        return leadingZeroCount;
      }
    }
    // we exhausted word and still have not found a 1
    this.loadWord();
    return leadingZeroCount + this.skipLZ();
  };

  // ():void


  ExpGolomb.prototype.skipUEG = function skipUEG() {
    this.skipBits(1 + this.skipLZ());
  };

  // ():void


  ExpGolomb.prototype.skipEG = function skipEG() {
    this.skipBits(1 + this.skipLZ());
  };

  // ():uint


  ExpGolomb.prototype.readUEG = function readUEG() {
    var clz = this.skipLZ(); // :uint
    return this.readBits(clz + 1) - 1;
  };

  // ():int


  ExpGolomb.prototype.readEG = function readEG() {
    var valu = this.readUEG(); // :int
    if (0x01 & valu) {
      // the number is odd if the low order bit is set
      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
    } else {
      return -1 * (valu >>> 1); // divide by two then make it negative
    }
  };

  // Some convenience functions
  // :Boolean


  ExpGolomb.prototype.readBoolean = function readBoolean() {
    return this.readBits(1) === 1;
  };

  // ():int


  ExpGolomb.prototype.readUByte = function readUByte() {
    return this.readBits(8);
  };

  // ():int


  ExpGolomb.prototype.readUShort = function readUShort() {
    return this.readBits(16);
  };
  // ():int


  ExpGolomb.prototype.readUInt = function readUInt() {
    return this.readBits(32);
  };

  /**
   * Advance the ExpGolomb decoder past a scaling list. The scaling
   * list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count {number} the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */


  ExpGolomb.prototype.skipScalingList = function skipScalingList(count) {
    var lastScale = 8,
        nextScale = 8,
        j = void 0,
        deltaScale = void 0;
    for (j = 0; j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = this.readEG();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }
      lastScale = nextScale === 0 ? lastScale : nextScale;
    }
  };

  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @param data {Uint8Array} the bytes of a sequence parameter set
   * @return {object} an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */


  ExpGolomb.prototype.readSPS = function readSPS() {
    var frameCropLeftOffset = 0,
        frameCropRightOffset = 0,
        frameCropTopOffset = 0,
        frameCropBottomOffset = 0,
        profileIdc = void 0,
        profileCompat = void 0,
        levelIdc = void 0,
        numRefFramesInPicOrderCntCycle = void 0,
        picWidthInMbsMinus1 = void 0,
        picHeightInMapUnitsMinus1 = void 0,
        frameMbsOnlyFlag = void 0,
        scalingListCount = void 0,
        i = void 0,
        readUByte = this.readUByte.bind(this),
        readBits = this.readBits.bind(this),
        readUEG = this.readUEG.bind(this),
        readBoolean = this.readBoolean.bind(this),
        skipBits = this.skipBits.bind(this),
        skipEG = this.skipEG.bind(this),
        skipUEG = this.skipUEG.bind(this),
        skipScalingList = this.skipScalingList.bind(this);

    readUByte();
    profileIdc = readUByte(); // profile_idc
    profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
    skipBits(3); // reserved_zero_3bits u(3),
    levelIdc = readUByte(); // level_idc u(8)
    skipUEG(); // seq_parameter_set_id
    // some profiles have more optional data we don't need
    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
      var chromaFormatIdc = readUEG();
      if (chromaFormatIdc === 3) skipBits(1); // separate_colour_plane_flag

      skipUEG(); // bit_depth_luma_minus8
      skipUEG(); // bit_depth_chroma_minus8
      skipBits(1); // qpprime_y_zero_transform_bypass_flag
      if (readBoolean()) {
        // seq_scaling_matrix_present_flag
        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
        for (i = 0; i < scalingListCount; i++) {
          if (readBoolean()) {
            // seq_scaling_list_present_flag[ i ]
            if (i < 6) skipScalingList(16);else skipScalingList(64);
          }
        }
      }
    }
    skipUEG(); // log2_max_frame_num_minus4
    var picOrderCntType = readUEG();
    if (picOrderCntType === 0) {
      readUEG(); // log2_max_pic_order_cnt_lsb_minus4
    } else if (picOrderCntType === 1) {
      skipBits(1); // delta_pic_order_always_zero_flag
      skipEG(); // offset_for_non_ref_pic
      skipEG(); // offset_for_top_to_bottom_field
      numRefFramesInPicOrderCntCycle = readUEG();
      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
        skipEG();
      } // offset_for_ref_frame[ i ]
    }
    skipUEG(); // max_num_ref_frames
    skipBits(1); // gaps_in_frame_num_value_allowed_flag
    picWidthInMbsMinus1 = readUEG();
    picHeightInMapUnitsMinus1 = readUEG();
    frameMbsOnlyFlag = readBits(1);
    if (frameMbsOnlyFlag === 0) skipBits(1); // mb_adaptive_frame_field_flag

    skipBits(1); // direct_8x8_inference_flag
    if (readBoolean()) {
      // frame_cropping_flag
      frameCropLeftOffset = readUEG();
      frameCropRightOffset = readUEG();
      frameCropTopOffset = readUEG();
      frameCropBottomOffset = readUEG();
    }
    var pixelRatio = [1, 1];
    if (readBoolean()) {
      // vui_parameters_present_flag
      if (readBoolean()) {
        // aspect_ratio_info_present_flag
        var aspectRatioIdc = readUByte();
        switch (aspectRatioIdc) {
          case 1:
            pixelRatio = [1, 1];break;
          case 2:
            pixelRatio = [12, 11];break;
          case 3:
            pixelRatio = [10, 11];break;
          case 4:
            pixelRatio = [16, 11];break;
          case 5:
            pixelRatio = [40, 33];break;
          case 6:
            pixelRatio = [24, 11];break;
          case 7:
            pixelRatio = [20, 11];break;
          case 8:
            pixelRatio = [32, 11];break;
          case 9:
            pixelRatio = [80, 33];break;
          case 10:
            pixelRatio = [18, 11];break;
          case 11:
            pixelRatio = [15, 11];break;
          case 12:
            pixelRatio = [64, 33];break;
          case 13:
            pixelRatio = [160, 99];break;
          case 14:
            pixelRatio = [4, 3];break;
          case 15:
            pixelRatio = [3, 2];break;
          case 16:
            pixelRatio = [2, 1];break;
          case 255:
            {
              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
              break;
            }
        }
      }
    }
    return {
      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
      pixelRatio: pixelRatio
    };
  };

  ExpGolomb.prototype.readSliceType = function readSliceType() {
    // skip NALu type
    this.readUByte();
    // discard first_mb_in_slice
    this.readUEG();
    // return slice_type
    return this.readUEG();
  };

  return ExpGolomb;
}();

exports.default = ExpGolomb;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/id3.js":
/*!********************************************!*\
  !*** ./third_party/hlsjs/src/demux/id3.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  /**
   * Returns true if an ID3 header can be found at offset in data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {boolean} - True if an ID3 header is found
   */
  ID3.isHeader = function isHeader(data, offset) {
    /*
    * http://id3.org/id3v2.3.0
    * [0]     = 'I'
    * [1]     = 'D'
    * [2]     = '3'
    * [3,4]   = {Version}
    * [5]     = {Flags}
    * [6-9]   = {ID3 Size}
    *
    * An ID3v2 tag can be detected with the following pattern:
    *  $49 44 33 yy yy xx zz zz zz zz
    * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
    */
    if (offset + 10 <= data.length) {
      // look for 'ID3' identifier
      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
        // check version is within range
        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) return true;
        }
      }
    }

    return false;
  };

  /**
   * Returns true if an ID3 footer can be found at offset in data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {boolean} - True if an ID3 footer is found
   */


  ID3.isFooter = function isFooter(data, offset) {
    /*
    * The footer is a copy of the header, but with a different identifier
    */
    if (offset + 10 <= data.length) {
      // look for '3DI' identifier
      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
        // check version is within range
        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
          // check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) return true;
        }
      }
    }

    return false;
  };

  /**
   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {Uint8Array} - The block of data containing any ID3 tags found
   */


  ID3.getID3Data = function getID3Data(data, offset) {
    var front = offset;
    var length = 0;

    while (ID3.isHeader(data, offset)) {
      // ID3 header is 10 bytes
      length += 10;

      var size = ID3._readSize(data, offset + 6);
      length += size;

      if (ID3.isFooter(data, offset + 10)) {
        // ID3 footer is 10 bytes
        length += 10;
      }

      offset += length;
    }

    if (length > 0) return data.subarray(front, front + length);

    return undefined;
  };

  ID3._readSize = function _readSize(data, offset) {
    var size = 0;
    size = (data[offset] & 0x7f) << 21;
    size |= (data[offset + 1] & 0x7f) << 14;
    size |= (data[offset + 2] & 0x7f) << 7;
    size |= data[offset + 3] & 0x7f;
    return size;
  };

  /**
   * Searches for the Elementary Stream timestamp found in the ID3 data chunk
   * @param {Uint8Array} data - Block of data containing one or more ID3 tags
   * @return {number} - The timestamp
   */


  ID3.getTimeStamp = function getTimeStamp(data) {
    var frames = ID3.getID3Frames(data);
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      if (ID3.isTimeStampFrame(frame)) return ID3._readTimeStamp(frame);
    }

    return undefined;
  };

  /**
   * Returns true if the ID3 frame is an Elementary Stream timestamp frame
   * @param {ID3 frame} frame
   */


  ID3.isTimeStampFrame = function isTimeStampFrame(frame) {
    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
  };

  ID3._getFrameData = function _getFrameData(data) {
    /*
    Frame ID       $xx xx xx xx (four characters)
    Size           $xx xx xx xx
    Flags          $xx xx
    */
    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    var size = ID3._readSize(data, 4);

    // skip frame id, size, and flags
    var offset = 10;

    return { type: type, size: size, data: data.subarray(offset, offset + size) };
  };

  /**
   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
   * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
   * @return {ID3 frame[]} - Array of ID3 frame objects
   */


  ID3.getID3Frames = function getID3Frames(id3Data) {
    var offset = 0;
    var frames = [];

    while (ID3.isHeader(id3Data, offset)) {
      var size = ID3._readSize(id3Data, offset + 6);
      // skip past ID3 header
      offset += 10;
      var end = offset + size;
      // loop through frames in the ID3 tag
      while (offset + 8 < end) {
        var frameData = ID3._getFrameData(id3Data.subarray(offset));
        var frame = ID3._decodeFrame(frameData);
        if (frame) frames.push(frame);

        // skip frame header and frame data
        offset += frameData.size + 10;
      }

      if (ID3.isFooter(id3Data, offset)) offset += 10;
    }

    return frames;
  };

  ID3._decodeFrame = function _decodeFrame(frame) {
    if (frame.type === 'PRIV') return ID3._decodePrivFrame(frame);else if (frame.type[0] === 'T') return ID3._decodeTextFrame(frame);else if (frame.type[0] === 'W') return ID3._decodeURLFrame(frame);

    return undefined;
  };

  ID3._readTimeStamp = function _readTimeStamp(timeStampFrame) {
    if (timeStampFrame.data.byteLength === 8) {
      var data = new Uint8Array(timeStampFrame.data);
      // timestamp is 33 bit expressed as a big-endian eight-octet number,
      // with the upper 31 bits set to zero.
      var pts33Bit = data[3] & 0x1;
      var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;

      if (pts33Bit) timestamp += 47721858.84; // 2^32 / 90

      return Math.round(timestamp);
    }

    return undefined;
  };

  ID3._decodePrivFrame = function _decodePrivFrame(frame) {
    /*
    Format: <text string>\0<binary data>
    */
    if (frame.size < 2) return undefined;

    var owner = ID3._utf8ArrayToStr(frame.data, true);
    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

    return { key: frame.type, info: owner, data: privateData.buffer };
  };

  ID3._decodeTextFrame = function _decodeTextFrame(frame) {
    if (frame.size < 2) return undefined;

    if (frame.type === 'TXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */
      var index = 1;
      var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    } else {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Value}
      */
      var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
      return { key: frame.type, data: text };
    }
  };

  ID3._decodeURLFrame = function _decodeURLFrame(frame) {
    if (frame.type === 'WXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
      if (frame.size < 2) return undefined;

      var index = 1;
      var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    } else {
      /*
      Format:
      [0-?] = {URL}
      */
      var url = ID3._utf8ArrayToStr(frame.data);
      return { key: frame.type, data: url };
    }
  };

  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
  /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */


  ID3._utf8ArrayToStr = function _utf8ArrayToStr(array) {
    var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var len = array.length;
    var c = void 0;
    var char2 = void 0;
    var char3 = void 0;
    var out = '';
    var i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0x00 && exitOnNull) {
        return out;
      } else if (c === 0x00 || c === 0x03) {
        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
        continue;
      }
      switch (c >> 4) {
        case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
        case 12:case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
          break;
        default:
      }
    }
    return out;
  };

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

exports.default = ID3;
exports.utf8ArrayToStr = utf8ArrayToStr;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/mp3demuxer.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/demux/mp3demuxer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _id = __webpack_require__(/*! ../demux/id3 */ "./third_party/hlsjs/src/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./third_party/hlsjs/src/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * MP3 demuxer
                                                                                                                                                           */


var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  MP3Demuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
  };

  MP3Demuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  MP3Demuxer.probe = function probe(data) {
    // check if data contains ID3 timestamp and MPEG sync word
    var offset = void 0,
        length = void 0;
    var id3Data = _id2.default.getID3Data(data, 0);
    if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
      // More info http://www.mp3-tech.org/programmer/frame_header.html
      for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
        if (_mpegaudio2.default.probe(data, offset)) {
          _logger.logger.log('MPEG Audio sync word found !');
          return true;
        }
      }
    }
    return false;
  };

  // feed incoming data to the front of the parsing pipeline


  MP3Demuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var id3Data = _id2.default.getID3Data(data, 0);
    var timestamp = _id2.default.getTimeStamp(id3Data);
    var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
    var offset = id3Data.length;
    var length = data.length;
    var frameIndex = 0,
        stamp = 0;
    var track = this._audioTrack;

    var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

    while (offset < length) {
      if (_mpegaudio2.default.isHeader(data, offset)) {
        var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          // logger.log('Unable to parse Mpeg audio frame');
          break;
        }
      } else if (_id2.default.isHeader(data, offset)) {
        id3Data = _id2.default.getID3Data(data, offset);
        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
        offset += id3Data.length;
      } else {
        // nothing found, keep looking
        offset++;
      }
    }

    this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
  };

  MP3Demuxer.prototype.destroy = function destroy() {};

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/mp4demuxer.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/demux/mp4demuxer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * MP4 demuxer
                                                                                                                                                           */


var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  MP4Demuxer.prototype.resetTimeStamp = function resetTimeStamp(initPTS) {
    this.initPTS = initPTS;
  };

  MP4Demuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    // jshint unused:false
    if (initSegment && initSegment.byteLength) {
      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

      // default audio codec if nothing specified
      // TODO : extract that from initsegment
      if (audioCodec == null) audioCodec = 'mp4a.40.5';

      if (videoCodec == null) videoCodec = 'avc1.42e01e';

      var tracks = {};
      if (initData.audio && initData.video) {
        tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
      } else {
        if (initData.audio) tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };

        if (initData.video) tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
      }
      this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
    } else {
      if (audioCodec) this.audioCodec = audioCodec;

      if (videoCodec) this.videoCodec = videoCodec;
    }
  };

  MP4Demuxer.probe = function probe(data) {
    // ensure we find a moof box in the first 16 kB
    return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
  };

  MP4Demuxer.bin2str = function bin2str(buffer) {
    return String.fromCharCode.apply(null, buffer);
  };

  MP4Demuxer.readUint16 = function readUint16(buffer, offset) {
    if (buffer.data) {
      offset += buffer.start;
      buffer = buffer.data;
    }

    var val = buffer[offset] << 8 | buffer[offset + 1];

    return val < 0 ? 65536 + val : val;
  };

  MP4Demuxer.readUint32 = function readUint32(buffer, offset) {
    if (buffer.data) {
      offset += buffer.start;
      buffer = buffer.data;
    }

    var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
    return val < 0 ? 4294967296 + val : val;
  };

  MP4Demuxer.writeUint32 = function writeUint32(buffer, offset, value) {
    if (buffer.data) {
      offset += buffer.start;
      buffer = buffer.data;
    }
    buffer[offset] = value >> 24;
    buffer[offset + 1] = value >> 16 & 0xff;
    buffer[offset + 2] = value >> 8 & 0xff;
    buffer[offset + 3] = value & 0xff;
  };

  // Find the data for a box specified by its path


  MP4Demuxer.findBox = function findBox(data, path) {
    var results = [],
        i = void 0,
        size = void 0,
        type = void 0,
        end = void 0,
        subresults = void 0,
        start = void 0,
        endbox = void 0;

    if (data.data) {
      start = data.start;
      end = data.end;
      data = data.data;
    } else {
      start = 0;
      end = data.byteLength;
    }

    if (!path.length) {
      // short-circuit the search for empty paths
      return null;
    }

    for (i = start; i < end;) {
      size = MP4Demuxer.readUint32(data, i);
      type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
      endbox = size > 1 ? i + size : end;

      if (type === path[0]) {
        if (path.length === 1) {
          // this is the end of the path and we've found the box we were
          // looking for
          results.push({ data: data, start: i + 8, end: endbox });
        } else {
          // recursively search for the next box along the path
          subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
          if (subresults.length) results = results.concat(subresults);
        }
      }
      i = endbox;
    }

    // we've finished searching all of data
    return results;
  };

  MP4Demuxer.parseSegmentIndex = function parseSegmentIndex(initSegment) {
    var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
    var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

    var index = 0;
    var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
    var references = void 0;

    if (!sidx || !sidx[0]) return null;

    references = [];
    sidx = sidx[0];

    var version = sidx.data[0];

    // set initial offset, we skip the reference ID (not needed)
    index = version === 0 ? 8 : 16;

    var timescale = MP4Demuxer.readUint32(sidx, index);
    index += 4;

    // TODO: parse earliestPresentationTime and firstOffset
    // usually zero in our case
    var earliestPresentationTime = 0;
    var firstOffset = 0;

    if (version === 0) index += 8;else index += 16;

    // skip reserved
    index += 2;

    var startByte = sidx.end + firstOffset;

    var referencesCount = MP4Demuxer.readUint16(sidx, index);
    index += 2;

    for (var i = 0; i < referencesCount; i++) {
      var referenceIndex = index;

      var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
      referenceIndex += 4;

      var referenceSize = referenceInfo & 0x7FFFFFFF;
      var referenceType = (referenceInfo & 0x80000000) >>> 31;

      if (referenceType === 1) {
        console.warn('SIDX has hierarchical references (not supported)');
        return;
      }

      var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
      referenceIndex += 4;

      references.push({
        referenceSize: referenceSize,
        subsegmentDuration: subsegmentDuration, // unscaled
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });

      startByte += referenceSize;

      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
      // for |sapDelta|.
      referenceIndex += 4;

      // skip to next ref
      index = referenceIndex;
    }

    return {
      earliestPresentationTime: earliestPresentationTime,
      timescale: timescale,
      version: version,
      referencesCount: referencesCount,
      references: references,
      moovEndOffset: moovEndOffset
    };
  };

  /**
   * Parses an MP4 initialization segment and extracts stream type and
   * timescale values for any declared tracks. Timescale values indicate the
   * number of clock ticks per second to assume for time-based values
   * elsewhere in the MP4.
   *
   * To determine the start time of an MP4, you need two pieces of
   * information: the timescale unit and the earliest base media decode
   * time. Multiple timescales can be specified within an MP4 but the
   * base media decode time is always expressed in the timescale from
   * the media header box for the track:
   * ```
   * moov > trak > mdia > mdhd.timescale
   * moov > trak > mdia > hdlr
   * ```
   * @param init {Uint8Array} the bytes of the init segment
   * @return {object} a hash of track type to timescale values or null if
   * the init segment is malformed.
   */


  MP4Demuxer.parseInitSegment = function parseInitSegment(initSegment) {
    var result = [];
    var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

    traks.forEach(function (trak) {
      var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
      if (tkhd) {
        var version = tkhd.data[tkhd.start];
        var index = version === 0 ? 12 : 20;
        var trackId = MP4Demuxer.readUint32(tkhd, index);

        var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          version = mdhd.data[mdhd.start];
          index = version === 0 ? 12 : 20;
          var timescale = MP4Demuxer.readUint32(mdhd, index);

          var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
          if (hdlr) {
            var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
            var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
            if (type) {
              // extract codec info. TODO : parse codec details to be able to build MIME type
              var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
              if (codecBox.length) {
                codecBox = codecBox[0];
                var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                _logger.logger.log('MP4Demuxer:' + type + ':' + codecType + ' found');
              }
              result[trackId] = { timescale: timescale, type: type };
              result[type] = { timescale: timescale, id: trackId };
            }
          }
        }
      }
    });
    return result;
  };

  /**
  * Determine the base media decode start time, in seconds, for an MP4
  * fragment. If multiple fragments are specified, the earliest time is
  * returned.
  *
  * The base media decode time can be parsed from track fragment
  * metadata:
  * ```
  * moof > traf > tfdt.baseMediaDecodeTime
  * ```
  * It requires the timescale value from the mdhd to interpret.
  *
  * @param timescale {object} a hash of track ids to timescale values.
  * @return {number} the earliest base media decode start time for the
  * fragment, in seconds
  */


  MP4Demuxer.getStartDTS = function getStartDTS(initData, fragment) {
    var trafs = void 0,
        baseTimes = void 0,
        result = void 0;

    // we need info from two childrend of each track fragment box
    trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

    // determine the start times for each track
    baseTimes = [].concat.apply([], trafs.map(function (traf) {
      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
        var id = void 0,
            scale = void 0,
            baseTime = void 0;

        // get the track id from the tfhd
        id = MP4Demuxer.readUint32(tfhd, 4);
        // assume a 90kHz clock if no timescale was specified
        scale = initData[id].timescale || 90e3;

        // get the base media decode time from the tfdt
        baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
          var version = void 0,
              result = void 0;

          version = tfdt.data[tfdt.start];
          result = MP4Demuxer.readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);

            result += MP4Demuxer.readUint32(tfdt, 8);
          }
          return result;
        })[0];
        // convert base time to seconds
        return baseTime / scale;
      });
    }));

    // return the minimum
    result = Math.min.apply(null, baseTimes);
    return isFinite(result) ? result : 0;
  };

  MP4Demuxer.offsetStartDTS = function offsetStartDTS(initData, fragment, timeOffset) {
    MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
        // get the track id from the tfhd
        var id = MP4Demuxer.readUint32(tfhd, 4);
        // assume a 90kHz clock if no timescale was specified
        var timescale = initData[id].timescale || 90e3;

        // get the base media decode time from the tfdt
        MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
          var version = tfdt.data[tfdt.start];
          var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
          if (version === 0) {
            MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
          } else {
            baseMediaDecodeTime *= Math.pow(2, 32);
            baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
            baseMediaDecodeTime -= timeOffset * timescale;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
            var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
            MP4Demuxer.writeUint32(tfdt, 4, upper);
            MP4Demuxer.writeUint32(tfdt, 8, lower);
          }
        });
      });
    });
  };

  // feed incoming data to the front of the parsing pipeline


  MP4Demuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var initData = this.initData;
    if (!initData) {
      this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
      initData = this.initData;
    }
    var startDTS = void 0,
        initPTS = this.initPTS;
    if (initPTS === undefined) {
      var _startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.initPTS = initPTS = _startDTS - timeOffset;
      this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
    }
    MP4Demuxer.offsetStartDTS(initData, data, initPTS);
    startDTS = MP4Demuxer.getStartDTS(initData, data);
    this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
  };

  MP4Demuxer.prototype.destroy = function destroy() {};

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/mpegaudio.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/demux/mpegaudio.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 *  MPEG parser helper
 */

var MpegAudio = {

  BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

  SamplesCoefficients: [
  // MPEG 2.5
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // Reserved
  [0, // Reserved
  0, // Layer3
  0, // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0, // Reserved
  144, // Layer3
  144, // Layer2
  12 // Layer1
  ]],

  BytesInSlot: [0, // Reserved
  1, // Layer3
  1, // Layer2
  4 // Layer1
  ],

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) return undefined;

    var header = this.parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      var stamp = pts + frameIndex * frameDuration;
      var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      track.len += header.frameLength;

      return { sample: sample, length: header.frameLength };
    }

    return undefined;
  },

  parseHeader: function parseHeader(data, offset) {
    var headerB = data[offset + 1] >> 3 & 3;
    var headerC = data[offset + 1] >> 1 & 3;
    var headerE = data[offset + 2] >> 4 & 15;
    var headerF = data[offset + 2] >> 2 & 3;
    var headerG = data[offset + 2] >> 1 & 1;
    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
      var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
      var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
      var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
      var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
      var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
      var bytesInSlot = MpegAudio.BytesInSlot[headerC];
      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

      return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
    }

    return undefined;
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  },

  isHeader: function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) return true;

    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // MPEG header Length
      var headerLength = 4;
      // MPEG frame Length
      var header = this.parseHeader(data, offset);
      var frameLength = headerLength;
      if (header && header.frameLength) frameLength = header.frameLength;

      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) return true;
    }
    return false;
  }
};

exports.default = MpegAudio;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/sample-aes.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/demux/sample-aes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./third_party/hlsjs/src/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * SAMPLE-AES decrypter
                                                                                                                                                          */

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config, { removePKCS7Padding: false });
  }

  SampleAesDecrypter.prototype.decryptBuffer = function decryptBuffer(encryptedData, callback) {
    this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
  };

  // AAC - encrypt all full 16 bytes blocks starting from offset 16


  SampleAesDecrypter.prototype.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {
    var curUnit = samples[sampleIndex].unit;
    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

    var localthis = this;
    this.decryptBuffer(encryptedBuffer, function (decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      curUnit.set(decryptedData, 16);

      if (!sync) localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
    });
  };

  SampleAesDecrypter.prototype.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
    for (;; sampleIndex++) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      if (samples[sampleIndex].unit.length < 32) continue;

      var sync = this.decrypter.isSync();

      this.decryptAacSample(samples, sampleIndex, callback, sync);

      if (!sync) return;
    }
  };

  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32


  SampleAesDecrypter.prototype.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
    var encryptedData = new Int8Array(encryptedDataLen);
    var outputPos = 0;
    for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
    }return encryptedData;
  };

  SampleAesDecrypter.prototype.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
    decryptedData = new Uint8Array(decryptedData);
    var inputPos = 0;
    for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
      decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
    }return decodedData;
  };

  SampleAesDecrypter.prototype.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
    var decodedData = this.discardEPB(curUnit.data);
    var encryptedData = this.getAvcEncryptedData(decodedData);
    var localthis = this;

    this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

      if (!sync) localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
    });
  };

  SampleAesDecrypter.prototype.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
    for (;; sampleIndex++, unitIndex = 0) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      var curUnits = samples[sampleIndex].units;
      for (;; unitIndex++) {
        if (unitIndex >= curUnits.length) break;

        var curUnit = curUnits[unitIndex];
        if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) continue;

        var sync = this.decrypter.isSync();

        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

        if (!sync) return;
      }
    }
  };

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;

/***/ }),

/***/ "./third_party/hlsjs/src/demux/tsdemuxer.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/demux/tsdemuxer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _adts = __webpack_require__(/*! ./adts */ "./third_party/hlsjs/src/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./third_party/hlsjs/src/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _expGolomb = __webpack_require__(/*! ./exp-golomb */ "./third_party/hlsjs/src/demux/exp-golomb.js");

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = __webpack_require__(/*! ./sample-aes */ "./third_party/hlsjs/src/demux/sample-aes.js");

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * highly optimized TS demuxer:
                                                                                                                                                           * parse PAT, PMT
                                                                                                                                                           * extract PES packet from audio and video PIDs
                                                                                                                                                           * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                           * trigger the remuxer upon parsing completion
                                                                                                                                                           * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                           * it also controls the remuxing process :
                                                                                                                                                           * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                          */

// import Hex from '../utils/hex';


// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 0,
  audio: 1,
  id3: 2,
  text: 3
};

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  TSDemuxer.prototype.setDecryptData = function setDecryptData(decryptdata) {
    if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);else this.sampleAes = null;
  };

  TSDemuxer.probe = function probe(data) {
    var syncOffset = TSDemuxer._syncOffset(data);
    if (syncOffset < 0) {
      return false;
    } else {
      if (syncOffset) _logger.logger.warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');

      return true;
    }
  };

  TSDemuxer._syncOffset = function _syncOffset(data) {
    // scan 1000 first bytes
    var scanwindow = Math.min(1000, data.length - 3 * 188);
    var i = 0;
    while (i < scanwindow) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) return i;else i++;
    }
    return -1;
  };

  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   *
   * @param {string} type 'audio' | 'video' | 'id3' | 'text'
   * @param {number} duration
   * @return {object} TSDemuxer's internal track model
   */


  TSDemuxer.createTrack = function createTrack(type, duration) {
    return {
      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
      type: type,
      id: RemuxerTrackIdConfig[type],
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      len: 0,
      dropped: type === 'video' ? 0 : undefined,
      isAAC: type === 'audio' ? true : undefined,
      duration: type === 'audio' ? duration : undefined
    };
  };

  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   *
   * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
   * @param {object} initSegment
   * @param {string} audioCodec
   * @param {string} videoCodec
   * @param {number} duration (in TS timescale = 90kHz)
   */


  TSDemuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this.pmtParsed = false;
    this._pmtId = -1;

    this._avcTrack = TSDemuxer.createTrack('video', duration);
    this._audioTrack = TSDemuxer.createTrack('audio', duration);
    this._id3Track = TSDemuxer.createTrack('id3', duration);
    this._txtTrack = TSDemuxer.createTrack('text', duration);

    // flush any partial content
    this.aacOverFlow = null;
    this.aacLastPTS = null;
    this.avcSample = null;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this._duration = duration;
  };

  /**
   *
   * @override
   */


  TSDemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  // feed incoming data to the front of the parsing pipeline


  TSDemuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var start = void 0,
        len = data.length,
        stt = void 0,
        pid = void 0,
        atf = void 0,
        offset = void 0,
        pes = void 0,
        unknownPIDs = false;
    this.contiguous = contiguous;
    var pmtParsed = this.pmtParsed,
        avcTrack = this._avcTrack,
        audioTrack = this._audioTrack,
        id3Track = this._id3Track,
        avcId = avcTrack.pid,
        audioId = audioTrack.pid,
        id3Id = id3Track.pid,
        pmtId = this._pmtId,
        avcData = avcTrack.pesData,
        audioData = audioTrack.pesData,
        id3Data = id3Track.pesData,
        parsePAT = this._parsePAT,
        parsePMT = this._parsePMT,
        parsePES = this._parsePES,
        parseAVCPES = this._parseAVCPES.bind(this),
        parseAACPES = this._parseAACPES.bind(this),
        parseMPEGPES = this._parseMPEGPES.bind(this),
        parseID3PES = this._parseID3PES.bind(this);

    var syncOffset = TSDemuxer._syncOffset(data);

    // don't parse last TS packet if incomplete
    len -= (len + syncOffset) % 188;

    // loop through TS packets
    for (start = syncOffset; start < len; start += 188) {
      if (data[start] === 0x47) {
        stt = !!(data[start + 1] & 0x40);
        // pid is a 13-bit field starting at the last bit of TS[1]
        pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
        atf = (data[start + 3] & 0x30) >> 4;
        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
        if (atf > 1) {
          offset = start + 5 + data[start + 4];
          // continue if there is only adaptation field
          if (offset === start + 188) continue;
        } else {
          offset = start + 4;
        }
        switch (pid) {
          case avcId:
            if (stt) {
              if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) parseAVCPES(pes, false);

              avcData = { data: [], size: 0 };
            }
            if (avcData) {
              avcData.data.push(data.subarray(offset, start + 188));
              avcData.size += start + 188 - offset;
            }
            break;
          case audioId:
            if (stt) {
              if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                if (audioTrack.isAAC) parseAACPES(pes);else parseMPEGPES(pes);
              }
              audioData = { data: [], size: 0 };
            }
            if (audioData) {
              audioData.data.push(data.subarray(offset, start + 188));
              audioData.size += start + 188 - offset;
            }
            break;
          case id3Id:
            if (stt) {
              if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) parseID3PES(pes);

              id3Data = { data: [], size: 0 };
            }
            if (id3Data) {
              id3Data.data.push(data.subarray(offset, start + 188));
              id3Data.size += start + 188 - offset;
            }
            break;
          case 0:
            if (stt) offset += data[offset] + 1;

            pmtId = this._pmtId = parsePAT(data, offset);
            break;
          case pmtId:
            if (stt) offset += data[offset] + 1;

            var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

            // only update track id if track PID found while parsing PMT
            // this is to avoid resetting the PID to -1 in case
            // track PID transiently disappears from the stream
            // this could happen in case of transient missing audio samples for example
            // NOTE this is only the PID of the track as found in TS,
            // but we are not using this for MP4 track IDs.
            avcId = parsedPIDs.avc;
            if (avcId > 0) avcTrack.pid = avcId;

            audioId = parsedPIDs.audio;
            if (audioId > 0) {
              audioTrack.pid = audioId;
              audioTrack.isAAC = parsedPIDs.isAAC;
            }
            id3Id = parsedPIDs.id3;
            if (id3Id > 0) id3Track.pid = id3Id;

            if (unknownPIDs && !pmtParsed) {
              _logger.logger.log('reparse from beginning');
              unknownPIDs = false;
              // we set it to -188, the += 188 in the for loop will reset start to 0
              start = syncOffset - 188;
            }
            pmtParsed = this.pmtParsed = true;
            break;
          case 17:
          case 0x1fff:
            break;
          default:
            unknownPIDs = true;
            break;
        }
      } else {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
      }
    }
    // try to parse last PES packets
    if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
      parseAVCPES(pes, true);
      avcTrack.pesData = null;
    } else {
      // either avcData null or PES truncated, keep it for next frag parsing
      avcTrack.pesData = avcData;
    }

    if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
      if (audioTrack.isAAC) parseAACPES(pes);else parseMPEGPES(pes);

      audioTrack.pesData = null;
    } else {
      if (audioData && audioData.size) _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');

      // either audioData null or PES truncated, keep it for next frag parsing
      audioTrack.pesData = audioData;
    }

    if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
      parseID3PES(pes);
      id3Track.pesData = null;
    } else {
      // either id3Data null or PES truncated, keep it for next frag parsing
      id3Track.pesData = id3Data;
    }

    if (this.sampleAes == null) this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);else this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
  };

  TSDemuxer.prototype.decryptAndRemux = function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    if (audioTrack.samples && audioTrack.isAAC) {
      var localthis = this;
      this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
        localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      });
    } else {
      this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
    }
  };

  TSDemuxer.prototype.decryptAndRemuxAvc = function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    if (videoTrack.samples) {
      var localthis = this;
      this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
        localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      });
    } else {
      this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
    }
  };

  TSDemuxer.prototype.destroy = function destroy() {
    this._initPTS = this._initDTS = undefined;
    this._duration = 0;
  };

  TSDemuxer.prototype._parsePAT = function _parsePAT(data, offset) {
    // skip the PSI header and parse the first PMT entry
    return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
    // logger.log('PMT PID:'  + this._pmtId);
  };

  TSDemuxer.prototype._parsePMT = function _parsePMT(data, offset, mpegSupported, isSampleAes) {
    var sectionLength = void 0,
        tableEnd = void 0,
        programInfoLength = void 0,
        pid = void 0,
        result = { audio: -1, avc: -1, id3: -1, isAAC: true };
    sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
    tableEnd = offset + 3 + sectionLength - 4;
    // to determine where the table is, we have to figure out how
    // long the program info descriptors are
    programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
    // advance the offset to the first entry in the mapping table
    offset += 12 + programInfoLength;
    while (offset < tableEnd) {
      pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
      switch (data[offset]) {
        case 0xcf:
          // SAMPLE-AES AAC
          if (!isSampleAes) {
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
          }
        /* falls through */

        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
        case 0x0f:
          // logger.log('AAC PID:'  + pid);
          if (result.audio === -1) result.audio = pid;

          break;

        // Packetized metadata (ID3)
        case 0x15:
          // logger.log('ID3 PID:'  + pid);
          if (result.id3 === -1) result.id3 = pid;

          break;

        case 0xdb:
          // SAMPLE-AES AVC
          if (!isSampleAes) {
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
          }
        /* falls through */

        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
        case 0x1b:
          // logger.log('AVC PID:'  + pid);
          if (result.avc === -1) result.avc = pid;

          break;

        // ISO/IEC 11172-3 (MPEG-1 audio)
        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
        case 0x03:
        case 0x04:
          // logger.log('MPEG PID:'  + pid);
          if (!mpegSupported) {
            _logger.logger.log('MPEG audio found, not supported in this browser for now');
          } else if (result.audio === -1) {
            result.audio = pid;
            result.isAAC = false;
          }
          break;

        case 0x24:
          _logger.logger.warn('HEVC stream type found, not supported for now');
          break;

        default:
          _logger.logger.log('unkown stream type:' + data[offset]);
          break;
      }
      // move to the next table entry
      // skip past the elementary stream descriptors, if present
      offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
    }
    return result;
  };

  TSDemuxer.prototype._parsePES = function _parsePES(stream) {
    var i = 0,
        frag = void 0,
        pesFlags = void 0,
        pesPrefix = void 0,
        pesLen = void 0,
        pesHdrLen = void 0,
        pesData = void 0,
        pesPts = void 0,
        pesDts = void 0,
        payloadStartOffset = void 0,
        data = stream.data;
    // safety check
    if (!stream || stream.size === 0) return null;

    // we might need up to 19 bytes to read PES header
    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
    // usually only one merge is needed (and this is rare ...)
    while (data[0].length < 19 && data.length > 1) {
      var newData = new Uint8Array(data[0].length + data[1].length);
      newData.set(data[0]);
      newData.set(data[1], data[0].length);
      data[0] = newData;
      data.splice(1, 1);
    }
    // retrieve PTS/DTS from first fragment
    frag = data[0];
    pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
    if (pesPrefix === 1) {
      pesLen = (frag[4] << 8) + frag[5];
      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
      // minus 6 : PES header size
      if (pesLen && pesLen > stream.size - 6) return null;

      pesFlags = frag[7];
      if (pesFlags & 0xC0) {
        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
            as Bitwise operators treat their operands as a sequence of 32 bits */
        pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
        (frag[10] & 0xFF) * 4194304 + // 1 << 22
        (frag[11] & 0xFE) * 16384 + // 1 << 14
        (frag[12] & 0xFF) * 128 + // 1 << 7
        (frag[13] & 0xFE) / 2;
        // check if greater than 2^32 -1
        if (pesPts > 4294967295) {
          // decrement 2^33
          pesPts -= 8589934592;
        }
        if (pesFlags & 0x40) {
          pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
          (frag[15] & 0xFF) * 4194304 + // 1 << 22
          (frag[16] & 0xFE) * 16384 + // 1 << 14
          (frag[17] & 0xFF) * 128 + // 1 << 7
          (frag[18] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesDts > 4294967295) {
            // decrement 2^33
            pesDts -= 8589934592;
          }
          if (pesPts - pesDts > 60 * 90000) {
            _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
            pesPts = pesDts;
          }
        } else {
          pesDts = pesPts;
        }
      }
      pesHdrLen = frag[8];
      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
      payloadStartOffset = pesHdrLen + 9;

      stream.size -= payloadStartOffset;
      // reassemble PES packet
      pesData = new Uint8Array(stream.size);
      for (var j = 0, dataLen = data.length; j < dataLen; j++) {
        frag = data[j];
        var len = frag.byteLength;
        if (payloadStartOffset) {
          if (payloadStartOffset > len) {
            // trim full frag if PES header bigger than frag
            payloadStartOffset -= len;
            continue;
          } else {
            // trim partial frag if PES header smaller than frag
            frag = frag.subarray(payloadStartOffset);
            len -= payloadStartOffset;
            payloadStartOffset = 0;
          }
        }
        pesData.set(frag, i);
        i += len;
      }
      if (pesLen) {
        // payload size : remove PES header + PES extension
        pesLen -= pesHdrLen + 3;
      }
      return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
    } else {
      return null;
    }
  };

  TSDemuxer.prototype.pushAccesUnit = function pushAccesUnit(avcSample, avcTrack) {
    if (avcSample.units.length && avcSample.frame) {
      var samples = avcTrack.samples;
      var nbSamples = samples.length;
      // only push AVC sample if starting with a keyframe is not mandatory OR
      //    if keyframe already found in this fragment OR
      //       keyframe found in last fragment (track.sps) AND
      //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
      if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
        avcSample.id = nbSamples;
        samples.push(avcSample);
      } else {
        // dropped samples, track it
        avcTrack.dropped++;
      }
    }
    if (avcSample.debug.length) _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
  };

  TSDemuxer.prototype._parseAVCPES = function _parseAVCPES(pes, last) {
    var _this = this;

    // logger.log('parse new PES');
    var track = this._avcTrack,
        units = this._parseAVCNALu(pes.data),
        debug = false,
        expGolombDecoder = void 0,
        avcSample = this.avcSample,
        push = void 0,
        spsfound = false,
        i = void 0,
        pushAccesUnit = this.pushAccesUnit.bind(this),
        createAVCSample = function createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: [], debug: debug };
    };
    // free pes.data to save up some memory
    pes.data = null;

    // if new NAL units found and last sample still there, let's push ...
    // this helps parsing streams with missing AUD (only do this if AUD never found)
    if (avcSample && units.length && !track.audFound) {
      pushAccesUnit(avcSample, track);
      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
    }

    units.forEach(function (unit) {
      switch (unit.type) {
        // NDR
        case 1:
          push = true;
          if (!avcSample) avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');

          if (debug) avcSample.debug += 'NDR ';

          avcSample.frame = true;
          var data = unit.data;
          // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
          if (spsfound && data.length > 4) {
            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
            var sliceType = new _expGolomb2.default(data).readSliceType();
            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
            // if (sliceType === 2 || sliceType === 7) {
            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) avcSample.key = true;
          }
          break;
        // IDR
        case 5:
          push = true;
          // handle PES not starting with AUD
          if (!avcSample) avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');

          if (debug) avcSample.debug += 'IDR ';

          avcSample.key = true;
          avcSample.frame = true;
          break;
        // SEI
        case 6:
          push = true;
          if (debug && avcSample) avcSample.debug += 'SEI ';

          expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

          // skip frameType
          expGolombDecoder.readUByte();

          var payloadType = 0;
          var payloadSize = 0;
          var endOfCaptions = false;
          var b = 0;

          while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
            payloadType = 0;
            do {
              b = expGolombDecoder.readUByte();
              payloadType += b;
            } while (b === 0xFF);

            // Parse payload size.
            payloadSize = 0;
            do {
              b = expGolombDecoder.readUByte();
              payloadSize += b;
            } while (b === 0xFF);

            // TODO: there can be more than one payload in an SEI packet...
            // TODO: need to read type and size in a while loop to get them all
            if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
              endOfCaptions = true;

              var countryCode = expGolombDecoder.readUByte();

              if (countryCode === 181) {
                var providerCode = expGolombDecoder.readUShort();

                if (providerCode === 49) {
                  var userStructure = expGolombDecoder.readUInt();

                  if (userStructure === 0x47413934) {
                    var userDataType = expGolombDecoder.readUByte();

                    // Raw CEA-608 bytes wrapped in CEA-708 packet
                    if (userDataType === 3) {
                      var firstByte = expGolombDecoder.readUByte();
                      var secondByte = expGolombDecoder.readUByte();

                      var totalCCs = 31 & firstByte;
                      var byteArray = [firstByte, secondByte];

                      for (i = 0; i < totalCCs; i++) {
                        // 3 bytes per CC
                        byteArray.push(expGolombDecoder.readUByte());
                        byteArray.push(expGolombDecoder.readUByte());
                        byteArray.push(expGolombDecoder.readUByte());
                      }

                      _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                    }
                  }
                }
              }
            } else if (payloadSize < expGolombDecoder.bytesAvailable) {
              for (i = 0; i < payloadSize; i++) {
                expGolombDecoder.readUByte();
              }
            }
          }
          break;
        // SPS
        case 7:
          push = true;
          spsfound = true;
          if (debug && avcSample) avcSample.debug += 'SPS ';

          if (!track.sps) {
            expGolombDecoder = new _expGolomb2.default(unit.data);
            var config = expGolombDecoder.readSPS();
            track.width = config.width;
            track.height = config.height;
            track.pixelRatio = config.pixelRatio;
            track.sps = [unit.data];
            track.duration = _this._duration;
            var codecarray = unit.data.subarray(1, 4);
            var codecstring = 'avc1.';
            for (i = 0; i < 3; i++) {
              var h = codecarray[i].toString(16);
              if (h.length < 2) h = '0' + h;

              codecstring += h;
            }
            track.codec = codecstring;
          }
          break;
        // PPS
        case 8:
          push = true;
          if (debug && avcSample) avcSample.debug += 'PPS ';

          if (!track.pps) track.pps = [unit.data];

          break;
        // AUD
        case 9:
          push = false;
          track.audFound = true;
          if (avcSample) pushAccesUnit(avcSample, track);

          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
          break;
        // Filler Data
        case 12:
          push = false;
          break;
        default:
          push = false;
          if (avcSample) avcSample.debug += 'unknown NAL ' + unit.type + ' ';

          break;
      }
      if (avcSample && push) {
        var _units = avcSample.units;
        _units.push(unit);
      }
    });
    // if last PES packet, push samples
    if (last && avcSample) {
      pushAccesUnit(avcSample, track);
      this.avcSample = null;
    }
  };

  TSDemuxer.prototype._insertSampleInOrder = function _insertSampleInOrder(arr, data) {
    var len = arr.length;
    if (len > 0) {
      if (data.pts >= arr[len - 1].pts) {
        arr.push(data);
      } else {
        for (var pos = len - 1; pos >= 0; pos--) {
          if (data.pts < arr[pos].pts) {
            arr.splice(pos, 0, data);
            break;
          }
        }
      }
    } else {
      arr.push(data);
    }
  };

  TSDemuxer.prototype._getLastNalUnit = function _getLastNalUnit() {
    var avcSample = this.avcSample,
        lastUnit = void 0;
    // try to fallback to previous sample if current one is empty
    if (!avcSample || avcSample.units.length === 0) {
      var track = this._avcTrack,
          samples = track.samples;
      avcSample = samples[samples.length - 1];
    }
    if (avcSample) {
      var units = avcSample.units;
      lastUnit = units[units.length - 1];
    }
    return lastUnit;
  };

  TSDemuxer.prototype._parseAVCNALu = function _parseAVCNALu(array) {
    var i = 0,
        len = array.byteLength,
        value = void 0,
        overflow = void 0,
        track = this._avcTrack,
        state = track.naluState || 0,
        lastState = state;
    var units = [],
        unit = void 0,
        unitType = void 0,
        lastUnitStart = -1,
        lastUnitType = void 0;
    // logger.log('PES:' + Hex.hexDump(array));

    if (state === -1) {
      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
      lastUnitStart = 0;
      // NALu type is value read from offset 0
      lastUnitType = array[0] & 0x1f;
      state = 0;
      i = 1;
    }

    while (i < len) {
      value = array[i++];
      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
      if (!state) {
        state = value ? 0 : 1;
        continue;
      }
      if (state === 1) {
        state = value ? 0 : 2;
        continue;
      }
      // here we have state either equal to 2 or 3
      if (!value) {
        state = 3;
      } else if (value === 1) {
        if (lastUnitStart >= 0) {
          unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
          units.push(unit);
        } else {
          // lastUnitStart is undefined => this is the first start code found in this PES packet
          // first check if start code delimiter is overlapping between 2 PES packets,
          // ie it started in last packet (lastState not zero)
          // and ended at the beginning of this PES packet (i <= 4 - lastState)
          var lastUnit = this._getLastNalUnit();
          if (lastUnit) {
            if (lastState && i <= 4 - lastState) {
              // start delimiter overlapping between PES packets
              // strip start delimiter bytes from the end of last NAL unit
              // check if lastUnit had a state different from zero
              if (lastUnit.state) {
                // strip last bytes
                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
              }
            }
            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
            overflow = i - state - 1;
            if (overflow > 0) {
              // logger.log('first NALU found with overflow:' + overflow);
              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
              tmp.set(lastUnit.data, 0);
              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
              lastUnit.data = tmp;
            }
          }
        }
        // check if we can read unit type
        if (i < len) {
          unitType = array[i] & 0x1f;
          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
          lastUnitStart = i;
          lastUnitType = unitType;
          state = 0;
        } else {
          // not enough byte to read unit type. let's read it on next PES parsing
          state = -1;
        }
      } else {
        state = 0;
      }
    }
    if (lastUnitStart >= 0 && state >= 0) {
      unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
      units.push(unit);
      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
    }
    // no NALu found
    if (units.length === 0) {
      // append pes.data to previous NAL unit
      var _lastUnit = this._getLastNalUnit();
      if (_lastUnit) {
        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
        _tmp.set(_lastUnit.data, 0);
        _tmp.set(array, _lastUnit.data.byteLength);
        _lastUnit.data = _tmp;
      }
    }
    track.naluState = state;
    return units;
  };

  /**
   * remove Emulation Prevention bytes from a RBSP
   */


  TSDemuxer.prototype.discardEPB = function discardEPB(data) {
    var length = data.byteLength,
        EPBPositions = [],
        i = 1,
        newLength = void 0,
        newData = void 0;

    // Find all `Emulation Prevention Bytes`
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }

    // If no Emulation Prevention Bytes were found just return the original
    // array
    if (EPBPositions.length === 0) return data;

    // Create a new array to hold the NAL unit data
    newLength = length - EPBPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;

    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        // Skip this byte
        sourceIndex++;
        // Remove this position index
        EPBPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };

  TSDemuxer.prototype._parseAACPES = function _parseAACPES(pes) {
    var track = this._audioTrack,
        data = pes.data,
        pts = pes.pts,
        startOffset = 0,
        aacOverFlow = this.aacOverFlow,
        aacLastPTS = this.aacLastPTS,
        frameDuration = void 0,
        frameIndex = void 0,
        offset = void 0,
        stamp = void 0,
        len = void 0;
    if (aacOverFlow) {
      var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
      tmp.set(aacOverFlow, 0);
      tmp.set(data, aacOverFlow.byteLength);
      // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
      data = tmp;
    }
    // look for ADTS header (0xFFFx)
    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
      if (ADTS.isHeader(data, offset)) break;
    }
    // if ADTS header does not start straight from the beginning of the PES payload, raise an error
    if (offset) {
      var reason = void 0,
          fatal = void 0;
      if (offset < len - 1) {
        reason = 'AAC PES did not start with ADTS header,offset:' + offset;
        fatal = false;
      } else {
        reason = 'no ADTS header found in AAC PES';
        fatal = true;
      }
      _logger.logger.warn('parsing error:' + reason);
      this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
      if (fatal) return;
    }

    ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
    frameIndex = 0;
    frameDuration = ADTS.getFrameDuration(track.samplerate);

    // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
    // first sample PTS should be equal to last sample PTS + frameDuration
    if (aacOverFlow && aacLastPTS) {
      var newPTS = aacLastPTS + frameDuration;
      if (Math.abs(newPTS - pts) > 1) {
        _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
        pts = newPTS;
      }
    }

    // scan for aac samples
    while (offset < len) {
      if (ADTS.isHeader(data, offset) && offset + 5 < len) {
        var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          // logger.log('Unable to parse AAC frame');
          break;
        }
      } else {
        // nothing found, keep looking
        offset++;
      }
    }

    if (offset < len) aacOverFlow = data.subarray(offset, len);
    // logger.log(`AAC: overflow detected:${len-offset}`);
    else aacOverFlow = null;

    this.aacOverFlow = aacOverFlow;
    this.aacLastPTS = stamp;
  };

  TSDemuxer.prototype._parseMPEGPES = function _parseMPEGPES(pes) {
    var data = pes.data;
    var length = data.length;
    var frameIndex = 0;
    var offset = 0;
    var pts = pes.pts;

    while (offset < length) {
      if (_mpegaudio2.default.isHeader(data, offset)) {
        var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          frameIndex++;
        } else {
          // logger.log('Unable to parse Mpeg audio frame');
          break;
        }
      } else {
        // nothing found, keep looking
        offset++;
      }
    }
  };

  TSDemuxer.prototype._parseID3PES = function _parseID3PES(pes) {
    this._id3Track.samples.push(pes);
  };

  return TSDemuxer;
}();

exports.default = TSDemuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/errors.js":
/*!*****************************************!*\
  !*** ./third_party/hlsjs/src/errors.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // EME (encrypted media extensions) errors
  KEY_SYSTEM_ERROR: 'keySystemError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
var ErrorDetails = exports.ErrorDetails = {
  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),

/***/ "./third_party/hlsjs/src/event-handler.js":
/*!************************************************!*\
  !*** ./third_party/hlsjs/src/event-handler.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _logger = __webpack_require__(/*! ./utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _errors = __webpack_require__(/*! ./errors */ "./third_party/hlsjs/src/errors.js");

var _events = __webpack_require__(/*! ./events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
                                                                                                                                                          *
                                                                                                                                                          * All objects in the event handling chain should inherit from this class
                                                                                                                                                          *
                                                                                                                                                          */

var FORBIDDEN_EVENT_NAMES = new Set(['hlsEventGeneric', 'hlsHandlerDestroying', 'hlsHandlerDestroyed']);

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  EventHandler.prototype.destroy = function destroy() {
    this.onHandlerDestroying();
    this.unregisterListeners();
    this.onHandlerDestroyed();
  };

  EventHandler.prototype.onHandlerDestroying = function onHandlerDestroying() {};

  EventHandler.prototype.onHandlerDestroyed = function onHandlerDestroyed() {};

  EventHandler.prototype.isEventHandler = function isEventHandler() {
    return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
  };

  EventHandler.prototype.registerListeners = function registerListeners() {
    if (this.isEventHandler()) {
      this.handledEvents.forEach(function (event) {
        if (FORBIDDEN_EVENT_NAMES.has(event)) throw new Error('Forbidden event-name: ' + event);

        this.hls.on(event, this.onEvent);
      }, this);
    }
  };

  EventHandler.prototype.unregisterListeners = function unregisterListeners() {
    if (this.isEventHandler()) {
      this.handledEvents.forEach(function (event) {
        this.hls.off(event, this.onEvent);
      }, this);
    }
  };

  /**
   * arguments: event (string), data (any)
   */


  EventHandler.prototype.onEvent = function onEvent(event, data) {
    this.onEventGeneric(event, data);
  };

  EventHandler.prototype.onEventGeneric = function onEventGeneric(event, data) {
    var eventToFunction = function eventToFunction(event, data) {
      var funcName = 'on' + event.replace('hls', '');
      if (typeof this[funcName] !== 'function') throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');

      return this[funcName].bind(this, data);
    };
    try {
      eventToFunction.call(this, event, data).call();
    } catch (err) {
      _logger.logger.error('An internal error happened while handling event ' + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
    }
  };

  return EventHandler;
}();

exports.default = EventHandler;

/***/ }),

/***/ "./third_party/hlsjs/src/events.js":
/*!*****************************************!*\
  !*** ./third_party/hlsjs/src/events.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};
exports.default = HlsEvents;

/***/ }),

/***/ "./third_party/hlsjs/src/helper/aac.js":
/*!*********************************************!*\
  !*** ./third_party/hlsjs/src/helper/aac.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {
    switch (codec) {
      case 'mp4a.40.2':
        if (channelCount === 1) return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);else if (channelCount === 2) return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);else if (channelCount === 3) return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);else if (channelCount === 4) return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);else if (channelCount === 5) return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);else if (channelCount === 6) return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);

        break;
      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
      default:
        if (channelCount === 1) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 2) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 3) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        }
        break;
    }
    return null;
  };

  return AAC;
}();

exports.default = AAC;

/***/ }),

/***/ "./third_party/hlsjs/src/helper/buffer-helper.js":
/*!*******************************************************!*\
  !*** ./third_party/hlsjs/src/helper/buffer-helper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/

var BufferHelper = {
  /**
   * Return true if `media`'s buffered include `position`
   * @param {HTMLMediaElement|SourceBuffer} media
   * @param {number} position
   * @returns {boolean}
   */
  isBuffered: function isBuffered(media, position) {
    try {
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) return true;
        }
      }
    } catch (error) {
      // this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }
    return false;
  },

  bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
    try {
      if (media) {
        var vbuffered = media.buffered,
            buffered = [],
            i = void 0;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }return this.bufferedInfo(buffered, pos, maxHoleDuration);
      }
    } catch (error) {
      // this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }
    return { len: 0, start: pos, end: pos, nextStart: undefined };
  },

  bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
    var buffered2 = [],

    // bufferStart and bufferEnd are buffer boundaries around current video position
    bufferLen = void 0,
        bufferStart = void 0,
        bufferEnd = void 0,
        bufferStartNext = void 0,
        i = void 0;
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;
      if (diff) return diff;else return b.end - a.end;
    });
    // there might be some small holes between buffer time range
    // consider that holes smaller than maxHoleDuration are irrelevant and build another
    // buffer time range representations that discards those holes
    for (i = 0; i < buffered.length; i++) {
      var buf2len = buffered2.length;
      if (buf2len) {
        var buf2end = buffered2[buf2len - 1].end;
        // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
        if (buffered[i].start - buf2end < maxHoleDuration) {
          // merge overlapping time ranges
          // update lastRange.end only if smaller than item.end
          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
          if (buffered[i].end > buf2end) buffered2[buf2len - 1].end = buffered[i].end;
        } else {
          // big hole
          buffered2.push(buffered[i]);
        }
      } else {
        // first value
        buffered2.push(buffered[i]);
      }
    }
    for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
      var start = buffered2[i].start,
          end = buffered2[i].end;
      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
  }
};

exports.default = BufferHelper;

/***/ }),

/***/ "./third_party/hlsjs/src/helper/fragment-tracker.js":
/*!**********************************************************!*\
  !*** ./third_party/hlsjs/src/helper/fragment-tracker.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.FragmentTracker = exports.FragmentState = undefined;

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FragmentState = exports.FragmentState = {
  NOT_LOADED: 'NOT_LOADED',
  APPENDING: 'APPENDING',
  PARTIAL: 'PARTIAL',
  OK: 'OK'
};

var FragmentTracker = exports.FragmentTracker = function (_EventHandler) {
  _inherits(FragmentTracker, _EventHandler);

  function FragmentTracker(hls) {
    _classCallCheck(this, FragmentTracker);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, _events2.default.BUFFER_APPENDED, _events2.default.FRAG_BUFFERED, _events2.default.FRAG_LOADED));

    _this.bufferPadding = 0.2;

    _this.fragments = Object.create(null);
    _this.timeRanges = Object.create(null);

    _this.config = hls.config;
    return _this;
  }

  FragmentTracker.prototype.destroy = function destroy() {
    this.fragments = null;
    this.timeRanges = null;
    this.config = null;
    _eventHandler2.default.prototype.destroy.call(this);
    _EventHandler.prototype.destroy.call(this);
  };

  /**
   * Return a Fragment that match the position and levelType.
   * If not found any Fragment, return null
   * @param {number} position
   * @param {LevelType} levelType
   * @returns {Fragment|null}
   */


  FragmentTracker.prototype.getBufferedFrag = function getBufferedFrag(position, levelType) {
    var fragments = this.fragments;
    var bufferedFrags = Object.keys(fragments).filter(function (key) {
      var fragmentEntity = fragments[key];
      if (fragmentEntity.body.type !== levelType) return false;

      if (!fragmentEntity.buffered) return false;

      var frag = fragmentEntity.body;
      return frag.startPTS <= position && position <= frag.endPTS;
    });
    if (bufferedFrags.length === 0) {
      return null;
    } else {
      // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
      var bufferedFragKey = bufferedFrags.pop();
      return fragments[bufferedFragKey].body;
    }
  };

  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
   * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
   */


  FragmentTracker.prototype.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange) {
    var _this2 = this;

    var fragmentTimes = void 0,
        time = void 0;
    // Check if any flagged fragments have been unloaded
    Object.keys(this.fragments).forEach(function (key) {
      var fragmentEntity = _this2.fragments[key];
      if (fragmentEntity.buffered === true) {
        var esData = fragmentEntity.range[elementaryStream];
        if (esData) {
          fragmentTimes = esData.time;
          for (var i = 0; i < fragmentTimes.length; i++) {
            time = fragmentTimes[i];

            if (_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
              // Unregister partial fragment as it needs to load again to be reused
              _this2.removeFragment(fragmentEntity.body);
              break;
            }
          }
        }
      }
    });
  };

  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   * @param {Object} fragment Check the fragment against all sourceBuffers loaded
   */


  FragmentTracker.prototype.detectPartialFragments = function detectPartialFragments(fragment) {
    var _this3 = this;

    var fragKey = this.getFragmentKey(fragment);
    var fragmentEntity = this.fragments[fragKey];
    if (fragmentEntity) {
      fragmentEntity.buffered = true;

      Object.keys(this.timeRanges).forEach(function (elementaryStream) {
        if (fragment.hasElementaryStream(elementaryStream) === true) {
          var timeRange = _this3.timeRanges[elementaryStream];
          // Check for malformed fragments
          // Gaps need to be calculated for each elementaryStream
          fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
        }
      });
    }
  };

  FragmentTracker.prototype.getBufferedTimes = function getBufferedTimes(startPTS, endPTS, timeRange) {
    var fragmentTimes = [];
    var startTime = void 0,
        endTime = void 0;
    var fragmentPartial = false;
    for (var i = 0; i < timeRange.length; i++) {
      startTime = timeRange.start(i) - this.bufferPadding;
      endTime = timeRange.end(i) + this.bufferPadding;
      if (startPTS >= startTime && endPTS <= endTime) {
        // Fragment is entirely contained in buffer
        // No need to check the other timeRange times since it's completely playable
        fragmentTimes.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
        break;
      } else if (startPTS < endTime && endPTS > startTime) {
        // Check for intersection with buffer
        // Get playable sections of the fragment
        fragmentTimes.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
        fragmentPartial = true;
      } else if (endPTS <= startTime) {
        // No need to check the rest of the timeRange as it is in order
        break;
      }
    }

    return {
      time: fragmentTimes,
      partial: fragmentPartial
    };
  };

  FragmentTracker.prototype.getFragmentKey = function getFragmentKey(fragment) {
    return fragment.type + '_' + fragment.level + '_' + fragment.sn;
  };

  /**
   * Gets the partial fragment for a certain time
   * @param {Number} time
   * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
   */


  FragmentTracker.prototype.getPartialFragment = function getPartialFragment(time) {
    var _this4 = this;

    var timePadding = void 0,
        startTime = void 0,
        endTime = void 0;
    var bestFragment = null;
    var bestOverlap = 0;
    Object.keys(this.fragments).forEach(function (key) {
      var fragmentEntity = _this4.fragments[key];
      if (_this4.isPartial(fragmentEntity)) {
        startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
        endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
        if (time >= startTime && time <= endTime) {
          // Use the fragment that has the most padding from start and end time
          timePadding = Math.min(time - startTime, endTime - time);
          if (bestOverlap <= timePadding) {
            bestFragment = fragmentEntity.body;
            bestOverlap = timePadding;
          }
        }
      }
    });
    return bestFragment;
  };

  /**
   * @param {Object} fragment The fragment to check
   * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
   */


  FragmentTracker.prototype.getState = function getState(fragment) {
    var fragKey = this.getFragmentKey(fragment);
    var fragmentEntity = this.fragments[fragKey];
    var state = FragmentState.NOT_LOADED;

    if (fragmentEntity !== undefined) {
      if (!fragmentEntity.buffered) state = FragmentState.APPENDING;else if (this.isPartial(fragmentEntity) === true) state = FragmentState.PARTIAL;else state = FragmentState.OK;
    }

    return state;
  };

  FragmentTracker.prototype.isPartial = function isPartial(fragmentEntity) {
    return fragmentEntity.buffered === true && (fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true);
  };

  FragmentTracker.prototype.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
    var startTime = void 0,
        endTime = void 0;
    for (var i = 0; i < timeRange.length; i++) {
      startTime = timeRange.start(i) - this.bufferPadding;
      endTime = timeRange.end(i) + this.bufferPadding;
      if (startPTS >= startTime && endPTS <= endTime) return true;

      if (endPTS <= startTime) {
        // No need to check the rest of the timeRange as it is in order
        return false;
      }
    }

    return false;
  };

  /**
   * Fires when a fragment loading is completed
   */


  FragmentTracker.prototype.onFragLoaded = function onFragLoaded(e) {
    var fragment = e.frag;
    // dont track initsegment (for which sn is not a number)
    if (!isNaN(fragment.sn)) {
      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = {
        body: fragment,
        range: Object.create(null),
        buffered: false
      };
      this.fragments[fragKey] = fragmentEntity;
    }
  };

  /**
   * Fires when the buffer is updated
   */


  FragmentTracker.prototype.onBufferAppended = function onBufferAppended(e) {
    var _this5 = this;

    // Store the latest timeRanges loaded in the buffer
    this.timeRanges = e.timeRanges;
    Object.keys(this.timeRanges).forEach(function (elementaryStream) {
      var timeRange = _this5.timeRanges[elementaryStream];
      _this5.detectEvictedFragments(elementaryStream, timeRange);
    });
  };

  /**
   * Fires after a fragment has been loaded into the source buffer
   */


  FragmentTracker.prototype.onFragBuffered = function onFragBuffered(e) {
    this.detectPartialFragments(e.frag);
  };

  /**
   * Return true if fragment tracker has the fragment.
   * @param {Object} fragment
   * @returns {boolean}
   */


  FragmentTracker.prototype.hasFragment = function hasFragment(fragment) {
    var fragKey = this.getFragmentKey(fragment);
    return this.fragments[fragKey] !== undefined;
  };

  /**
   * Remove a fragment from fragment tracker until it is loaded again
   * @param {Object} fragment The fragment to remove
   */


  FragmentTracker.prototype.removeFragment = function removeFragment(fragment) {
    var fragKey = this.getFragmentKey(fragment);
    delete this.fragments[fragKey];
  };

  /**
   * Remove all fragments from fragment tracker.
   */


  FragmentTracker.prototype.removeAllFragments = function removeAllFragments() {
    this.fragments = Object.create(null);
  };

  return FragmentTracker;
}(_eventHandler2.default);

/***/ }),

/***/ "./third_party/hlsjs/src/helper/level-helper.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/helper/level-helper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.updatePTS = updatePTS;
exports.updateFragPTSDTS = updateFragPTSDTS;
exports.mergeDetails = mergeDetails;

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (!isNaN(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) fragTo.start = fragFrom.start + fragFrom.duration;else fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
  }
} /**
   * Level Helper class, providing methods dealing with playlist sliding and drift
  */

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (!isNaN(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (isNaN(frag.deltaPTS)) frag.deltaPTS = deltaPTS;else frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);

    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) return 0;

  var fragIdx = void 0,
      fragments = void 0,
      i = void 0;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happpen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  } // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }details.PTSKnown = true;
  // logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
      end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
      delta = newDetails.startSN - oldDetails.startSN,
      oldfragments = oldDetails.fragments,
      newfragments = newDetails.fragments,
      ccOffset = 0,
      PTSFrag = void 0;

  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) newDetails.initSegment = oldDetails.initSegment;

  // check if old/new playlists have fragments in common
  if (end < start) {
    newDetails.PTSKnown = false;
    return;
  }
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  for (var i = start; i <= end; i++) {
    var oldFrag = oldfragments[delta + i],
        newFrag = newfragments[i];
    if (newFrag && oldFrag) {
      ccOffset = oldFrag.cc - newFrag.cc;
      if (!isNaN(oldFrag.startPTS)) {
        newFrag.start = newFrag.startPTS = oldFrag.startPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.duration = oldFrag.duration;
        newFrag.backtracked = oldFrag.backtracked;
        newFrag.dropped = oldFrag.dropped;
        PTSFrag = newFrag;
      }
    }
  }

  if (ccOffset) {
    _logger.logger.log('discontinuity sliding from playlist, take drift into account');
    for (i = 0; i < newfragments.length; i++) {
      newfragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldfragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    if (delta >= 0 && delta < oldfragments.length) {
      // adjust start by sliding offset
      var sliding = oldfragments[delta].start;
      for (i = 0; i < newfragments.length; i++) {
        newfragments[i].start += sliding;
      }
    }
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}

/***/ }),

/***/ "./third_party/hlsjs/src/helper/mediakeys-helper.js":
/*!**********************************************************!*\
  !*** ./third_party/hlsjs/src/helper/mediakeys-helper.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var requestMediaKeySystemAccess = function () {
  if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);else return null;
}();

exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

/***/ }),

/***/ "./third_party/hlsjs/src/helper/mediasource-helper.js":
/*!************************************************************!*\
  !*** ./third_party/hlsjs/src/helper/mediasource-helper.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.getMediaSource = getMediaSource;
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') return window.MediaSource || window.WebKitMediaSource;
}

/***/ }),

/***/ "./third_party/hlsjs/src/loader/fragment.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/loader/fragment.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _levelKey = __webpack_require__(/*! ./level-key */ "./third_party/hlsjs/src/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = function () {
  function Fragment() {
    var _elementaryStreams;

    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];

    // Holds the types of data this fragment supports
    this._elementaryStreams = (_elementaryStreams = {}, _elementaryStreams[Fragment.ElementaryStreamTypes.AUDIO] = false, _elementaryStreams[Fragment.ElementaryStreamTypes.VIDEO] = false, _elementaryStreams);
  }

  /**
   * `type` property for this._elementaryStreams
   *
   * @enum
   */


  /**
   * @param {ElementaryStreamType} type
   */
  Fragment.prototype.addElementaryStream = function addElementaryStream(type) {
    this._elementaryStreams[type] = true;
  };

  /**
   * @param {ElementaryStreamType} type
   */


  Fragment.prototype.hasElementaryStream = function hasElementaryStream(type) {
    return this._elementaryStreams[type] === true;
  };

  /**
   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
   * @returns {Uint8Array}
   */


  Fragment.prototype.createInitializationVector = function createInitializationVector(segmentNumber) {
    var uint8View = new Uint8Array(16);

    for (var i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
    }return uint8View;
  };

  /**
   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
   * @param levelkey - a playlist's encryption info
   * @param segmentNumber - the fragment's segment number
   * @returns {*} - an object to be applied as a fragment's decryptdata
   */


  Fragment.prototype.fragmentDecryptdataFromLevelkey = function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
    var decryptdata = levelkey;

    if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
      decryptdata = new _levelKey2.default();
      decryptdata.method = levelkey.method;
      decryptdata.baseuri = levelkey.baseuri;
      decryptdata.reluri = levelkey.reluri;
      decryptdata.iv = this.createInitializationVector(segmentNumber);
    }

    return decryptdata;
  };

  _createClass(Fragment, [{
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });

      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));

      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange && !this.rawByteRange) return [];

      if (this._byteRange) return this._byteRange;

      var byteRange = [];
      if (this.rawByteRange) {
        var params = this.rawByteRange.split('@', 2);
        if (params.length === 1) {
          var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
          byteRange[0] = lastByteRangeEndOffset || 0;
        } else {
          byteRange[0] = parseInt(params[1]);
        }
        byteRange[1] = parseInt(params[0]) + byteRange[0];
        this._byteRange = byteRange;
      }
      return byteRange;
    }

    /**
     * @type {number}
     */

  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);

      return this._decryptdata;
    }
  }], [{
    key: 'ElementaryStreamTypes',
    get: function get() {
      return {
        AUDIO: 'audio',
        VIDEO: 'video'
      };
    }
  }]);

  return Fragment;
}();

exports.default = Fragment;

/***/ }),

/***/ "./third_party/hlsjs/src/loader/level-key.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/loader/level-key.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });

      return this._uri;
    }
  }]);

  return LevelKey;
}();

exports.default = LevelKey;

/***/ }),

/***/ "./third_party/hlsjs/src/loader/m3u8-parser.js":
/*!*****************************************************!*\
  !*** ./third_party/hlsjs/src/loader/m3u8-parser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");

var _urlToolkit2 = _interopRequireDefault(_urlToolkit);

var _fragment = __webpack_require__(/*! ./fragment */ "./third_party/hlsjs/src/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _levelKey = __webpack_require__(/*! ./level-key */ "./third_party/hlsjs/src/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

var _attrList = __webpack_require__(/*! ../utils/attr-list */ "./third_party/hlsjs/src/utils/attr-list.js");

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./third_party/hlsjs/src/utils/codecs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * M3U8 parser
 * @module
 */

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)(\S+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var M3U8Parser = function () {
  function M3U8Parser() {
    _classCallCheck(this, M3U8Parser);
  }

  M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {
    if (!groups) return null;

    var matchingGroup = null;

    for (var i = 0; i < groups.length; i++) {
      var group = groups[i];
      if (group.id === mediaGroupId) matchingGroup = group;
    }

    return matchingGroup;
  };

  M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
    var result = void 0,
        avcdata = codec.split('.');
    if (avcdata.length > 2) {
      result = avcdata.shift() + '.';
      result += parseInt(avcdata.shift()).toString(16);
      result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
    } else {
      result = codec;
    }
    return result;
  };

  M3U8Parser.resolve = function resolve(url, baseUrl) {
    return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
  };

  M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
    var levels = [],
        result = void 0;
    MASTER_PLAYLIST_REGEX.lastIndex = 0;

    function setCodecs(codecs, level) {
      ['video', 'audio'].forEach(function (type) {
        var filtered = codecs.filter(function (codec) {
          return (0, _codecs.isCodecType)(codec, type);
        });
        if (filtered.length) {
          var preferred = filtered.filter(function (codec) {
            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
          });
          level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

          // remove from list
          codecs = codecs.filter(function (codec) {
            return filtered.indexOf(codec) === -1;
          });
        }
      });

      level.unknownCodecs = codecs;
    }

    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
      var level = {};

      var attrs = level.attrs = new _attrList2.default(result[1]);
      level.url = M3U8Parser.resolve(result[2], baseurl);

      var resolution = attrs.decimalResolution('RESOLUTION');
      if (resolution) {
        level.width = resolution.width;
        level.height = resolution.height;
      }
      level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
      level.name = attrs.NAME;

      setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

      if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);

      levels.push(level);
    }
    return levels;
  };

  M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type) {
    var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    var result = void 0;
    var medias = [];
    var id = 0;
    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
      var media = {};
      var attrs = new _attrList2.default(result[1]);
      if (attrs.TYPE === type) {
        media.groupId = attrs['GROUP-ID'];
        media.name = attrs.NAME;
        media.type = type;
        media.default = attrs.DEFAULT === 'YES';
        media.autoselect = attrs.AUTOSELECT === 'YES';
        media.forced = attrs.FORCED === 'YES';
        if (attrs.URI) media.url = M3U8Parser.resolve(attrs.URI, baseurl);

        media.lang = attrs.LANGUAGE;
        if (!media.name) media.name = media.lang;

        if (audioGroups.length) {
          var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
          media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
        }
        media.id = id++;
        medias.push(media);
      }
    }
    return medias;
  };

  M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type) {
    var currentSN = 0,
        totalduration = 0,
        level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
        levelkey = new _levelKey2.default(),
        cc = 0,
        prevFrag = null,
        frag = new _fragment2.default(),
        result = void 0,
        i = void 0;

    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      var duration = result[1];
      if (duration) {
        // INF
        frag.duration = parseFloat(duration);
        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        var title = (' ' + result[2]).slice(1);
        frag.title = title || null;
        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
      } else if (result[3]) {
        // url
        if (!isNaN(frag.duration)) {
          var sn = currentSN++;
          frag.type = type;
          frag.start = totalduration;
          frag.levelkey = levelkey;
          frag.sn = sn;
          frag.level = id;
          frag.cc = cc;
          frag.baseurl = baseurl;
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.relurl = (' ' + result[3]).slice(1);

          if (level.programDateTime) {
            if (prevFrag) {
              if (frag.rawProgramDateTime) {
                // PDT discontinuity found
                frag.pdt = Date.parse(frag.rawProgramDateTime);
              } else {
                // Contiguous fragment
                frag.pdt = prevFrag.pdt + prevFrag.duration * 1000;
              }
            } else {
              // First fragment
              frag.pdt = Date.parse(level.programDateTime);
            }
            frag.endPdt = frag.pdt + frag.duration * 1000;
          }

          level.fragments.push(frag);
          prevFrag = frag;
          totalduration += frag.duration;

          frag = new _fragment2.default();
        }
      } else if (result[4]) {
        // X-BYTERANGE
        frag.rawByteRange = (' ' + result[4]).slice(1);
        if (prevFrag) {
          var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
          if (lastByteRangeEndOffset) frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
        }
      } else if (result[5]) {
        // PROGRAM-DATE-TIME
        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        frag.rawProgramDateTime = (' ' + result[5]).slice(1);
        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
        if (level.programDateTime === undefined) level.programDateTime = new Date(new Date(Date.parse(result[5])) - 1000 * totalduration);
      } else {
        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
        for (i = 1; i < result.length; i++) {
          if (result[i] !== undefined) break;
        }

        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        var value1 = (' ' + result[i + 1]).slice(1);
        var value2 = (' ' + result[i + 2]).slice(1);

        switch (result[i]) {
          case '#':
            frag.tagList.push(value2 ? [value1, value2] : [value1]);
            break;
          case 'PLAYLIST-TYPE':
            level.type = value1.toUpperCase();
            break;
          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(value1);
            break;
          case 'TARGETDURATION':
            level.targetduration = parseFloat(value1);
            break;
          case 'VERSION':
            level.version = parseInt(value1);
            break;
          case 'EXTM3U':
            break;
          case 'ENDLIST':
            level.live = false;
            break;
          case 'DIS':
            cc++;
            frag.tagList.push(['DIS']);
            break;
          case 'DISCONTINUITY-SEQ':
            cc = parseInt(value1);
            break;
          case 'KEY':
            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
            var decryptparams = value1;
            var keyAttrs = new _attrList2.default(decryptparams);
            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                decrypturi = keyAttrs.URI,
                decryptiv = keyAttrs.hexadecimalInteger('IV');
            if (decryptmethod) {
              levelkey = new _levelKey2.default();
              if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                levelkey.method = decryptmethod;
                // URI to get the key
                levelkey.baseuri = baseurl;
                levelkey.reluri = decrypturi;
                levelkey.key = null;
                // Initialization Vector (IV)
                levelkey.iv = decryptiv;
              }
            }
            break;
          case 'START':
            var startParams = value1;
            var startAttrs = new _attrList2.default(startParams);
            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
            // TIME-OFFSET can be 0
            if (!isNaN(startTimeOffset)) level.startTimeOffset = startTimeOffset;

            break;
          case 'MAP':
            var mapAttrs = new _attrList2.default(value1);
            frag.relurl = mapAttrs.URI;
            frag.rawByteRange = mapAttrs.BYTERANGE;
            frag.baseurl = baseurl;
            frag.level = id;
            frag.type = type;
            frag.sn = 'initSegment';
            level.initSegment = frag;
            frag = new _fragment2.default();
            break;
          default:
            _logger.logger.warn('line parsed but not handled: ' + result);
            break;
        }
      }
    }
    frag = prevFrag;
    // logger.log('found ' + level.fragments.length + ' fragments');
    if (frag && !frag.relurl) {
      level.fragments.pop();
      totalduration -= frag.duration;
    }
    level.totalduration = totalduration;
    level.averagetargetduration = totalduration / level.fragments.length;
    level.endSN = currentSN - 1;
    level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
    level.endCC = cc;

    if (!level.initSegment && level.fragments.length) {
      // this is a bit lurky but HLS really has no other way to tell us
      // if the fragments are TS or MP4, except if we download them :/
      // but this is to be able to handle SIDX.
      // FIXME: replace string test by a regex that matches
      //        also `m4s` `m4a` `m4v` and other popular extensions
      if (level.fragments.every(function (frag) {
        return frag.relurl.endsWith('.mp4');
      })) {
        _logger.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');

        frag = new _fragment2.default();
        frag.relurl = level.fragments[0].relurl;
        frag.baseurl = baseurl;
        frag.level = id;
        frag.type = type;
        frag.sn = 'initSegment';

        level.initSegment = frag;
        level.needSidxRanges = true;
      }
    }

    return level;
  };

  return M3U8Parser;
}();

exports.default = M3U8Parser;

/***/ }),

/***/ "./third_party/hlsjs/src/remux/mp4-generator.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/remux/mp4-generator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

// import Hex from '../utils/hex';

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  MP4.init = function init() {
    MP4.types = {
      avc1: [], // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      '.mp3': [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };

    var i = void 0;
    for (i in MP4.types) {
      if (MP4.types.hasOwnProperty(i)) {
        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }

    var videoHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
    ]);

    var audioHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
    ]);

    MP4.HDLR_TYPES = {
      'video': videoHdlr,
      'audio': audioHdlr
    };

    var dref = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01, // entry_count
    0x00, 0x00, 0x00, 0x0c, // entry_size
    0x75, 0x72, 0x6c, 0x20, // 'url' type
    0x00, // version 0
    0x00, 0x00, 0x01 // entry_flags
    ]);

    var stco = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00 // entry_count
    ]);

    MP4.STTS = MP4.STSC = MP4.STCO = stco;

    MP4.STSZ = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // sample_size
    0x00, 0x00, 0x00, 0x00 // sample_count
    ]);
    MP4.VMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x01, // flags
    0x00, 0x00, // graphicsmode
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
    ]);
    MP4.SMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, // balance
    0x00, 0x00 // reserved
    ]);

    MP4.STSD = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01]); // entry_count

    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
    var minorVersion = new Uint8Array([0, 0, 0, 1]);

    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
  };

  MP4.box = function box(type) {
    var payload = Array.prototype.slice.call(arguments, 1),
        size = 8,
        i = payload.length,
        len = i,
        result = void 0;
    // calculate the total size we need to allocate
    while (i--) {
      size += payload[i].byteLength;
    }result = new Uint8Array(size);
    result[0] = size >> 24 & 0xff;
    result[1] = size >> 16 & 0xff;
    result[2] = size >> 8 & 0xff;
    result[3] = size & 0xff;
    result.set(type, 4);
    // copy the payload into the result
    for (i = 0, size = 8; i < len; i++) {
      // copy payload[i] array @ offset size
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };

  MP4.hdlr = function hdlr(type) {
    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
  };

  MP4.mdat = function mdat(data) {
    return MP4.box(MP4.types.mdat, data);
  };

  MP4.mdhd = function mdhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
    0x00, 0x00]));
  };

  MP4.mdia = function mdia(track) {
    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
  };

  MP4.mfhd = function mfhd(sequenceNumber) {
    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
    sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF // sequence_number
    ]));
  };

  MP4.minf = function minf(track) {
    if (track.type === 'audio') return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));else return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
  };

  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
  };
  /**
  * @param tracks... (optional) {array} the tracks associated with this movie
  */


  MP4.moov = function moov(tracks) {
    var i = tracks.length,
        boxes = [];

    while (i--) {
      boxes[i] = MP4.trak(tracks[i]);
    }return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
  };

  MP4.mvex = function mvex(tracks) {
    var i = tracks.length,
        boxes = [];

    while (i--) {
      boxes[i] = MP4.trex(tracks[i]);
    }return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
  };

  MP4.mvhd = function mvhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    var bytes = new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
    0x01, 0x00, // 1.0 volume
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    0xff, 0xff, 0xff, 0xff // next_track_ID
    ]);
    return MP4.box(MP4.types.mvhd, bytes);
  };

  MP4.sdtp = function sdtp(track) {
    var samples = track.samples || [],
        bytes = new Uint8Array(4 + samples.length),
        flags = void 0,
        i = void 0;
    // leave the full box header (4 bytes) all zero
    // write the sample table
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }

    return MP4.box(MP4.types.sdtp, bytes);
  };

  MP4.stbl = function stbl(track) {
    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
  };

  MP4.avc1 = function avc1(track) {
    var sps = [],
        pps = [],
        i = void 0,
        data = void 0,
        len = void 0;
    // assemble the SPSs

    for (i = 0; i < track.sps.length; i++) {
      data = track.sps[i];
      len = data.byteLength;
      sps.push(len >>> 8 & 0xFF);
      sps.push(len & 0xFF);
      sps = sps.concat(Array.prototype.slice.call(data)); // SPS
    }

    // assemble the PPSs
    for (i = 0; i < track.pps.length; i++) {
      data = track.pps[i];
      len = data.byteLength;
      pps.push(len >>> 8 & 0xFF);
      pps.push(len & 0xFF);
      pps = pps.concat(Array.prototype.slice.call(data));
    }

    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
    sps[3], // profile
    sps[4], // profile compat
    sps[5], // level
    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
    0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
    ]).concat(pps))),
        // "PPS"
    width = track.width,
        height = track.height,
        hSpacing = track.pixelRatio[0],
        vSpacing = track.pixelRatio[1];

    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, // pre_defined
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    width >> 8 & 0xFF, width & 0xff, // width
    height >> 8 & 0xFF, height & 0xff, // height
    0x00, 0x48, 0x00, 0x00, // horizresolution
    0x00, 0x48, 0x00, 0x00, // vertresolution
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // frame_count
    0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js
    0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
    0x00, 0x18, // depth = 24
    0x11, 0x11]), // pre_defined = -1
    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
    0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
    hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
    vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
  };

  MP4.esds = function esds(track) {
    var configlen = track.config.length;
    return new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags

    0x03, // descriptor_type
    0x17 + configlen, // length
    0x00, 0x01, // es_id
    0x00, // stream_priority

    0x04, // descriptor_type
    0x0f + configlen, // length
    0x40, // codec : mpeg4_audio
    0x15, // stream_type
    0x00, 0x00, 0x00, // buffer_size
    0x00, 0x00, 0x00, 0x00, // maxBitrate
    0x00, 0x00, 0x00, 0x00, // avgBitrate

    0x05 // descriptor_type
    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
  };

  MP4.mp4a = function mp4a(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xFF, samplerate & 0xff, //
    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
  };

  MP4.mp3 = function mp3(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xFF, samplerate & 0xff, //
    0x00, 0x00]));
  };

  MP4.stsd = function stsd(track) {
    if (track.type === 'audio') {
      if (!track.isAAC && track.codec === 'mp3') return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));

      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
    } else {
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
    }
  };

  MP4.tkhd = function tkhd(track) {
    var id = track.id,
        duration = track.duration * track.timescale,
        width = track.width,
        height = track.height,
        upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
        lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x07, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
    0x00, 0x00, 0x00, 0x00, // reserved
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, // layer
    0x00, 0x00, // alternate_group
    0x00, 0x00, // non-audio track volume
    0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
    height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
    ]));
  };

  MP4.traf = function traf(track, baseMediaDecodeTime) {
    var sampleDependencyTable = MP4.sdtp(track),
        id = track.id,
        upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
        lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
    ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8), // mdat header
    sampleDependencyTable);
  };

  /**
   * Generate a track box.
   * @param track {object} a track definition
   * @return {Uint8Array} the track box
   */


  MP4.trak = function trak(track) {
    track.duration = track.duration || 0xffffffff;
    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
  };

  MP4.trex = function trex(track) {
    var id = track.id;
    return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
    0x00, 0x00, 0x00, 0x01, // default_sample_description_index
    0x00, 0x00, 0x00, 0x00, // default_sample_duration
    0x00, 0x00, 0x00, 0x00, // default_sample_size
    0x00, 0x01, 0x00, 0x01 // default_sample_flags
    ]));
  };

  MP4.trun = function trun(track, offset) {
    var samples = track.samples || [],
        len = samples.length,
        arraylen = 12 + 16 * len,
        array = new Uint8Array(arraylen),
        i = void 0,
        sample = void 0,
        duration = void 0,
        size = void 0,
        flags = void 0,
        cts = void 0;
    offset += 8 + arraylen;
    array.set([0x00, // version 0
    0x00, 0x0f, 0x01, // flags
    len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
    offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
    ], 0);
    for (i = 0; i < len; i++) {
      sample = samples[i];
      duration = sample.duration;
      size = sample.size;
      flags = sample.flags;
      cts = sample.cts;
      array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
      size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
      cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
      ], 12 + 16 * i);
    }
    return MP4.box(MP4.types.trun, array);
  };

  MP4.initSegment = function initSegment(tracks) {
    if (!MP4.types) MP4.init();

    var movie = MP4.moov(tracks),
        result = void 0;
    result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
    result.set(MP4.FTYP);
    result.set(movie, MP4.FTYP.byteLength);
    return result;
  };

  return MP4;
}();

exports.default = MP4;

/***/ }),

/***/ "./third_party/hlsjs/src/remux/mp4-remuxer.js":
/*!****************************************************!*\
  !*** ./third_party/hlsjs/src/remux/mp4-remuxer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _aac = __webpack_require__(/*! ../helper/aac */ "./third_party/hlsjs/src/helper/aac.js");

var _aac2 = _interopRequireDefault(_aac);

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

var _mp4Generator = __webpack_require__(/*! ../remux/mp4-generator */ "./third_party/hlsjs/src/remux/mp4-generator.js");

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _errors = __webpack_require__(/*! ../errors */ "./third_party/hlsjs/src/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * fMP4 remuxer
                                                                                                                                                          */

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  MP4Remuxer.prototype.destroy = function destroy() {};

  MP4Remuxer.prototype.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
    this._initPTS = this._initDTS = defaultTimeStamp;
  };

  MP4Remuxer.prototype.resetInitSegment = function resetInitSegment() {
    this.ISGenerated = false;
  };

  MP4Remuxer.prototype.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    // generate Init Segment if needed
    if (!this.ISGenerated) this.generateIS(audioTrack, videoTrack, timeOffset);

    if (this.ISGenerated) {
      var nbAudioSamples = audioTrack.samples.length;
      var nbVideoSamples = videoTrack.samples.length;
      var audioTimeOffset = timeOffset;
      var videoTimeOffset = timeOffset;
      if (nbAudioSamples && nbVideoSamples) {
        // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
        // if first audio DTS is not aligned with first video DTS then we need to take that into account
        // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
        // drift between audio and video streams
        var audiovideoDeltaDts = (audioTrack.samples[0].dts - videoTrack.samples[0].dts) / videoTrack.inputTimeScale;
        audioTimeOffset += Math.max(0, audiovideoDeltaDts);
        videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
      }
      // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
      // calculated in remuxAudio.
      // logger.log('nb AAC samples:' + audioTrack.samples.length);
      if (nbAudioSamples) {
        // if initSegment was generated without video samples, regenerate it again
        if (!audioTrack.timescale) {
          _logger.logger.warn('regenerate InitSegment as audio detected');
          this.generateIS(audioTrack, videoTrack, timeOffset);
        }
        var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
        // logger.log('nb AVC samples:' + videoTrack.samples.length);
        if (nbVideoSamples) {
          var audioTrackLength = void 0;
          if (audioData) audioTrackLength = audioData.endPTS - audioData.startPTS;

          // if initSegment was generated without video samples, regenerate it again
          if (!videoTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as video detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
        }
      } else {
        // logger.log('nb AVC samples:' + videoTrack.samples.length);
        if (nbVideoSamples) {
          var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
          if (videoData && audioTrack.codec) this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
        }
      }
    }
    // logger.log('nb ID3 samples:' + audioTrack.samples.length);
    if (id3Track.samples.length) this.remuxID3(id3Track, timeOffset);

    // logger.log('nb ID3 samples:' + audioTrack.samples.length);
    if (textTrack.samples.length) this.remuxText(textTrack, timeOffset);

    // notify end of parsing
    this.observer.trigger(_events2.default.FRAG_PARSED);
  };

  MP4Remuxer.prototype.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
    var observer = this.observer,
        audioSamples = audioTrack.samples,
        videoSamples = videoTrack.samples,
        typeSupported = this.typeSupported,
        container = 'audio/mp4',
        tracks = {},
        data = { tracks: tracks },
        computePTSDTS = this._initPTS === undefined,
        initPTS = void 0,
        initDTS = void 0;

    if (computePTSDTS) initPTS = initDTS = Infinity;

    if (audioTrack.config && audioSamples.length) {
      // let's use audio sampling rate as MP4 time scale.
      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
      // using audio sampling rate here helps having an integer MP4 frame duration
      // this avoids potential rounding issue and AV sync issue
      audioTrack.timescale = audioTrack.samplerate;
      _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
      if (!audioTrack.isAAC) {
        if (typeSupported.mpeg) {
          // Chrome and Safari
          container = 'audio/mpeg';
          audioTrack.codec = '';
        } else if (typeSupported.mp3) {
          // Firefox
          audioTrack.codec = 'mp3';
        }
      }
      tracks.audio = {
        container: container,
        codec: audioTrack.codec,
        initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
        metadata: {
          channelCount: audioTrack.channelCount
        }
      };
      if (computePTSDTS) {
        // remember first PTS of this demuxing context. for audio, PTS = DTS
        initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
      }
    }

    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
      // let's use input time scale as MP4 video timescale
      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
      var inputTimeScale = videoTrack.inputTimeScale;
      videoTrack.timescale = inputTimeScale;
      tracks.video = {
        container: 'video/mp4',
        codec: videoTrack.codec,
        initSegment: _mp4Generator2.default.initSegment([videoTrack]),
        metadata: {
          width: videoTrack.width,
          height: videoTrack.height
        }
      };
      if (computePTSDTS) {
        initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
        initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
    }

    if (Object.keys(tracks).length) {
      observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
      this.ISGenerated = true;
      if (computePTSDTS) {
        this._initPTS = initPTS;
        this._initDTS = initDTS;
      }
    } else {
      observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
    }
  };

  MP4Remuxer.prototype.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
    var offset = 8,
        timeScale = track.timescale,
        mp4SampleDuration = void 0,
        mdat = void 0,
        moof = void 0,
        firstPTS = void 0,
        firstDTS = void 0,
        nextDTS = void 0,
        lastPTS = void 0,
        lastDTS = void 0,
        inputSamples = track.samples,
        outputSamples = [],
        nbSamples = inputSamples.length,
        ptsNormalize = this._PTSNormalize,
        initDTS = this._initDTS;

    // for (let i = 0; i < track.samples.length; i++) {
    //   let avcSample = track.samples[i];
    //   let units = avcSample.units;
    //   let unitsString = '';
    //   for (let j = 0; j < units.length ; j++) {
    //     unitsString += units[j].type + ',';
    //     if (units[j].data.length < 500) {
    //       unitsString += Hex.hexDump(units[j].data);
    //     }
    //   }
    //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
    // }

    // if parsed fragment is contiguous with last one, let's use last DTS value as reference
    var nextAvcDts = this.nextAvcDts;

    var isSafari = this.isSafari;

    if (nbSamples === 0) return;

    // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
    if (isSafari) {
      // also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 200 ms PTS gaps (timeScale/5)
      contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initDTS) < timeScale / 5);
    }

    if (!contiguous) {
      // if not contiguous, let's use target timeOffset
      nextAvcDts = timeOffset * timeScale;
    }

    // PTS is coded on 33bits, and can loop from -2^32 to 2^32
    // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
    inputSamples.forEach(function (sample) {
      sample.pts = ptsNormalize(sample.pts - initDTS, nextAvcDts);
      sample.dts = ptsNormalize(sample.dts - initDTS, nextAvcDts);
    });

    // sort video samples by DTS then PTS then demux id order
    inputSamples.sort(function (a, b) {
      var deltadts = a.dts - b.dts;
      var deltapts = a.pts - b.pts;
      return deltadts || deltapts || a.id - b.id;
    });

    // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
    var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
      return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
    }, 0);
    if (PTSDTSshift < 0) {
      _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
      for (var i = 0; i < inputSamples.length; i++) {
        inputSamples[i].dts += PTSDTSshift;
      }
    }

    // compute first DTS and last DTS, normalize them against reference value
    var sample = inputSamples[0];
    firstDTS = Math.max(sample.dts, 0);
    firstPTS = Math.max(sample.pts, 0);

    // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
    var delta = Math.round((firstDTS - nextAvcDts) / 90);
    // if fragment are contiguous, detect hole/overlapping between fragments
    if (contiguous) {
      if (delta) {
        if (delta > 1) _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');else if (delta < -1) _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');

        // remove hole/gap : set DTS to next expected DTS
        firstDTS = nextAvcDts;
        inputSamples[0].dts = firstDTS;
        // offset PTS as well, ensure that PTS is smaller or equal than new DTS
        firstPTS = Math.max(firstPTS - delta, nextAvcDts);
        inputSamples[0].pts = firstPTS;
        _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
      }
    }
    nextDTS = firstDTS;

    // compute lastPTS/lastDTS
    sample = inputSamples[inputSamples.length - 1];
    lastDTS = Math.max(sample.dts, 0);
    lastPTS = Math.max(sample.pts, 0, lastDTS);

    // on Safari let's signal the same sample duration for all samples
    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
    // set this constant duration as being the avg delta between consecutive DTS.
    if (isSafari) mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));

    var nbNalu = 0,
        naluLen = 0;
    for (var _i = 0; _i < nbSamples; _i++) {
      // compute total/avc sample length and nb of NAL units
      var _sample = inputSamples[_i],
          units = _sample.units,
          nbUnits = units.length,
          sampleLen = 0;
      for (var j = 0; j < nbUnits; j++) {
        sampleLen += units[j].data.length;
      }naluLen += sampleLen;
      nbNalu += nbUnits;
      _sample.length = sampleLen;

      // normalize PTS/DTS
      if (isSafari) {
        // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
        _sample.dts = firstDTS + _i * mp4SampleDuration;
      } else {
        // ensure sample monotonic DTS
        _sample.dts = Math.max(_sample.dts, firstDTS);
      }
      // ensure that computed value is greater or equal than sample DTS
      _sample.pts = Math.max(_sample.pts, _sample.dts);
    }

    /* concatenate the video data and construct the mdat in place
      (need 8 more bytes to fill length and mpdat type) */
    var mdatSize = naluLen + 4 * nbNalu + 8;
    try {
      mdat = new Uint8Array(mdatSize);
    } catch (err) {
      this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
      return;
    }
    var view = new DataView(mdat.buffer);
    view.setUint32(0, mdatSize);
    mdat.set(_mp4Generator2.default.types.mdat, 4);

    for (var _i2 = 0; _i2 < nbSamples; _i2++) {
      var avcSample = inputSamples[_i2],
          avcSampleUnits = avcSample.units,
          mp4SampleLength = 0,
          compositionTimeOffset = void 0;
      // convert NALU bitstream to MP4 format (prepend NALU with size field)
      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
        var unit = avcSampleUnits[_j],
            unitData = unit.data,
            unitDataLen = unit.data.byteLength;
        view.setUint32(offset, unitDataLen);
        offset += 4;
        mdat.set(unitData, offset);
        offset += unitDataLen;
        mp4SampleLength += 4 + unitDataLen;
      }

      if (!isSafari) {
        // expected sample duration is the Decoding Timestamp diff of consecutive samples
        if (_i2 < nbSamples - 1) {
          mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
        } else {
          var config = this.config,
              lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
          if (config.stretchShortVideoTrack) {
            // In some cases, a segment's audio track duration may exceed the video track duration.
            // Since we've already remuxed audio, and we know how long the audio track is, we look to
            // see if the delta to the next segment is longer than maxBufferHole.
            // If so, playback would potentially get stuck, so we artificially inflate
            // the duration of the last frame to minimize any potential gap between segments.
            var maxBufferHole = config.maxBufferHole,
                gapTolerance = Math.floor(maxBufferHole * timeScale),
                deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
            if (deltaToFrameEnd > gapTolerance) {
              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
              // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
              if (mp4SampleDuration < 0) mp4SampleDuration = lastFrameDuration;

              _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        }
        compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
      } else {
        compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
      }

      // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
      outputSamples.push({
        size: mp4SampleLength,
        // constant duration
        duration: mp4SampleDuration,
        cts: compositionTimeOffset,
        flags: {
          isLeading: 0,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradPrio: 0,
          dependsOn: avcSample.key ? 2 : 1,
          isNonSync: avcSample.key ? 0 : 1
        }
      });
    }
    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
    this.nextAvcDts = lastDTS + mp4SampleDuration;
    var dropped = track.dropped;
    track.len = 0;
    track.nbNalu = 0;
    track.dropped = 0;
    if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
      var flags = outputSamples[0].flags;
      // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
      // https://code.google.com/p/chromium/issues/detail?id=229412
      flags.dependsOn = 2;
      flags.isNonSync = 0;
    }
    track.samples = outputSamples;
    moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
    track.samples = [];

    var data = {
      data1: moof,
      data2: mdat,
      startPTS: firstPTS / timeScale,
      endPTS: (lastPTS + mp4SampleDuration) / timeScale,
      startDTS: firstDTS / timeScale,
      endDTS: this.nextAvcDts / timeScale,
      type: 'video',
      hasAudio: false,
      hasVideo: true,
      nb: outputSamples.length,
      dropped: dropped
    };
    this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
    return data;
  };

  MP4Remuxer.prototype.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
    var inputTimeScale = track.inputTimeScale,
        mp4timeScale = track.timescale,
        scaleFactor = inputTimeScale / mp4timeScale,
        mp4SampleDuration = track.isAAC ? 1024 : 1152,
        inputSampleDuration = mp4SampleDuration * scaleFactor,
        ptsNormalize = this._PTSNormalize,
        initDTS = this._initDTS,
        rawMPEG = !track.isAAC && this.typeSupported.mpeg;

    var offset = void 0,
        mp4Sample = void 0,
        fillFrame = void 0,
        mdat = void 0,
        moof = void 0,
        firstPTS = void 0,
        lastPTS = void 0,
        inputSamples = track.samples,
        outputSamples = [],
        nextAudioPts = this.nextAudioPts;

    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
    // for sake of clarity:
    // consecutive fragments are frags with
    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
    //  - less than 20 audio frames distance
    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
    // this helps ensuring audio continuity
    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
    contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);

    // compute normalized PTS
    inputSamples.forEach(function (sample) {
      sample.pts = sample.dts = ptsNormalize(sample.pts - initDTS, timeOffset * inputTimeScale);
    });

    // filter out sample with negative PTS that are not playable anyway
    // if we don't remove these negative samples, they will shift all audio samples forward.
    // leading to audio overlap between current / next fragment
    inputSamples = inputSamples.filter(function (sample) {
      return sample.pts >= 0;
    });

    // in case all samples have negative PTS, and have been filtered out, return now
    if (inputSamples.length === 0) return;

    if (!contiguous) {
      if (!accurateTimeOffset) {
        // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
        nextAudioPts = inputSamples[0].pts;
      } else {
        // if timeOffset is accurate, let's use it as predicted next audio PTS
        nextAudioPts = timeOffset * inputTimeScale;
      }
    }

    // If the audio track is missing samples, the frames seem to get "left-shifted" within the
    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
    // In an effort to prevent this from happening, we inject frames here where there are gaps.
    // When possible, we inject a silent frame; when that's not possible, we duplicate the last
    // frame.

    if (track.isAAC) {
      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
        // First, let's see how far off this frame is from where we expect it to be
        var sample = inputSamples[i],
            delta;
        var pts = sample.pts;
        delta = pts - nextPts;

        var duration = Math.abs(1000 * delta / inputTimeScale);

        // If we're overlapping by more than a duration, drop this sample
        if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
          _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
          inputSamples.splice(i, 1);
          track.len -= sample.unit.length;
          // Don't touch nextPtsNorm or i
        } // eslint-disable-line brace-style

        // Insert missing frames if:
        // 1: We're more than maxAudioFramesDrift frame away
        // 2: Not more than MAX_SILENT_FRAME_DURATION away
        // 3: currentTime (aka nextPtsNorm) is not 0
        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
            var missing = Math.round(delta / inputSampleDuration);
            _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
            for (var j = 0; j < missing; j++) {
              var newStamp = Math.max(nextPts, 0);
              fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
              if (!fillFrame) {
                _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.subarray();
              }
              inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
              track.len += fillFrame.length;
              nextPts += inputSampleDuration;
              i++;
            }

            // Adjust sample to next expected pts
            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          } else {
            // Otherwise, just adjust pts
            if (Math.abs(delta) > 0.1 * inputSampleDuration) {
              // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
            }
            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          }
      }
    }

    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
      var audioSample = inputSamples[_j2];
      var unit = audioSample.unit;
      var _pts = audioSample.pts;
      // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
      // if not first sample
      if (lastPTS !== undefined) {
        mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
      } else {
        var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
            numMissingFrames = 0;
        // if fragment are contiguous, detect hole/overlapping between fragments
        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
        if (contiguous && track.isAAC) {
          // log delta
          if (_delta) {
            if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
              numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
              _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
              if (numMissingFrames > 0) {
                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) fillFrame = unit.subarray();

                track.len += numMissingFrames * fillFrame.length;
              }
              // if we have frame overlap, overlapping for more than half a frame duraion
            } else if (_delta < -12) {
              // drop overlapping audio frames... browser will deal with it
              _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
              track.len -= unit.byteLength;
              continue;
            }
            // set PTS/DTS to expected PTS/DTS
            _pts = nextAudioPts;
          }
        }
        // remember first PTS of our audioSamples
        firstPTS = _pts;
        if (track.len > 0) {
          /* concatenate the audio data and construct the mdat in place
            (need 8 more bytes to fill length and mdat type) */
          var mdatSize = rawMPEG ? track.len : track.len + 8;
          offset = rawMPEG ? 0 : 8;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
            return;
          }
          if (!rawMPEG) {
            var view = new DataView(mdat.buffer);
            view.setUint32(0, mdatSize);
            mdat.set(_mp4Generator2.default.types.mdat, 4);
          }
        } else {
          // no audio samples
          return;
        }
        for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
          fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
          if (!fillFrame) {
            _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
            fillFrame = unit.subarray();
          }
          mdat.set(fillFrame, offset);
          offset += fillFrame.byteLength;
          mp4Sample = {
            size: fillFrame.byteLength,
            cts: 0,
            duration: 1024,
            flags: {
              isLeading: 0,
              isDependedOn: 0,
              hasRedundancy: 0,
              degradPrio: 0,
              dependsOn: 1
            }
          };
          outputSamples.push(mp4Sample);
        }
      }
      mdat.set(unit, offset);
      var unitLen = unit.byteLength;
      offset += unitLen;
      // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
      mp4Sample = {
        size: unitLen,
        cts: 0,
        duration: 0,
        flags: {
          isLeading: 0,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradPrio: 0,
          dependsOn: 1
        }
      };
      outputSamples.push(mp4Sample);
      lastPTS = _pts;
    }
    var lastSampleDuration = 0;
    var nbSamples = outputSamples.length;
    // set last sample duration as being identical to previous sample
    if (nbSamples >= 2) {
      lastSampleDuration = outputSamples[nbSamples - 2].duration;
      mp4Sample.duration = lastSampleDuration;
    }
    if (nbSamples) {
      // next audio sample PTS should be equal to last sample PTS + duration
      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
      // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
      track.len = 0;
      track.samples = outputSamples;
      if (rawMPEG) moof = new Uint8Array();else moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);

      track.samples = [];
      var start = firstPTS / inputTimeScale;
      var end = nextAudioPts / inputTimeScale;
      var audioData = {
        data1: moof,
        data2: mdat,
        startPTS: start,
        endPTS: end,
        startDTS: start,
        endDTS: end,
        type: 'audio',
        hasAudio: true,
        hasVideo: false,
        nb: nbSamples
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
      return audioData;
    }
    return null;
  };

  MP4Remuxer.prototype.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
    var inputTimeScale = track.inputTimeScale,
        mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
        scaleFactor = inputTimeScale / mp4timeScale,
        nextAudioPts = this.nextAudioPts,


    // sync with video's timestamp
    startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
        endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

    // one sample's duration value
    sampleDuration = 1024,
        frameDuration = scaleFactor * sampleDuration,


    // samples count of this segment's duration
    nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


    // silent frame
    silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

    _logger.logger.warn('remux empty Audio');
    // Can't remux if we can't generate a silent frame...
    if (!silentFrame) {
      _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
      return;
    }

    var samples = [];
    for (var i = 0; i < nbSamples; i++) {
      var stamp = startDTS + i * frameDuration;
      samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
      track.len += silentFrame.length;
    }
    track.samples = samples;

    this.remuxAudio(track, timeOffset, contiguous);
  };

  MP4Remuxer.prototype.remuxID3 = function remuxID3(track, timeOffset) {
    var length = track.samples.length,
        sample = void 0;
    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;
    var initDTS = this._initDTS;
    // consume samples
    if (length) {
      for (var index = 0; index < length; index++) {
        sample = track.samples[index];
        // setting id3 pts, dts to relative time
        // using this._initPTS and this._initDTS to calculate relative time
        sample.pts = (sample.pts - initPTS) / inputTimeScale;
        sample.dts = (sample.dts - initDTS) / inputTimeScale;
      }
      this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
        samples: track.samples
      });
    }

    track.samples = [];
    timeOffset = timeOffset;
  };

  MP4Remuxer.prototype.remuxText = function remuxText(track, timeOffset) {
    track.samples.sort(function (a, b) {
      return a.pts - b.pts;
    });

    var length = track.samples.length,
        sample = void 0;
    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;
    // consume samples
    if (length) {
      for (var index = 0; index < length; index++) {
        sample = track.samples[index];
        // setting text pts, dts to relative time
        // using this._initPTS and this._initDTS to calculate relative time
        sample.pts = (sample.pts - initPTS) / inputTimeScale;
      }
      this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
        samples: track.samples
      });
    }

    track.samples = [];
    timeOffset = timeOffset;
  };

  MP4Remuxer.prototype._PTSNormalize = function _PTSNormalize(value, reference) {
    var offset = void 0;
    if (reference === undefined) return value;

    if (reference < value) {
      // - 2^33
      offset = -8589934592;
    } else {
      // + 2^33
      offset = 8589934592;
    }
    /* PTS is 33bit (from 0 to 2^33 -1)
      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
      PTS looping occured. fill the gap */
    while (Math.abs(value - reference) > 4294967296) {
      value += offset;
    }return value;
  };

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/remux/passthrough-remuxer.js":
/*!************************************************************!*\
  !*** ./third_party/hlsjs/src/remux/passthrough-remuxer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _events = __webpack_require__(/*! ../events */ "./third_party/hlsjs/src/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * passthrough remuxer
                                                                                                                                                          */


var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  PassThroughRemuxer.prototype.destroy = function destroy() {};

  PassThroughRemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  PassThroughRemuxer.prototype.resetInitSegment = function resetInitSegment() {};

  PassThroughRemuxer.prototype.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
    var observer = this.observer;
    var streamType = '';
    if (audioTrack) streamType += 'audio';

    if (videoTrack) streamType += 'video';

    observer.trigger(_events2.default.FRAG_PARSING_DATA, {
      data1: rawData,
      startPTS: timeOffset,
      startDTS: timeOffset,
      type: streamType,
      hasAudio: !!audioTrack,
      hasVideo: !!videoTrack,
      nb: 1,
      dropped: 0
    });
    // notify end of parsing
    observer.trigger(_events2.default.FRAG_PARSED);
  };

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;

/***/ }),

/***/ "./third_party/hlsjs/src/task-loop.js":
/*!********************************************!*\
  !*** ./third_party/hlsjs/src/task-loop.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = undefined;

var _eventHandler = __webpack_require__(/*! ./event-handler */ "./third_party/hlsjs/src/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TaskLoop = function (_EventHandler) {
  _inherits(TaskLoop, _EventHandler);

  function TaskLoop(hls) {
    _classCallCheck(this, TaskLoop);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _EventHandler.call.apply(_EventHandler, [this, hls].concat(events)));

    _this._tickInterval = null;
    _this._tickCallCount = 0;
    return _this;
  }

  /**
   * @override
   */


  TaskLoop.prototype.destroy = function destroy() {
    this.clearInterval();
    _EventHandler.prototype.destroy.call(this);
  };

  /**
   * @returns {boolean}
   */


  TaskLoop.prototype.hasInterval = function hasInterval() {
    return this._tickInterval !== null;
  };

  /**
   * @param {number} millis Interval time (ms)
   * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
   */


  TaskLoop.prototype.setInterval = function (_setInterval) {
    function setInterval(_x) {
      return _setInterval.apply(this, arguments);
    }

    setInterval.toString = function () {
      return _setInterval.toString();
    };

    return setInterval;
  }(function (millis) {
    if (!this._tickInterval) {
      this._tickInterval = setInterval(this.tick.bind(this, false), millis);
      return true;
    }
    return false;
  });

  /**
   * @returns {boolean} True when interval was cleared, false when none was set (no effect)
   */


  TaskLoop.prototype.clearInterval = function (_clearInterval) {
    function clearInterval() {
      return _clearInterval.apply(this, arguments);
    }

    clearInterval.toString = function () {
      return _clearInterval.toString();
    };

    return clearInterval;
  }(function () {
    if (this._tickInterval) {
      clearInterval(this._tickInterval);
      this._tickInterval = null;
      return true;
    }
    return false;
  });

  /**
   *
   * @param {Wether to force async} forceAsync
   * @returns {boolean} True when async, false when sync
   */


  TaskLoop.prototype.tick = function tick() {
    this._tickCallCount++;
    if (this._tickCallCount === 1) {
      this.doTick();
      if (this._tickCallCount > 1) setTimeout(this.tick.bind(this), 0);

      this._tickCallCount = 0;
    }
  };

  /**
   * For subclass to implement task logic
   * @abstract
   */


  TaskLoop.prototype.doTick = function doTick() {
    throw new Error('TaskLoop is abstract and `doLoop` must be implemented');
  };

  return TaskLoop;
}(_eventHandler2.default);

exports.default = TaskLoop;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/attr-list.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/utils/attr-list.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') attrs = AttrList.parseAttrList(attrs);

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) this[attr] = attrs[attr];
    }
  }

  AttrList.prototype.decimalInteger = function decimalInteger(attrName) {
    var intValue = parseInt(this[attrName], 10);
    if (intValue > Number.MAX_SAFE_INTEGER) return Infinity;

    return intValue;
  };

  AttrList.prototype.hexadecimalInteger = function hexadecimalInteger(attrName) {
    if (this[attrName]) {
      var stringValue = (this[attrName] || '0x').slice(2);
      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

      var value = new Uint8Array(stringValue.length / 2);
      for (var i = 0; i < stringValue.length / 2; i++) {
        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
      }return value;
    } else {
      return null;
    }
  };

  AttrList.prototype.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
    var intValue = parseInt(this[attrName], 16);
    if (intValue > Number.MAX_SAFE_INTEGER) return Infinity;

    return intValue;
  };

  AttrList.prototype.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
    return parseFloat(this[attrName]);
  };

  AttrList.prototype.enumeratedString = function enumeratedString(attrName) {
    return this[attrName];
  };

  AttrList.prototype.decimalResolution = function decimalResolution(attrName) {
    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
    if (res === null) return undefined;

    return {
      width: parseInt(res[1], 10),
      height: parseInt(res[2], 10)
    };
  };

  AttrList.parseAttrList = function parseAttrList(input) {
    var match = void 0,
        attrs = {};
    ATTR_LIST_REGEX.lastIndex = 0;
    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
      var value = match[2],
          quote = '"';

      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) value = value.slice(1, -1);

      attrs[match[1]] = value;
    }
    return attrs;
  };

  return AttrList;
}();

exports.default = AttrList;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/binary-search.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/utils/binary-search.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var BinarySearch = {
  /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
  search: function search(list, comparisonFunction) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];

      var comparisonResult = comparisonFunction(currentElement);
      if (comparisonResult > 0) minIndex = currentIndex + 1;else if (comparisonResult < 0) maxIndex = currentIndex - 1;else return currentElement;
    }

    return null;
  }
};

exports.default = BinarySearch;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/cea-608-parser.js":
/*!*******************************************************!*\
  !*** ./third_party/hlsjs/src/utils/cea-608-parser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */

var specialCea608CharsCodes = {
  0x2a: 0xe1, // lowercase a, acute accent
  0x5c: 0xe9, // lowercase e, acute accent
  0x5e: 0xed, // lowercase i, acute accent
  0x5f: 0xf3, // lowercase o, acute accent
  0x60: 0xfa, // lowercase u, acute accent
  0x7b: 0xe7, // lowercase c with cedilla
  0x7c: 0xf7, // division symbol
  0x7d: 0xd1, // uppercase N tilde
  0x7e: 0xf1, // lowercase n tilde
  0x7f: 0x2588, // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae, // Registered symbol (R)
  0x81: 0xb0, // degree sign
  0x82: 0xbd, // 1/2 symbol
  0x83: 0xbf, // Inverted (open) question mark
  0x84: 0x2122, // Trademark symbol (TM)
  0x85: 0xa2, // Cents symbol
  0x86: 0xa3, // Pounds sterling
  0x87: 0x266a, // Music 8'th note
  0x88: 0xe0, // lowercase a, grave accent
  0x89: 0x20, // transparent space (regular)
  0x8a: 0xe8, // lowercase e, grave accent
  0x8b: 0xe2, // lowercase a, circumflex accent
  0x8c: 0xea, // lowercase e, circumflex accent
  0x8d: 0xee, // lowercase i, circumflex accent
  0x8e: 0xf4, // lowercase o, circumflex accent
  0x8f: 0xfb, // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1, // capital letter A with acute
  0x91: 0xc9, // capital letter E with acute
  0x92: 0xd3, // capital letter O with acute
  0x93: 0xda, // capital letter U with acute
  0x94: 0xdc, // capital letter U with diaresis
  0x95: 0xfc, // lowercase letter U with diaeresis
  0x96: 0x2018, // opening single quote
  0x97: 0xa1, // inverted exclamation mark
  0x98: 0x2a, // asterisk
  0x99: 0x2019, // closing single quote
  0x9a: 0x2501, // box drawings heavy horizontal
  0x9b: 0xa9, // copyright sign
  0x9c: 0x2120, // Service mark
  0x9d: 0x2022, // (round) bullet
  0x9e: 0x201c, // Left double quotation mark
  0x9f: 0x201d, // Right double quotation mark
  0xa0: 0xc0, // uppercase A, grave accent
  0xa1: 0xc2, // uppercase A, circumflex
  0xa2: 0xc7, // uppercase C with cedilla
  0xa3: 0xc8, // uppercase E, grave accent
  0xa4: 0xca, // uppercase E, circumflex
  0xa5: 0xcb, // capital letter E with diaresis
  0xa6: 0xeb, // lowercase letter e with diaresis
  0xa7: 0xce, // uppercase I, circumflex
  0xa8: 0xcf, // uppercase I, with diaresis
  0xa9: 0xef, // lowercase i, with diaresis
  0xaa: 0xd4, // uppercase O, circumflex
  0xab: 0xd9, // uppercase U, grave accent
  0xac: 0xf9, // lowercase u, grave accent
  0xad: 0xdb, // uppercase U, circumflex
  0xae: 0xab, // left-pointing double angle quotation mark
  0xaf: 0xbb, // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3, // Uppercase A, tilde
  0xb1: 0xe3, // Lowercase a, tilde
  0xb2: 0xcd, // Uppercase I, acute accent
  0xb3: 0xcc, // Uppercase I, grave accent
  0xb4: 0xec, // Lowercase i, grave accent
  0xb5: 0xd2, // Uppercase O, grave accent
  0xb6: 0xf2, // Lowercase o, grave accent
  0xb7: 0xd5, // Uppercase O, tilde
  0xb8: 0xf5, // Lowercase o, tilde
  0xb9: 0x7b, // Open curly brace
  0xba: 0x7d, // Closing curly brace
  0xbb: 0x5c, // Backslash
  0xbc: 0x5e, // Caret
  0xbd: 0x5f, // Underscore
  0xbe: 0x7c, // Pipe (vertical line)
  0xbf: 0x223c, // Tilde operator
  0xc0: 0xc4, // Uppercase A, umlaut
  0xc1: 0xe4, // Lowercase A, umlaut
  0xc2: 0xd6, // Uppercase O, umlaut
  0xc3: 0xf6, // Lowercase o, umlaut
  0xc4: 0xdf, // Esszett (sharp S)
  0xc5: 0xa5, // Yen symbol
  0xc6: 0xa4, // Generic currency sign
  0xc7: 0x2503, // Box drawings heavy vertical
  0xc8: 0xc5, // Uppercase A, ring
  0xc9: 0xe5, // Lowercase A, ring
  0xca: 0xd8, // Uppercase O, stroke
  0xcb: 0xf8, // Lowercase o, strok
  0xcc: 0x250f, // Box drawings heavy down and right
  0xcd: 0x2513, // Box drawings heavy down and left
  0xce: 0x2517, // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
  var charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) charCode = specialCea608CharsCodes[byte];

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
  verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
  time: null,
  verboseLevel: 0, // Only write errors
  setTime: function setTime(newTime) {
    this.time = newTime;
  },
  log: function log(severity, msg) {
    var minLevel = this.verboseFilter[severity];
    if (this.verboseLevel >= minLevel) console.log(this.time + ' [' + severity + '] ' + msg);
  }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];
  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }return hexArray;
};

var PenState = function () {
  function PenState(foreground, underline, italics, background, flash) {
    _classCallCheck(this, PenState);

    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  PenState.prototype.reset = function reset() {
    this.foreground = 'white';
    this.underline = false;
    this.italics = false;
    this.background = 'black';
    this.flash = false;
  };

  PenState.prototype.setStyles = function setStyles(styles) {
    var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
    for (var i = 0; i < attribs.length; i++) {
      var style = attribs[i];
      if (styles.hasOwnProperty(style)) this[style] = styles[style];
    }
  };

  PenState.prototype.isDefault = function isDefault() {
    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
  };

  PenState.prototype.equals = function equals(other) {
    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
  };

  PenState.prototype.copy = function copy(newPenState) {
    this.foreground = newPenState.foreground;
    this.underline = newPenState.underline;
    this.italics = newPenState.italics;
    this.background = newPenState.background;
    this.flash = newPenState.flash;
  };

  PenState.prototype.toString = function toString() {
    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
  };

  return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    _classCallCheck(this, StyledUnicodeChar);

    this.uchar = uchar || ' '; // unicode character
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  StyledUnicodeChar.prototype.reset = function reset() {
    this.uchar = ' ';
    this.penState.reset();
  };

  StyledUnicodeChar.prototype.setChar = function setChar(uchar, newPenState) {
    this.uchar = uchar;
    this.penState.copy(newPenState);
  };

  StyledUnicodeChar.prototype.setPenState = function setPenState(newPenState) {
    this.penState.copy(newPenState);
  };

  StyledUnicodeChar.prototype.equals = function equals(other) {
    return this.uchar === other.uchar && this.penState.equals(other.penState);
  };

  StyledUnicodeChar.prototype.copy = function copy(newChar) {
    this.uchar = newChar.uchar;
    this.penState.copy(newChar.penState);
  };

  StyledUnicodeChar.prototype.isEmpty = function isEmpty() {
    return this.uchar === ' ' && this.penState.isDefault();
  };

  return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
  function Row() {
    _classCallCheck(this, Row);

    this.chars = [];
    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }this.pos = 0;
    this.currPenState = new PenState();
  }

  Row.prototype.equals = function equals(other) {
    var equal = true;
    for (var i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].equals(other.chars[i])) {
        equal = false;
        break;
      }
    }
    return equal;
  };

  Row.prototype.copy = function copy(other) {
    for (var i = 0; i < NR_COLS; i++) {
      this.chars[i].copy(other.chars[i]);
    }
  };

  Row.prototype.isEmpty = function isEmpty() {
    var empty = true;
    for (var i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  };

  /**
     *  Set the cursor to a valid column.
     */


  Row.prototype.setCursor = function setCursor(absPos) {
    if (this.pos !== absPos) this.pos = absPos;

    if (this.pos < 0) {
      logger.log('ERROR', 'Negative cursor position ' + this.pos);
      this.pos = 0;
    } else if (this.pos > NR_COLS) {
      logger.log('ERROR', 'Too large cursor position ' + this.pos);
      this.pos = NR_COLS;
    }
  };

  /**
     * Move the cursor relative to current position.
     */


  Row.prototype.moveCursor = function moveCursor(relPos) {
    var newPos = this.pos + relPos;
    if (relPos > 1) {
      for (var i = this.pos + 1; i < newPos + 1; i++) {
        this.chars[i].setPenState(this.currPenState);
      }
    }
    this.setCursor(newPos);
  };

  /**
     * Backspace, move one step back and clear character.
     */


  Row.prototype.backSpace = function backSpace() {
    this.moveCursor(-1);
    this.chars[this.pos].setChar(' ', this.currPenState);
  };

  Row.prototype.insertChar = function insertChar(byte) {
    if (byte >= 0x90) {
      // Extended char
      this.backSpace();
    }
    var char = getCharForByte(byte);
    if (this.pos >= NR_COLS) {
      logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
      return;
    }
    this.chars[this.pos].setChar(char, this.currPenState);
    this.moveCursor(1);
  };

  Row.prototype.clearFromPos = function clearFromPos(startPos) {
    var i = void 0;
    for (i = startPos; i < NR_COLS; i++) {
      this.chars[i].reset();
    }
  };

  Row.prototype.clear = function clear() {
    this.clearFromPos(0);
    this.pos = 0;
    this.currPenState.reset();
  };

  Row.prototype.clearToEndOfRow = function clearToEndOfRow() {
    this.clearFromPos(this.pos);
  };

  Row.prototype.getTextString = function getTextString() {
    var chars = [];
    var empty = true;
    for (var i = 0; i < NR_COLS; i++) {
      var char = this.chars[i].uchar;
      if (char !== ' ') empty = false;

      chars.push(char);
    }
    if (empty) return '';else return chars.join('');
  };

  Row.prototype.setPenStyles = function setPenStyles(styles) {
    this.currPenState.setStyles(styles);
    var currChar = this.chars[this.pos];
    currChar.setPenState(this.currPenState);
  };

  return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
  function CaptionScreen() {
    _classCallCheck(this, CaptionScreen);

    this.rows = [];
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row());
    } // Note that we use zero-based numbering (0-14)

    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.reset();
  }

  CaptionScreen.prototype.reset = function reset() {
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows[i].clear();
    }this.currRow = NR_ROWS - 1;
  };

  CaptionScreen.prototype.equals = function equals(other) {
    var equal = true;
    for (var i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].equals(other.rows[i])) {
        equal = false;
        break;
      }
    }
    return equal;
  };

  CaptionScreen.prototype.copy = function copy(other) {
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows[i].copy(other.rows[i]);
    }
  };

  CaptionScreen.prototype.isEmpty = function isEmpty() {
    var empty = true;
    for (var i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  };

  CaptionScreen.prototype.backSpace = function backSpace() {
    var row = this.rows[this.currRow];
    row.backSpace();
  };

  CaptionScreen.prototype.clearToEndOfRow = function clearToEndOfRow() {
    var row = this.rows[this.currRow];
    row.clearToEndOfRow();
  };

  /**
     * Insert a character (without styling) in the current row.
     */


  CaptionScreen.prototype.insertChar = function insertChar(char) {
    var row = this.rows[this.currRow];
    row.insertChar(char);
  };

  CaptionScreen.prototype.setPen = function setPen(styles) {
    var row = this.rows[this.currRow];
    row.setPenStyles(styles);
  };

  CaptionScreen.prototype.moveCursor = function moveCursor(relPos) {
    var row = this.rows[this.currRow];
    row.moveCursor(relPos);
  };

  CaptionScreen.prototype.setCursor = function setCursor(absPos) {
    logger.log('INFO', 'setCursor: ' + absPos);
    var row = this.rows[this.currRow];
    row.setCursor(absPos);
  };

  CaptionScreen.prototype.setPAC = function setPAC(pacData) {
    logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
    var newRow = pacData.row - 1;
    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) newRow = this.nrRollUpRows - 1;

    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
    if (this.nrRollUpRows && this.currRow !== newRow) {
      // clear all rows first
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      } // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
      // topRowIndex - the start of rows to copy (inclusive index)
      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      // We only copy if the last position was already shown.
      // We use the cueStartTime value to check this.
      var lastOutputScreen = this.lastOutputScreen;
      if (lastOutputScreen) {
        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
        if (prevLineTime && prevLineTime < logger.time) {
          for (var _i = 0; _i < this.nrRollUpRows; _i++) {
            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
          }
        }
      }
    }

    this.currRow = newRow;
    var row = this.rows[this.currRow];
    if (pacData.indent !== null) {
      var indent = pacData.indent;
      var prevPos = Math.max(indent - 1, 0);
      row.setCursor(pacData.indent);
      pacData.color = row.chars[prevPos].penState.foreground;
    }
    var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
    this.setPen(styles);
  };

  /**
     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
     */


  CaptionScreen.prototype.setBkgData = function setBkgData(bkgData) {
    logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
    this.backSpace();
    this.setPen(bkgData);
    this.insertChar(0x20); // Space
  };

  CaptionScreen.prototype.setRollUpRows = function setRollUpRows(nrRows) {
    this.nrRollUpRows = nrRows;
  };

  CaptionScreen.prototype.rollUp = function rollUp() {
    if (this.nrRollUpRows === null) {
      logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
      return; // Not properly setup
    }
    logger.log('TEXT', this.getDisplayText());
    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
    var topRow = this.rows.splice(topRowIndex, 1)[0];
    topRow.clear();
    this.rows.splice(this.currRow, 0, topRow);
    logger.log('INFO', 'Rolling up');
    // logger.log('TEXT', this.get_display_text())
  };

  /**
    * Get all non-empty rows with as unicode text.
    */


  CaptionScreen.prototype.getDisplayText = function getDisplayText(asOneRow) {
    asOneRow = asOneRow || false;
    var displayText = [];
    var text = '';
    var rowNr = -1;
    for (var i = 0; i < NR_ROWS; i++) {
      var rowText = this.rows[i].getTextString();
      if (rowText) {
        rowNr = i + 1;
        if (asOneRow) displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');else displayText.push(rowText.trim());
      }
    }
    if (displayText.length > 0) {
      if (asOneRow) text = '[' + displayText.join(' | ') + ']';else text = displayText.join('\n');
    }
    return text;
  };

  CaptionScreen.prototype.getTextAndFormat = function getTextAndFormat() {
    return this.rows;
  };

  return CaptionScreen;
}();

// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
  function Cea608Channel(channelNumber, outputFilter) {
    _classCallCheck(this, Cea608Channel);

    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen();
    this.nonDisplayedMemory = new CaptionScreen();
    this.lastOutputScreen = new CaptionScreen();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.
  }

  Cea608Channel.prototype.reset = function reset() {
    this.mode = null;
    this.displayedMemory.reset();
    this.nonDisplayedMemory.reset();
    this.lastOutputScreen.reset();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
    this.lastCueEndTime = null;
  };

  Cea608Channel.prototype.getHandler = function getHandler() {
    return this.outputFilter;
  };

  Cea608Channel.prototype.setHandler = function setHandler(newHandler) {
    this.outputFilter = newHandler;
  };

  Cea608Channel.prototype.setPAC = function setPAC(pacData) {
    this.writeScreen.setPAC(pacData);
  };

  Cea608Channel.prototype.setBkgData = function setBkgData(bkgData) {
    this.writeScreen.setBkgData(bkgData);
  };

  Cea608Channel.prototype.setMode = function setMode(newMode) {
    if (newMode === this.mode) return;

    this.mode = newMode;
    logger.log('INFO', 'MODE=' + newMode);
    if (this.mode === 'MODE_POP-ON') {
      this.writeScreen = this.nonDisplayedMemory;
    } else {
      this.writeScreen = this.displayedMemory;
      this.writeScreen.reset();
    }
    if (this.mode !== 'MODE_ROLL-UP') {
      this.displayedMemory.nrRollUpRows = null;
      this.nonDisplayedMemory.nrRollUpRows = null;
    }
    this.mode = newMode;
  };

  Cea608Channel.prototype.insertChars = function insertChars(chars) {
    for (var i = 0; i < chars.length; i++) {
      this.writeScreen.insertChar(chars[i]);
    }var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
    logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
      logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
      this.outputDataUpdate();
    }
  };

  Cea608Channel.prototype.ccRCL = function ccRCL() {
    // Resume Caption Loading (switch mode to Pop On)
    logger.log('INFO', 'RCL - Resume Caption Loading');
    this.setMode('MODE_POP-ON');
  };

  Cea608Channel.prototype.ccBS = function ccBS() {
    // BackSpace
    logger.log('INFO', 'BS - BackSpace');
    if (this.mode === 'MODE_TEXT') return;

    this.writeScreen.backSpace();
    if (this.writeScreen === this.displayedMemory) this.outputDataUpdate();
  };

  Cea608Channel.prototype.ccAOF = function ccAOF() {// Reserved (formerly Alarm Off)

  };

  Cea608Channel.prototype.ccAON = function ccAON() {// Reserved (formerly Alarm On)

  };

  Cea608Channel.prototype.ccDER = function ccDER() {
    // Delete to End of Row
    logger.log('INFO', 'DER- Delete to End of Row');
    this.writeScreen.clearToEndOfRow();
    this.outputDataUpdate();
  };

  Cea608Channel.prototype.ccRU = function ccRU(nrRows) {
    // Roll-Up Captions-2,3,or 4 Rows
    logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
    this.writeScreen = this.displayedMemory;
    this.setMode('MODE_ROLL-UP');
    this.writeScreen.setRollUpRows(nrRows);
  };

  Cea608Channel.prototype.ccFON = function ccFON() {
    // Flash On
    logger.log('INFO', 'FON - Flash On');
    this.writeScreen.setPen({ flash: true });
  };

  Cea608Channel.prototype.ccRDC = function ccRDC() {
    // Resume Direct Captioning (switch mode to PaintOn)
    logger.log('INFO', 'RDC - Resume Direct Captioning');
    this.setMode('MODE_PAINT-ON');
  };

  Cea608Channel.prototype.ccTR = function ccTR() {
    // Text Restart in text mode (not supported, however)
    logger.log('INFO', 'TR');
    this.setMode('MODE_TEXT');
  };

  Cea608Channel.prototype.ccRTD = function ccRTD() {
    // Resume Text Display in Text mode (not supported, however)
    logger.log('INFO', 'RTD');
    this.setMode('MODE_TEXT');
  };

  Cea608Channel.prototype.ccEDM = function ccEDM() {
    // Erase Displayed Memory
    logger.log('INFO', 'EDM - Erase Displayed Memory');
    this.displayedMemory.reset();
    this.outputDataUpdate(true);
  };

  Cea608Channel.prototype.ccCR = function ccCR() {
    // Carriage Return
    logger.log('CR - Carriage Return');
    this.writeScreen.rollUp();
    this.outputDataUpdate(true);
  };

  Cea608Channel.prototype.ccENM = function ccENM() {
    // Erase Non-Displayed Memory
    logger.log('INFO', 'ENM - Erase Non-displayed Memory');
    this.nonDisplayedMemory.reset();
  };

  Cea608Channel.prototype.ccEOC = function ccEOC() {
    // End of Caption (Flip Memories)
    logger.log('INFO', 'EOC - End Of Caption');
    if (this.mode === 'MODE_POP-ON') {
      var tmp = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory;
      this.nonDisplayedMemory = tmp;
      this.writeScreen = this.nonDisplayedMemory;
      logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(true);
  };

  Cea608Channel.prototype.ccTO = function ccTO(nrCols) {
    // Tab Offset 1,2, or 3 columns
    logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
    this.writeScreen.moveCursor(nrCols);
  };

  Cea608Channel.prototype.ccMIDROW = function ccMIDROW(secondByte) {
    // Parse MIDROW command
    var styles = { flash: false };
    styles.underline = secondByte % 2 === 1;
    styles.italics = secondByte >= 0x2e;
    if (!styles.italics) {
      var colorIndex = Math.floor(secondByte / 2) - 0x10;
      var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
      styles.foreground = colors[colorIndex];
    } else {
      styles.foreground = 'white';
    }
    logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
    this.writeScreen.setPen(styles);
  };

  Cea608Channel.prototype.outputDataUpdate = function outputDataUpdate() {
    var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var t = logger.time;
    if (t === null) return;

    if (this.outputFilter) {
      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
        // Start of a new cue
        this.cueStartTime = t;
      } else {
        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
            if (dispatch === true && this.outputFilter.dispatchCue) this.outputFilter.dispatchCue();
          }
          this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
        }
      }
      this.lastOutputScreen.copy(this.displayedMemory);
    }
  };

  Cea608Channel.prototype.cueSplitAtTime = function cueSplitAtTime(t) {
    if (this.outputFilter) {
      if (!this.displayedMemory.isEmpty()) {
        if (this.outputFilter.newCue) this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);

        this.cueStartTime = t;
      }
    }
  };

  return Cea608Channel;
}();

var Cea608Parser = function () {
  function Cea608Parser(field, out1, out2) {
    _classCallCheck(this, Cea608Parser);

    this.field = field || 1;
    this.outputs = [out1, out2];
    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
    this.currChNr = -1; // Will be 1 or 2
    this.lastCmdA = null; // First byte of last command
    this.lastCmdB = null; // Second byte of last command
    this.bufferedData = [];
    this.startTime = null;
    this.lastTime = null;
    this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
  }

  Cea608Parser.prototype.getHandler = function getHandler(index) {
    return this.channels[index].getHandler();
  };

  Cea608Parser.prototype.setHandler = function setHandler(index, newHandler) {
    this.channels[index].setHandler(newHandler);
  };

  /**
     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
     */


  Cea608Parser.prototype.addData = function addData(t, byteList) {
    var cmdFound = void 0,
        a = void 0,
        b = void 0,
        charsFound = false;

    this.lastTime = t;
    logger.setTime(t);

    for (var i = 0; i < byteList.length; i += 2) {
      a = byteList[i] & 0x7f;
      b = byteList[i + 1] & 0x7f;
      if (a === 0 && b === 0) {
        this.dataCounters.padding += 2;
        continue;
      } else {
        logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
      }
      cmdFound = this.parseCmd(a, b);
      if (!cmdFound) cmdFound = this.parseMidrow(a, b);

      if (!cmdFound) cmdFound = this.parsePAC(a, b);

      if (!cmdFound) cmdFound = this.parseBackgroundAttributes(a, b);

      if (!cmdFound) {
        charsFound = this.parseChars(a, b);
        if (charsFound) {
          if (this.currChNr && this.currChNr >= 0) {
            var channel = this.channels[this.currChNr - 1];
            channel.insertChars(charsFound);
          } else {
            logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
          }
        }
      }
      if (cmdFound) {
        this.dataCounters.cmd += 2;
      } else if (charsFound) {
        this.dataCounters.char += 2;
      } else {
        this.dataCounters.other += 2;
        logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
      }
    }
  };

  /**
     * Parse Command.
     * @returns {Boolean} Tells if a command was found
     */


  Cea608Parser.prototype.parseCmd = function parseCmd(a, b) {
    var chNr = null;

    var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <= 0x2F;
    var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <= 0x23;
    if (!(cond1 || cond2)) return false;

    if (a === this.lastCmdA && b === this.lastCmdB) {
      this.lastCmdA = null;
      this.lastCmdB = null; // Repeated commands are dropped (once)
      logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
      return true;
    }

    if (a === 0x14 || a === 0x17) chNr = 1;else chNr = 2; // (a === 0x1C || a=== 0x1f)

    var channel = this.channels[chNr - 1];

    if (a === 0x14 || a === 0x1C) {
      if (b === 0x20) channel.ccRCL();else if (b === 0x21) channel.ccBS();else if (b === 0x22) channel.ccAOF();else if (b === 0x23) channel.ccAON();else if (b === 0x24) channel.ccDER();else if (b === 0x25) channel.ccRU(2);else if (b === 0x26) channel.ccRU(3);else if (b === 0x27) channel.ccRU(4);else if (b === 0x28) channel.ccFON();else if (b === 0x29) channel.ccRDC();else if (b === 0x2A) channel.ccTR();else if (b === 0x2B) channel.ccRTD();else if (b === 0x2C) channel.ccEDM();else if (b === 0x2D) channel.ccCR();else if (b === 0x2E) channel.ccENM();else if (b === 0x2F) channel.ccEOC();
    } else {
      // a == 0x17 || a == 0x1F
      channel.ccTO(b - 0x20);
    }
    this.lastCmdA = a;
    this.lastCmdB = b;
    this.currChNr = chNr;
    return true;
  };

  /**
     * Parse midrow styling command
     * @returns {Boolean}
     */


  Cea608Parser.prototype.parseMidrow = function parseMidrow(a, b) {
    var chNr = null;

    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
      if (a === 0x11) chNr = 1;else chNr = 2;

      if (chNr !== this.currChNr) {
        logger.log('ERROR', 'Mismatch channel in midrow parsing');
        return false;
      }
      var channel = this.channels[chNr - 1];
      channel.ccMIDROW(b);
      logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
      return true;
    }
    return false;
  };
  /**
     * Parse Preable Access Codes (Table 53).
     * @returns {Boolean} Tells if PAC found
     */


  Cea608Parser.prototype.parsePAC = function parsePAC(a, b) {
    var chNr = null;
    var row = null;

    var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1F) && b >= 0x40 && b <= 0x7F;
    var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5F;
    if (!(case1 || case2)) return false;

    if (a === this.lastCmdA && b === this.lastCmdB) {
      this.lastCmdA = null;
      this.lastCmdB = null;
      return true; // Repeated commands are dropped (once)
    }

    chNr = a <= 0x17 ? 1 : 2;

    if (b >= 0x40 && b <= 0x5F) {
      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
    } else {
      // 0x60 <= b <= 0x7F
      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
    }
    var pacData = this.interpretPAC(row, b);
    var channel = this.channels[chNr - 1];
    channel.setPAC(pacData);
    this.lastCmdA = a;
    this.lastCmdB = b;
    this.currChNr = chNr;
    return true;
  };

  /**
     * Interpret the second byte of the pac, and return the information.
     * @returns {Object} pacData with style parameters.
     */


  Cea608Parser.prototype.interpretPAC = function interpretPAC(row, byte) {
    var pacIndex = byte;
    var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

    if (byte > 0x5F) pacIndex = byte - 0x60;else pacIndex = byte - 0x40;

    pacData.underline = (pacIndex & 1) === 1;
    if (pacIndex <= 0xd) {
      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
    } else if (pacIndex <= 0xf) {
      pacData.italics = true;
      pacData.color = 'white';
    } else {
      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
    }
    return pacData; // Note that row has zero offset. The spec uses 1.
  };

  /**
     * Parse characters.
     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
     */


  Cea608Parser.prototype.parseChars = function parseChars(a, b) {
    var channelNr = null,
        charCodes = null,
        charCode1 = null;

    if (a >= 0x19) {
      channelNr = 2;
      charCode1 = a - 8;
    } else {
      channelNr = 1;
      charCode1 = a;
    }
    if (charCode1 >= 0x11 && charCode1 <= 0x13) {
      // Special character
      var oneCode = b;
      if (charCode1 === 0x11) oneCode = b + 0x50;else if (charCode1 === 0x12) oneCode = b + 0x70;else oneCode = b + 0x90;

      logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
      charCodes = [oneCode];
    } else if (a >= 0x20 && a <= 0x7f) {
      charCodes = b === 0 ? [a] : [a, b];
    }
    if (charCodes) {
      var hexCodes = numArrayToHexArray(charCodes);
      logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
      this.lastCmdA = null;
      this.lastCmdB = null;
    }
    return charCodes;
  };

  /**
    * Parse extended background attributes as well as new foreground color black.
    * @returns{Boolean} Tells if background attributes are found
    */


  Cea608Parser.prototype.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
    var bkgData = void 0,
        index = void 0,
        chNr = void 0,
        channel = void 0;

    var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
    var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
    if (!(case1 || case2)) return false;

    bkgData = {};
    if (a === 0x10 || a === 0x18) {
      index = Math.floor((b - 0x20) / 2);
      bkgData.background = backgroundColors[index];
      if (b % 2 === 1) bkgData.background = bkgData.background + '_semi';
    } else if (b === 0x2d) {
      bkgData.background = 'transparent';
    } else {
      bkgData.foreground = 'black';
      if (b === 0x2f) bkgData.underline = true;
    }
    chNr = a < 0x18 ? 1 : 2;
    channel = this.channels[chNr - 1];
    channel.setBkgData(bkgData);
    this.lastCmdA = null;
    this.lastCmdB = null;
    return true;
  };

  /**
     * Reset state of parser and its channels.
     */


  Cea608Parser.prototype.reset = function reset() {
    for (var i = 0; i < this.channels.length; i++) {
      if (this.channels[i]) this.channels[i].reset();
    }
    this.lastCmdA = null;
    this.lastCmdB = null;
  };

  /**
     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
     */


  Cea608Parser.prototype.cueSplitAtTime = function cueSplitAtTime(t) {
    for (var i = 0; i < this.channels.length; i++) {
      if (this.channels[i]) this.channels[i].cueSplitAtTime(t);
    }
  };

  return Cea608Parser;
}();

exports.default = Cea608Parser;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/codecs.js":
/*!***********************************************!*\
  !*** ./third_party/hlsjs/src/utils/codecs.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    'a3ds': true,
    'ac-3': true,
    'ac-4': true,
    'alac': true,
    'alaw': true,
    'dra1': true,
    'dts+': true,
    'dts-': true,
    'dtsc': true,
    'dtse': true,
    'dtsh': true,
    'ec-3': true,
    'enca': true,
    'g719': true,
    'g726': true,
    'm4ae': true,
    'mha1': true,
    'mha2': true,
    'mhm1': true,
    'mhm2': true,
    'mlpa': true,
    'mp4a': true,
    'raw ': true,
    'Opus': true,
    'samr': true,
    'sawb': true,
    'sawp': true,
    'sevc': true,
    'sqcp': true,
    'ssmv': true,
    'twos': true,
    'ulaw': true
  },
  video: {
    'avc1': true,
    'avc2': true,
    'avc3': true,
    'avc4': true,
    'avcp': true,
    'drac': true,
    'dvav': true,
    'dvhe': true,
    'encv': true,
    'hev1': true,
    'hvc1': true,
    'mjp2': true,
    'mp4v': true,
    'mvc1': true,
    'mvc2': true,
    'mvc3': true,
    'mvc4': true,
    'resv': true,
    'rv60': true,
    's263': true,
    'svc1': true,
    'svc2': true,
    'vc-1': true,
    'vp08': true,
    'vp09': true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}

exports.isCodecType = isCodecType;
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/cues.js":
/*!*********************************************!*\
  !*** ./third_party/hlsjs/src/utils/cues.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.newCue = newCue;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./third_party/hlsjs/src/utils/vttparser.js");

function newCue(track, startTime, endTime, captionScreen) {
  var row = void 0;
  var cue = void 0;
  var indenting = void 0;
  var indent = void 0;
  var text = void 0;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      // To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) endTime += 0.0001;

      cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

      if (indent >= 16) indent--;else indent++;

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) cue.line = r + 1;else cue.line = r > 7 ? r - 2 : r + 1;

      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}

/***/ }),

/***/ "./third_party/hlsjs/src/utils/discontinuities.js":
/*!********************************************************!*\
  !*** ./third_party/hlsjs/src/utils/discontinuities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPts = adjustPts;
exports.alignDiscontinuities = alignDiscontinuities;

var _binarySearch = __webpack_require__(/*! ./binary-search */ "./third_party/hlsjs/src/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) return 1;else if (candidate.cc > CC) return -1;else return 0;
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) shouldAlign = true;
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

// If a change in CC is detected, the PTS can no longer be relied upon
// Attempt to align the level by using the last level - find the last frag matching the current CC and use it's PTS
// as a reference
function alignDiscontinuities(lastFrag, lastLevel, details) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
  // try to align using programDateTime attribute (if available)
  if (details.PTSKnown === false && lastLevel && lastLevel.details && lastLevel.details.fragments && lastLevel.details.fragments.length) {
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastLevel.details.programDateTime;
    var newPDT = details.programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastLevel.details.fragments[0].start;
    if (!isNaN(sliding)) {
      _logger.logger.log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}

/***/ }),

/***/ "./third_party/hlsjs/src/utils/ewma-bandwidth-estimator.js":
/*!*****************************************************************!*\
  !*** ./third_party/hlsjs/src/utils/ewma-bandwidth-estimator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ewma = __webpack_require__(/*! ../utils/ewma */ "./third_party/hlsjs/src/utils/ewma.js");

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
                                                                                                                                                           * EWMA Bandwidth Estimator
                                                                                                                                                           *  - heavily inspired from shaka-player
                                                                                                                                                           * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                           * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                           * different half-lives.
                                                                                                                                                           */

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  EwmaBandWidthEstimator.prototype.sample = function sample(durationMs, numBytes) {
    durationMs = Math.max(durationMs, this.minDelayMs_);
    var bandwidth = 8000 * numBytes / durationMs,

    // console.log('instant bw:'+ Math.round(bandwidth));
    // we weight sample using loading duration....
    weight = durationMs / 1000;
    this.fast_.sample(weight, bandwidth);
    this.slow_.sample(weight, bandwidth);
  };

  EwmaBandWidthEstimator.prototype.canEstimate = function canEstimate() {
    var fast = this.fast_;
    return fast && fast.getTotalWeight() >= this.minWeight_;
  };

  EwmaBandWidthEstimator.prototype.getEstimate = function getEstimate() {
    if (this.canEstimate()) {
      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
      // Take the minimum of these two estimates.  This should have the effect of
      // adapting down quickly, but up more slowly.
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    } else {
      return this.defaultEstimate_;
    }
  };

  EwmaBandWidthEstimator.prototype.destroy = function destroy() {};

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/ewma.js":
/*!*********************************************!*\
  !*** ./third_party/hlsjs/src/utils/ewma.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  EWMA.prototype.sample = function sample(weight, value) {
    var adjAlpha = Math.pow(this.alpha_, weight);
    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
    this.totalWeight_ += weight;
  };

  EWMA.prototype.getTotalWeight = function getTotalWeight() {
    return this.totalWeight_;
  };

  EWMA.prototype.getEstimate = function getEstimate() {
    if (this.alpha_) {
      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
      return this.estimate_ / zeroFactor;
    } else {
      return this.estimate_;
    }
  };

  return EWMA;
}();

exports.default = EWMA;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/logger.js":
/*!***********************************************!*\
  !*** ./third_party/hlsjs/src/utils/logger.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/* globals self: false */

// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) args[0] = formatMsg(type, args[0]);

      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/output-filter.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/utils/output-filter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, trackName) {
    _classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.trackName = trackName;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  OutputFilter.prototype.dispatchCue = function dispatchCue() {
    if (this.startTime === null) return;

    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
    this.startTime = null;
  };

  OutputFilter.prototype.newCue = function newCue(startTime, endTime, screen) {
    if (this.startTime === null || this.startTime > startTime) this.startTime = startTime;

    this.endTime = endTime;
    this.screen = screen;
    this.timelineController.createCaptionsTrack(this.trackName);
  };

  return OutputFilter;
}();

exports.default = OutputFilter;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/texttrack-utils.js":
/*!********************************************************!*\
  !*** ./third_party/hlsjs/src/utils/texttrack-utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.sendAddTrackEvent = sendAddTrackEvent;
exports.clearCurrentCues = clearCurrentCues;
function sendAddTrackEvent(track, videoEl) {
  var event = null;
  try {
    event = new window.Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

/***/ }),

/***/ "./third_party/hlsjs/src/utils/time-ranges.js":
/*!****************************************************!*\
  !*** ./third_party/hlsjs/src/utils/time-ranges.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }return log;
  }
};

exports.default = TimeRanges;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/vttcue.js":
/*!***********************************************!*\
  !*** ./third_party/hlsjs/src/utils/vttcue.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) return window.VTTCue;

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') return false;

    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') return false;

    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') return;

      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) cue = document.createElement('custom');else baseObj.enumerable = true;

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') throw new TypeError('Start time must be set to a number.');

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') throw new TypeError('End time must be set to a number.');

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) throw new SyntaxError('An invalid or illegal string was specified.');

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) throw new SyntaxError('An invalid number or illegal string was specified.');

        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) throw new SyntaxError('An invalid or illegal string was specified.');

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) throw new Error('Position must be between 0 and 100.');

        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) throw new SyntaxError('An invalid or illegal string was specified.');

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) throw new Error('Size must be between 0 and 100.');

        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) throw new SyntaxError('An invalid or illegal string was specified.');

        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) return cue;
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

/***/ }),

/***/ "./third_party/hlsjs/src/utils/vttparser.js":
/*!**************************************************!*\
  !*** ./third_party/hlsjs/src/utils/vttparser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.fixLineBreaks = undefined;

var _vttcue = __webpack_require__(/*! ./vttcue */ "./third_party/hlsjs/src/utils/vttcue.js");

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) return '';

      if (typeof data !== 'string') throw new Error('Error - expected string data.');

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) return null;

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') this.values[k] = v;
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) return this.has(k) ? this.values[k] : dflt[defaultKey];

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m = void 0;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') continue;

    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) continue;

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) throw new Error('Malformed timestamp: ' + oInput);

    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) settings.set('snapToLines', false);

          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) settings.alt('lineAlign', vals[1], ['start', center, 'end']);

          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);

          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') ++pos;

      if (buffer[pos] === '\n') ++pos;

      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line = void 0;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) return this;

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^()?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) throw new Error('Malformed WebVTT signature.');

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) return this;

        if (!alreadyCollectedLine) line = collectNextLine();else alreadyCollectedLine = false;

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) self.state = 'ID';

            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) continue;

            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) self.oncue(self.cue);

              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) self.cue.text += '\n';

            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) self.state = 'ID';

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) self.oncue(self.cue);

      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') throw new Error('Malformed WebVTT signature.');
    } catch (e) {
      throw e;
    }
    if (self.onflush) self.onflush();

    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/webvtt-parser.js":
/*!******************************************************!*\
  !*** ./third_party/hlsjs/src/utils/webvtt-parser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./third_party/hlsjs/src/utils/vttparser.js");

var _vttparser2 = _interopRequireDefault(_vttparser);

var _id = __webpack_require__(/*! ../demux/id3 */ "./third_party/hlsjs/src/demux/id3.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
  return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) return -1;

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;

  return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;
  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC];

  // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }

  // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed
  while (prevCC && prevCC.new) {
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
  parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    var re = /\r\n|\n\r|\n|\r/g;
    // Uint8Array.prototype.reduce is not implemented in IE11
    var vttLines = (0, _id.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

    var cueTime = '00:00.000';
    var mpegTs = 0;
    var localTime = 0;
    var presentationTime = 0;
    var cues = [];
    var parsingError = void 0;
    var inHeader = true;
    // let VTTCue = VTTCue || window.TextTrackCue;

    // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
    var parser = new _vttparser2.default();

    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      var currCC = vttCCs[cc];
      var cueOffset = vttCCs.ccOffset;

      // Update offsets for new discontinuities
      if (currCC && currCC.new) {
        if (localTime !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, presentationTime);
        }
      }

      if (presentationTime) {
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
      }

      cue.startTime += cueOffset - localTime;
      cue.endTime += cueOffset - localTime;

      // Create a unique hash id for a cue based on start/end times and text.
      // This helps timeline-controller to avoid showing repeated captions.
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

      // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
      cue.text = decodeURIComponent(encodeURIComponent(cue.text));
      if (cue.endTime > 0) cues.push(cue);
    };

    parser.onparsingerror = function (e) {
      parsingError = e;
    };

    parser.onflush = function () {
      if (parsingError && errorCallBack) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(function (line) {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.substr(16).split(',').forEach(function (timestamp) {
            if (startsWith(timestamp, 'LOCAL:')) cueTime = timestamp.substr(6);else if (startsWith(timestamp, 'MPEGTS:')) mpegTs = parseInt(timestamp.substr(7));
          });
          try {
            // Calculate subtitle offset in milliseconds.
            // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
            syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
            // Adjust MPEGTS by sync PTS.
            mpegTs -= syncPTS;
            // Convert cue time to seconds
            localTime = cueString2millis(cueTime) / 1000;
            // Convert MPEGTS to seconds from 90kHz.
            presentationTime = mpegTs / 90000;

            if (localTime === -1) parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          } catch (e) {
            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });

    parser.flush();
  }
};

exports.default = WebVTTParser;

/***/ }),

/***/ "./third_party/hlsjs/src/utils/xhr-loader.js":
/*!***************************************************!*\
  !*** ./third_party/hlsjs/src/utils/xhr-loader.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _logger = __webpack_require__(/*! ../utils/logger */ "./third_party/hlsjs/src/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * XHR based logger
                                                                                                                                                          */

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) this.xhrSetup = config.xhrSetup;
  }

  XhrLoader.prototype.destroy = function destroy() {
    this.abort();
    this.loader = null;
  };

  XhrLoader.prototype.abort = function abort() {
    var loader = this.loader;
    if (loader && loader.readyState !== 4) {
      this.stats.aborted = true;
      loader.abort();
    }

    window.clearTimeout(this.requestTimeout);
    this.requestTimeout = null;
    window.clearTimeout(this.retryTimeout);
    this.retryTimeout = null;
  };

  XhrLoader.prototype.load = function load(context, config, callbacks) {
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.stats = { trequest: performance.now(), retry: 0 };
    this.retryDelay = config.retryDelay;
    this.loadInternal();
  };

  XhrLoader.prototype.loadInternal = function loadInternal() {
    var xhr = void 0,
        context = this.context;
    xhr = this.loader = new XMLHttpRequest();

    var stats = this.stats;
    stats.tfirst = 0;
    stats.loaded = 0;
    var xhrSetup = this.xhrSetup;

    try {
      if (xhrSetup) {
        try {
          xhrSetup(xhr, context.url);
        } catch (e) {
          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
          xhr.open('GET', context.url, true);
          xhrSetup(xhr, context.url);
        }
      }
      if (!xhr.readyState) xhr.open('GET', context.url, true);
    } catch (e) {
      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
      this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
      return;
    }

    if (context.rangeEnd) xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));

    xhr.onreadystatechange = this.readystatechange.bind(this);
    xhr.onprogress = this.loadprogress.bind(this);
    xhr.responseType = context.responseType;

    // setup timeout before we perform request
    this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
    xhr.send();
  };

  XhrLoader.prototype.readystatechange = function readystatechange(event) {
    var xhr = event.currentTarget,
        readyState = xhr.readyState,
        stats = this.stats,
        context = this.context,
        config = this.config;

    // don't proceed if xhr has been aborted
    if (stats.aborted) return;

    // >= HEADERS_RECEIVED
    if (readyState >= 2) {
      // clear xhr timeout and rearm it if readyState less than 4
      window.clearTimeout(this.requestTimeout);
      if (stats.tfirst === 0) stats.tfirst = Math.max(performance.now(), stats.trequest);

      if (readyState === 4) {
        var status = xhr.status;
        // http status between 200 to 299 are all successful
        if (status >= 200 && status < 300) {
          stats.tload = Math.max(stats.tfirst, performance.now());
          var data = void 0,
              len = void 0;
          if (context.responseType === 'arraybuffer') {
            data = xhr.response;
            len = data.byteLength;
          } else {
            data = xhr.responseText;
            len = data.length;
          }
          stats.loaded = stats.total = len;
          var response = { url: xhr.responseURL, data: data };
          this.callbacks.onSuccess(response, stats, context, xhr);
        } else {
          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
            _logger.logger.error(status + ' while loading ' + context.url);
            this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
          } else {
            // retry
            _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
            // aborts and resets internal state
            this.destroy();
            // schedule retry
            this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
            // set exponential backoff
            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
            stats.retry++;
          }
        }
      } else {
        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
        this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
      }
    }
  };

  XhrLoader.prototype.loadtimeout = function loadtimeout() {
    _logger.logger.warn('timeout while loading ' + this.context.url);
    this.callbacks.onTimeout(this.stats, this.context, null);
  };

  XhrLoader.prototype.loadprogress = function loadprogress(event) {
    var xhr = event.currentTarget,
        stats = this.stats;

    stats.loaded = event.loaded;
    if (event.lengthComputable) stats.total = event.total;

    var onProgress = this.callbacks.onProgress;
    if (onProgress) {
      // third arg is to provide on progress data
      onProgress(stats, this.context, null, xhr);
    }
  };

  return XhrLoader;
}();

exports.default = XhrLoader;

/***/ })

/******/ });
//# sourceMappingURL=liteH5Player.debug.js.map